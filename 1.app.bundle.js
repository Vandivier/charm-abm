webpackJsonp([1],{

/***/ 5:
/*!************************************************!*\
  !*** ./node_modules/asx-abm/dist/AS.module.js ***!
  \************************************************/
/*! exports provided: AgentSet, Animator, AscDataSet, Color, ColorMap, DataSet, DataSetIO, Int24, Link, Links, Model, Patch, Patches, RGBADataSet, RGBDataSet, SpriteSheet, Three, ThreeMeshes, Turtle, Turtles, World, util */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AgentSet\", function() { return AgentSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Animator\", function() { return Animator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AscDataSet\", function() { return AscDataSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return Color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorMap\", function() { return ColorMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataSet\", function() { return DataSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataSetIO\", function() { return DataSetIO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int24\", function() { return Int24; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Link\", function() { return Link; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Links\", function() { return Links; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Model\", function() { return Model; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Patch\", function() { return Patch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Patches\", function() { return Patches; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBADataSet\", function() { return RGBADataSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBDataSet\", function() { return RGBDataSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpriteSheet\", function() { return SpriteSheet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Three\", function() { return Three; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ThreeMeshes\", function() { return Meshes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Turtle\", function() { return Turtle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Turtles\", function() { return Turtles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"World\", function() { return World; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"util\", function() { return util; });\n/* eslint-disable */\r\n\r\nif (!THREE.OrbitControls && OrbitControls) THREE.OrbitControls = OrbitControls;\r\n\r\n// A set of useful misc utils which will eventually move to individual files.\r\n// Note we use arrow functions one-liners, more likely to be optimized.\r\n// REMIND: Test optimization, if none, remove arrow one-liners.\r\n\r\nconst util = {\r\n\r\n// ### Types\r\n\r\n  // Fixing the javascript [typeof operator](https://goo.gl/Efdzk5)\r\n  typeOf: (obj) => ({}).toString.call(obj).match(/\\s(\\w+)/)[1].toLowerCase(),\r\n  isOneOf: (obj, array) => array.includes(util.typeOf(obj)),\r\n  // isUintArray: (obj) => util.typeOf(obj).match(/uint.*array/),\r\n  isUintArray: (obj) => /^uint.*array$/.test(util.typeOf(obj)),\r\n  isIntArray: (obj) => /^int.*array$/.test(util.typeOf(obj)),\r\n  isFloatArray: (obj) => /^float.*array$/.test(util.typeOf(obj)),\r\n  isImage: (obj) => util.typeOf(obj) === 'image',\r\n  isImageable: (obj) => util.isOneOf(obj,\r\n    ['image', 'htmlimageelement', 'htmlcanvaselement']),\r\n  // Is obj TypedArray? If obj.buffer not present, works, type is 'undefined'\r\n  isTypedArray: (obj) => util.typeOf(obj.buffer) === 'arraybuffer',\r\n  // Is a number an integer (rather than a float w/ non-zero fractional part)\r\n  isInteger: Number.isInteger || ((num) => Math.floor(num) === num),\r\n  // Is obj a string?\r\n  isString: (obj) => typeof obj === 'string',\r\n  // Check [big/little endian](https://en.wikipedia.org/wiki/Endianness)\r\n  isLittleEndian () {\r\n    const d32 = new Uint32Array([0x01020304]);\r\n    return (new Uint8ClampedArray(d32.buffer))[0] === 4\r\n  },\r\n\r\n  // Throw an error with string.\r\n  // Use instead of `throw message` for better debugging\r\n  // error: (message) => { throw new Error(message) },\r\n\r\n  // Identity fcn, returning its argument unchanged. Used in callbacks\r\n  identity: (o) => o,\r\n  // No-op function, does nothing. Used for default callback.\r\n  noop: () => {},\r\n  // Return function returning an object's property.  Property in fcn closure.\r\n  propFcn: (prop) => (o) => o[prop],\r\n\r\n  // Convert Array or TypedArray to given Type (Array or TypedArray).\r\n  // Result same length as array, precision may be lost.\r\n  convertArray (array, Type) {\r\n    const Type0 = array.constructor;\r\n    if (Type0 === Type) return array  // return array if already same Type\r\n    return Type.from(array) // Use .from (both TypedArrays and Arrays)\r\n  },\r\n  // Convert to/from new Uint8Array view onto an Array or TypedArray.\r\n  // Arrays converted to ArrayType, default Float64Array.\r\n  // Return will in general be a different length than array\r\n  arrayToBuffer (array, ArrayType = Float64Array) {\r\n    if (array.constructor === Array) array = new ArrayType(array);\r\n    return new Uint8Array(array.buffer)\r\n  },\r\n  bufferToArray (uint8array, Type, ArrayType = Float64Array) {\r\n    if (Type === Array) Type = ArrayType;\r\n    return (Type === Array)\r\n      ? Array.from(new ArrayType(uint8array.buffer))\r\n      : new Type(uint8array.buffer)\r\n    // return new Type(uint8array.buffer)\r\n  },\r\n\r\n  // Convert between Uint8Array buffer and base64 string.\r\n  // https://coolaj86.com/articles/typedarray-buffer-to-base64-in-javascript/\r\n  // Stack Overflow: https://goo.gl/xscs8T\r\n  bufferToBase64 (uint8Array) {\r\n    const binstr = Array.prototype.map.call(uint8Array, (ch) =>\r\n      String.fromCharCode(ch)\r\n    ).join('');\r\n    return btoa(binstr)\r\n  },\r\n  base64ToBuffer (base64) {\r\n    const binstr = atob(base64);\r\n    const uint8Array = new Uint8Array(binstr.length);\r\n    Array.prototype.forEach.call(binstr, (ch, i) => {\r\n      uint8Array[i] = ch.charCodeAt(0);\r\n    });\r\n    return uint8Array\r\n  },\r\n\r\n// ### Debug\r\n\r\n  // Print a message just once.\r\n  logOnce (msg) {\r\n    if (!this.logOnceMsgSet) this.logOnceMsgSet = new Set();\r\n    if (!this.logOnceMsgSet.has(msg)) {\r\n      console.log(msg);\r\n      this.logOnceMsgSet.add(msg);\r\n    }\r\n  },\r\n  warn (msg) {\r\n    this.logOnce('Warning: ' + msg);\r\n  },\r\n\r\n  // Use chrome/ffox/ie console.time()/timeEnd() performance functions\r\n  timeit (f, runs = 1e5, name = 'test') {\r\n    console.time(name);\r\n    for (let i = 0; i < runs; i++) f(i);\r\n    console.timeEnd(name);\r\n  },\r\n\r\n  pps (obj, title = '') {\r\n    if (title) console.log(title);   // eslint-disable-line\r\n    let count = 1;\r\n    let str = '';\r\n    while (obj) {\r\n      if (typeof obj === 'function') {\r\n        str = obj.constructor.toString();\r\n      } else {\r\n        const okeys = Object.keys(obj);\r\n        str = okeys.length > 0\r\n          ? `[${okeys.join(', ')}]` : `[${obj.constructor.name}]`;\r\n      }\r\n      console.log(`[${count++}]: ${str}`);\r\n      obj = Object.getPrototypeOf(obj);\r\n    }\r\n  },\r\n\r\n  // addToDom: add an element to the doeument body.\r\n  addToDom (src, type, parent = document.body) {\r\n    if (type) {\r\n      type = document.createElement(type);\r\n      src = type.textContent = src;\r\n    }\r\n    parent.appendChild(src);\r\n  },\r\n\r\n  // Return a string representation of an array of arrays\r\n  arraysToString: (arrays) => arrays.map((a) => `[${a}]`).join(','),\r\n\r\n  // Return array of strings of fixed floats to given precision\r\n  fixedStrings (array, digits = 4) {\r\n    array = this.convertArray(array, Array); // Only Array stores strings.\r\n    return array.map((n) => n.toFixed(digits))\r\n  },\r\n\r\n  // Merge from's key/val pairs into to the global window namespace\r\n  toWindow (obj) {\r\n    Object.assign(window, obj);\r\n    console.log('toWindow:', Object.keys(obj).join(', '));\r\n  },\r\n\r\n// ### HTML, CSS, DOM\r\n\r\n  // REST: Parse the query, returning an object of key/val pairs.\r\n  parseQueryString () {\r\n    const results = {};\r\n    const query = document.location.search.substring(1);\r\n    query.split('&').forEach((s) => {\r\n      const param = s.split('=');\r\n      // If just key, no val, set val to true\r\n      results[param[0]] = (param.length === 1) ? true : param[1];\r\n    });\r\n    return results\r\n  },\r\n\r\n  // Create dynamic `<script>` tag, appending to `<head>`\r\n  //   <script src=\"./test/src/three0.js\" type=\"module\"></script>\r\n  setScript (path, props = {}) {\r\n    const scriptTag = document.createElement('script');\r\n    scriptTag.src = path;\r\n    // this.forEach(props, (val, key) => { scriptTag[key] = val })\r\n    Object.assign(scriptTag, props);\r\n    document.querySelector('head').appendChild(scriptTag);\r\n  },\r\n\r\n  // Get element (i.e. canvas) relative x,y position from event/mouse position.\r\n  getEventXY (element, evt) { // http://goo.gl/356S91\r\n    const rect = element.getBoundingClientRect();\r\n    return [ evt.clientX - rect.left, evt.clientY - rect.top ]\r\n  },\r\n\r\n  // Set the text font, align and baseline drawing parameters.\r\n  // Obj can be either a canvas context or a DOM element\r\n  // See [reference](http://goo.gl/AvEAq) for details.\r\n  // * font is a HTML/CSS string like: \"9px sans-serif\"\r\n  // * align is left right center start end\r\n  // * baseline is top hanging middle alphabetic ideographic bottom\r\n  setTextParams (obj, font, align = 'center', baseline = 'middle') {\r\n    obj.font = font; obj.textAlign = align; obj.textBaseline = baseline;\r\n  },\r\n\r\n// ### Math\r\n\r\n  // Return random int/float in [0,max) or [min,max) or [-r/2,r/2)\r\n  randomInt: (max) => Math.floor(Math.random() * max),\r\n  randomInt2: (min, max) => min + Math.floor(Math.random() * (max - min)),\r\n  randomFloat: (max) => Math.random() * max,\r\n  randomFloat2: (min, max) => min + Math.random() * (max - min),\r\n  randomCentered: (r) => util.randomFloat2(-r / 2, r / 2),\r\n  // min: (a, b) => (a < b) ? a : b, // Math.max/min now faster, yay!\r\n  // max: (a, b) => (a < b) ? b : a,\r\n\r\n  // Return float Gaussian normal with given mean, std deviation.\r\n  randomNormal (mean = 0.0, sigma = 1.0) { // Box-Muller\r\n    const [u1, u2] = [1.0 - Math.random(), Math.random()]; // ui in 0,1\r\n    const norm = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\r\n    return norm * sigma + mean\r\n  },\r\n\r\n  // Return whether num is [Power of Two](http://goo.gl/tCfg5). Very clever!\r\n  isPowerOf2: (num) => (num & (num - 1)) === 0, // twgl library\r\n  // Return next greater power of two. There are faster, see:\r\n  // [Stack Overflow](https://goo.gl/zvD78e)\r\n  nextPowerOf2: (num) => Math.pow(2, Math.ceil(Math.log2(num))),\r\n\r\n  // Trims decimal digits of float to reduce size.\r\n  fixed (n, digits = 4) {\r\n    const p = Math.pow(10, digits);\r\n    return Math.round(n * p) / p\r\n  },\r\n\r\n  // A [modulus](http://mathjs.org/docs/reference/functions/mod.html)\r\n  // function rather than %, the remainder function.\r\n  // [`((v % n) + n) % n`](http://goo.gl/spr24) also works.\r\n  mod: (v, n) => ((v % n) + n) % n, // v - n * Math.floor(v / n),\r\n  // Wrap v around min, max values if v outside min, max\r\n  wrap: (v, min, max) => min + util.mod(v - min, max - min),\r\n  // Clamp a number to be between min/max.\r\n  // Much faster than Math.max(Math.min(v, max), min)\r\n  clamp (v, min, max) {\r\n    if (v < min) return min\r\n    if (v > max) return max\r\n    return v\r\n  },\r\n  // Return true is val in [min, max] enclusive\r\n  between: (val, min, max) => min <= val && val <= max,\r\n\r\n  // Return a linear interpolation between lo and hi.\r\n  // Scale is in [0-1], a percentage, and the result is in [lo,hi]\r\n  // If lo>hi, scaling is from hi end of range.\r\n  // [Why the name `lerp`?](http://goo.gl/QrzMc)\r\n  lerp: (lo, hi, scale) =>\r\n    lo <= hi ? lo + (hi - lo) * scale : lo - (lo - hi) * scale,\r\n  // Calculate the lerp scale given lo/hi pair and a number between them.\r\n  lerpScale: (number, lo, hi) => (number - lo) / (hi - lo),\r\n\r\n// ### Geometry\r\n\r\n  // Degrees & Radians\r\n  // radians: (degrees) => util.mod(degrees * Math.PI / 180, Math.PI * 2),\r\n  // degrees: (radians) => util.mod(radians * 180 / Math.PI, 360),\r\n  radians: (degrees) => degrees * Math.PI / 180,\r\n  degrees: (radians) => radians * 180 / Math.PI,\r\n  // Heading & Angles:\r\n  // * Heading is 0-up (y-axis), clockwise angle measured in degrees.\r\n  // * Angle is euclidean: 0-right (x-axis), counterclockwise in radians\r\n  heading (radians) { // angleToHeading?\r\n    const degrees = this.degrees(radians);\r\n    return this.mod((90 - degrees), 360)\r\n  },\r\n  angle (heading) { // headingToAngle?\r\n    const degrees = this.mod(360 - heading, 360);\r\n    return this.radians(degrees)\r\n  },\r\n  // Return angle (radians) in (-pi,pi] that added to rad0 = rad1\r\n  // See NetLogo's [subtract-headings](http://goo.gl/CjoHuV) for explanation\r\n  subtractRadians (rad1, rad0) {\r\n    let dr = this.mod(rad1 - rad0, 2 * Math.PI);\r\n    if (dr > Math.PI) dr = dr - 2 * Math.PI;\r\n    return dr\r\n  },\r\n  // Above using headings (degrees) returning degrees in (-180, 180]\r\n  subtractHeadings (deg1, deg0) {\r\n    let dAngle = this.mod(deg1 - deg0, 360);\r\n    if (dAngle > 180) dAngle = dAngle - 360;\r\n    return dAngle\r\n  },\r\n  // Return angle in [-pi,pi] radians from (x,y) to (x1,y1)\r\n  // [See: Math.atan2](http://goo.gl/JS8DF)\r\n  radiansToward: (x, y, x1, y1) => Math.atan2(y1 - y, x1 - x),\r\n  // Above using headings (degrees) returning degrees in [-90, 90]\r\n  headingToward (x, y, x1, y1) {\r\n    return this.heading(this.radiansToward(x, y, x1, y1))\r\n  },\r\n\r\n  // Return distance between (x, y), (x1, y1)\r\n  distance: (x, y, x1, y1) => Math.sqrt(util.sqDistance(x, y, x1, y1)),\r\n  // Return distance between (x, y), (x1, y1)\r\n  hypot: (x, y, x1, y1) => Math.hypot(x - x1, y - y1),\r\n  // Return squared distance .. i.e. avoid Math.sqrt. Faster comparisons\r\n  sqDistance: (x, y, x1, y1) => (x - x1) * (x - x1) + (y - y1) * (y - y1),\r\n  // Return true if x,y is within cone.\r\n  // Cone: origin x0,y0 in given direction, with coneAngle width in radians.\r\n  // All angles in radians\r\n  inCone (x, y, radius, coneAngle, direction, x0, y0) {\r\n    if (this.sqDistance(x0, y0, x, y) > (radius * radius)) return false\r\n    const angle12 = this.radiansToward(x0, y0, x, y); // angle from 1 to 2\r\n    return coneAngle / 2 >= Math.abs(this.subtractRadians(direction, angle12))\r\n  },\r\n\r\n// ### Arrays, Objects and Iteration\r\n\r\n  // Repeat function f(i, a) n times, i in 0, n-1, a is optional array\r\n  repeat (n, f, a = []) { for (let i = 0; i < n; i++) f(i, a); return a },\r\n  // Repeat function n/step times, incrementing i by step each step.\r\n  step (n, step, f) { for (let i = 0; i < n; i += step) f(i); },\r\n  // Return range [0, length-1]. Note: 6x faster than Array.from!\r\n  range (length) { return this.repeat(length, (i, a) => { a[i] = i; }) },\r\n  // range (length) { return this.repeat(length, (i, a) => { a[i] = i }, []) },\r\n\r\n  // Return key for (first) given value in object, null if not found.\r\n  keyForValue (obj, value) {\r\n    for (const key in obj)\r\n      if (obj[key] === value) //  gl problems: && obj.hasOwnProperty(key)\r\n        return key\r\n    return null\r\n  },\r\n\r\n  // Execute fcn for all own member of an obj or array (typed OK).\r\n  // Return input arrayOrObj, transformed by fcn.\r\n  // - Unlike forEach, does not skip undefines.\r\n  // - Like map, forEach, etc, fcn = fcn(item, key/index, obj).\r\n  // - Alternatives are: `for..of`, array map, reduce, filter etc\r\n  forEach (arrayOrObj, fcn) {\r\n    if (arrayOrObj.slice) // typed & std arrays\r\n      for (let i = 0, len = arrayOrObj.length; i < len; i++)\r\n        fcn(arrayOrObj[i], i, arrayOrObj);\r\n    else // obj\r\n      Object.keys(arrayOrObj).forEach((k) => fcn(arrayOrObj[k], k, arrayOrObj));\r\n    return arrayOrObj\r\n  },\r\n\r\n  // Return a new shallow of array, either Array or TypedArray\r\n  copyArray (array) { return array.slice(0) },\r\n\r\n  // Return a new array that is the concatination two arrays.\r\n  // The resulting Type is that of the first array.\r\n  concatArrays (array1, array2) {\r\n    const Type = array1.constructor;\r\n    if (Type === Array)\r\n      return array1.concat(this.convertArray(array2, Array))\r\n    const array = new Type(array1.length + array2.length);\r\n    // NOTE: typedArray.set() allows any Array or TypedArray arg\r\n    array.set(array1); array.set(array2, array1.length);\r\n    return array\r\n  },\r\n\r\n  // Return an array with no sub-array elements\r\n  flatten (array) {\r\n    if (!Array.isArray(array[0])) return array\r\n    const result = [];\r\n    array.forEach((a) => result.push(...a));\r\n    return this.flatten(result)\r\n  },\r\n\r\n  // Return array's type (Array or TypedArray variant)\r\n  arrayType (array) { return array.constructor },\r\n\r\n  // Return a new JavaScript Array of floats/strings to a given precision.\r\n  // Fails for Float32Array due to float64->32 artifiacts, thus Array conversion\r\n  fixedArray (array, digits = 4) {\r\n    array = this.convertArray(array, Array); // 64 bit rounding\r\n    return array.map((n) => this.fixed(n, digits))\r\n  },\r\n\r\n  // Shallow clone of obj or array\r\n  clone (obj) {\r\n    if (obj.slice) return obj.slice(0) // ok for TypedArrays\r\n    const result = {};\r\n    Object.keys(obj).forEach((k) => { result[k] = obj[k]; });\r\n    return result\r\n  },\r\n\r\n  // [Deep clone](http://goo.gl/MIaTxU) an obj or array. Clever!\r\n  deepClone: (obj) => JSON.parse(JSON.stringify(obj)),\r\n  // Compare Objects or Arrays via JSON string. Note: TypedArrays !== Arrays\r\n  objectsEqual: (a, b) => JSON.stringify(a) === JSON.stringify(b),\r\n  // Use JSON to return pretty, printable string of an object, array, other\r\n  // Remove \"\"s around keys.\r\n  objectToString (obj) {\r\n    return JSON.stringify(obj, null, '  ')\r\n      .replace(/ {2}\"/g, '  ')\r\n      .replace(/\": /g, ': ')\r\n  },\r\n  // Like above, but a single line for small objects.\r\n  objectToString1 (obj) {\r\n    return JSON.stringify(obj)\r\n      .replace(/{\"/g, '{')\r\n      .replace(/,\"/g, ',')\r\n      .replace(/\":/g, ':')\r\n  },\r\n\r\n  // Create random array of floats between min/max.\r\n  // Array Type allows conversion to Float32Array or integers (Int32Array etc)\r\n  randomArray (length, min = 0, max = 1, Type = Array) {\r\n    const a = new Type(length);\r\n    for (let i = 0; i < length; i++)\r\n      a[i] = this.randomFloat2(min, max);\r\n    return a\r\n  },\r\n\r\n  // Create a histogram, given an array, a bin size, and a\r\n  // min bin defaulting to min of of the array.\r\n  // Return an object with:\r\n  // - min/maxBin: the first/last bin with data\r\n  // - min/maxVal: the min/max values in the array\r\n  // - bins: the number of bins\r\n  // - hist: the array of bins\r\n  histogram (array, bin = 1, min = Math.floor(this.arrayMin(array))) {\r\n    const hist = [];\r\n    let [minBin, maxBin] = [Number.MAX_VALUE, Number.MIN_VALUE];\r\n    let [minVal, maxVal] = [Number.MAX_VALUE, Number.MIN_VALUE];\r\n    for (const a of array) {\r\n      const i = Math.floor(a / bin) - min;\r\n      hist[i] = (hist[i] === undefined) ? 1 : hist[i] + 1;\r\n      minBin = Math.min(minBin, i);\r\n      maxBin = Math.max(maxBin, i);\r\n      minVal = Math.min(minVal, a);\r\n      maxVal = Math.max(maxVal, a);\r\n    }\r\n    for (const i in hist)\r\n      if (hist[i] === undefined) { hist[i] = 0; }\r\n    const bins = maxBin - minBin + 1;\r\n    return { bins, minBin, maxBin, minVal, maxVal, hist }\r\n  },\r\n\r\n  // Return scalar max/min/sum/avg of numeric Array or TypedArray.\r\n  arrayMax: (array) => array.reduce((a, b) => Math.max(a, b)),\r\n  arrayMin: (array) => array.reduce((a, b) => Math.min(a, b)),\r\n  arraySum: (array) => array.reduce((a, b) => a + b),\r\n  arrayAvg: (array) => util.arraySum(array) / array.length,\r\n  // Return random one of array items. No array.length tests\r\n  oneOf: (array) => array[util.randomInt(array.length)],\r\n  otherOneOf (array, item) {\r\n    do { var other = this.oneOf(array); } while (item === other) // note var use\r\n    return other\r\n  },\r\n  // Create an array of properties from an array of objects\r\n  arrayProps: (array, propName) => array.map((a) => a[propName]),\r\n  // Random key/val of object\r\n  oneKeyOf: (obj) => util.oneOf(Object.keys(obj)),\r\n  oneValOf: (obj) => obj[util.oneKeyOf(obj)],\r\n\r\n  // You'd think this wasn't necessary, but I always forget. Damn.\r\n  // NOTE: this, like sort, sorts in place. Clone array if needed.\r\n  sortNums (array, ascending = true) {\r\n    return array.sort((a, b) => ascending ? a - b : b - a)\r\n  },\r\n  // Sort an array of objects w/ fcn(obj) as compareFunction.\r\n  // If fcn is a string, convert to propFcn.\r\n  sortObjs (array, fcn, ascending = true) {\r\n    if (typeof fcn === 'string') fcn = this.propFcn(fcn);\r\n    const comp = (a, b) => fcn(a) - fcn(b);\r\n    return array.sort((a, b) => ascending ? comp(a, b) : -comp(a, b))\r\n  },\r\n  // Randomize array in-place. Use clone() first if new array needed\r\n  // The array is returned for chaining; same as input array.\r\n  // See [Durstenfeld / Fisher-Yates-Knuth shuffle](https://goo.gl/mfbdPh)\r\n  shuffle (array) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      const temp = array[i];\r\n      array[i] = array[j];\r\n      array[j] = temp;\r\n    }\r\n    return array\r\n  },\r\n  // Returns new array (of this type) of unique elements in this *sorted* array.\r\n  // Sort or clone & sort if needed.\r\n  uniq (array, f = this.identity) {\r\n    if (this.isString(f)) f = this.propFcn(f);\r\n    return array.filter((ai, i, a) => (i === 0) || (f(ai) !== f(a[i - 1])))\r\n  },\r\n  // unique = (array) => [...new Set(array)],\r\n\r\n  // Binary search:\r\n  // Return array index of item, where array is sorted.\r\n  // If item not found, return index for item for array to remain sorted.\r\n  // f is used to return an integer for sorting, defaults to identity.\r\n  // If f is a string, it is the object property to sort by.\r\n  // Adapted from underscore's _.sortedIndex.\r\n  sortedIndex (array, item, f = this.identity) {\r\n    if (this.isString(f)) f = this.propFcn(f);\r\n    const value = f(item);\r\n    // Why not array.length - 1? Because we can insert 1 after end of array.\r\n    // let [low, high] = [0, array.length]\r\n    let low = 0;\r\n    let high = array.length;\r\n    while (low < high) {\r\n      const mid = (low + high) >>> 1; // floor (low+high)/2\r\n      if (f(array[mid]) < value) { low = mid + 1; } else { high = mid; }\r\n    }\r\n    return low\r\n  },\r\n  // Return index of value in array with given property or -1 if not found.\r\n  // Binary search if property isnt null\r\n  // Property can be string or function.\r\n  // Use property = identity to compare objs directly.\r\n  indexOf (array, item, property) {\r\n    if (!property) return array.indexOf(item)\r\n    const i = this.sortedIndex(array, item, property);\r\n    return array[i] === item ? i : -1\r\n  },\r\n  // True if item is in array. Binary search if f given\r\n  contains (array, item, f) { return this.indexOf(array, item, f) >= 0 },\r\n  // Remove an item from an array. Binary search if f given\r\n  // Array unchanged if item not found.\r\n  removeItem (array, item, f) {\r\n    const i = this.indexOf(array, item, f);\r\n    if (i !== -1) array.splice(i, 1);\r\n    else this.warn(`util.removeItem: ${item} not in array ${array.constructor.name}`);\r\n    // else throw Error(`util.removeItem: item ${item} not in array ${array}`)\r\n  },\r\n  // Insert an item in a sorted array\r\n  insertItem (array, item, f) {\r\n    const i = this.sortedIndex(array, item, f);\r\n    if (array[i] === item) this.error('insertItem: item already in array');\r\n    array.splice(i, 0, item); // copyWithin?\r\n  },\r\n\r\n  // Return array composed of f(a1i, a2i) called pairwise on both arrays\r\n  aPairwise: (a1, a2, f) => a1.map((val, i) => f(val, a2[i])),\r\n  arraysAdd: (a1, a2) => util.aPairwise(a1, a2, (a, b) => a + b),\r\n  arraysSub: (a1, a2) => util.aPairwise(a1, a2, (a, b) => a - b),\r\n  arraysMul: (a1, a2) => util.aPairwise(a1, a2, (a, b) => a * b),\r\n  arraysEqual: (a1, a2) => util.arraysSub(a1, a2).every((a) => a === 0),\r\n\r\n  // Return a \"ramp\" (array of uniformly ascending/descending floats)\r\n  // in [start,stop] with numItems (positive integer > 1).\r\n  // OK for start>stop. Will always include start/stop w/in float accuracy.\r\n  aRamp (start, stop, numItems) {\r\n    // NOTE: start + step*i, where step is (stop-start)/(numItems-1),\r\n    // has float accuracy problems, must recalc step each iteration.\r\n    if (numItems <= 1) this.error('aRamp: numItems must be > 1');\r\n    const a = [];\r\n    for (let i = 0; i < numItems; i++)\r\n      a.push(start + (stop - start) * (i / (numItems - 1)));\r\n    return a\r\n  },\r\n  // Integer version of aRamp, start & stop integers, rounding each element.\r\n  // Default numItems yields unit step between start & stop.\r\n  aIntRamp (start, stop, numItems = (Math.abs(stop - start) + 1)) {\r\n    return this.aRamp(start, stop, numItems).map((a) => Math.round(a))\r\n  },\r\n\r\n  // Return an array normalized (lerp) between lo/hi values\r\n  normalize (array, lo = 0, hi = 1) {\r\n    const [min, max] = [this.arrayMin(array), this.arrayMax(array)];\r\n    const scale = 1 / (max - min);\r\n    return array.map((n) => this.lerp(lo, hi, scale * ((n) - min)))\r\n  },\r\n  // Return Uint8ClampedArray normalized in 0-255\r\n  normalize8 (array) {\r\n    return new Uint8ClampedArray(this.normalize(array, -0.5, 255.5))\r\n  },\r\n  // Return Array normalized to integers in lo-hi\r\n  normalizeInt (array, lo, hi) {\r\n    return this.normalize(array, lo, hi).map((n) => Math.round(n))\r\n  },\r\n\r\n// ### Async\r\n\r\n  // Return Promise for getting an image.\r\n  // - use: imagePromise('./path/to/img').then(img => imageFcn(img))\r\n  imagePromise (url) {\r\n    return new Promise((resolve, reject) => {\r\n      const img = new Image();\r\n      img.crossOrigin = 'Anonymous';\r\n      img.onload = () => resolve(img);\r\n      img.onerror = () => reject(Error(`Could not load image ${url}`));\r\n      img.src = url;\r\n    })\r\n  },\r\n  // Return Promise for ajax/xhr data.\r\n  // - type: 'arraybuffer', 'blob', 'document', 'json', 'text'.\r\n  // - method: 'GET', 'POST'\r\n  // - use: xhrPromise('./path/to/data').then(data => dataFcn(data))\r\n  xhrPromise (url, type = 'text', method = 'GET') {\r\n    return new Promise((resolve, reject) => {\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open(method, url); // POST mainly for security and large files\r\n      xhr.responseType = type;\r\n      xhr.onload = () => resolve(xhr.response);\r\n      xhr.onerror = () => reject(Error(`Could not load ${url}: ${xhr.status}`));\r\n      xhr.send();\r\n    })\r\n  },\r\n  // Return promise for pause of ms. Use:\r\n  // timeoutPromise(2000).then(()=>console.log('foo'))\r\n  timeoutPromise (ms = 1000) {\r\n    return new Promise((resolve, reject) => {\r\n      setTimeout(() => resolve(), ms);\r\n    })\r\n  },\r\n  // Imports a script, waits 'till loaded, then resolves. Use:\r\n  // scriptPromise('../lib/pako.js', 'pako')\r\n  //   .then((script) => console.log(script))\r\n  scriptPromise (path, name, f = () => window[name], props = {}) {\r\n    if (window[name] == null) this.setScript(path, props);\r\n    return this.waitPromise(() => window[name] != null, f)\r\n  },\r\n  // Promise: Wait until done(), then resolve with f()'s value, default to noop\r\n  // Ex: This waits until window.foo is defined, then reports:\r\n  // waitPromise(()=>window.foo).then(()=>console.log('foo defined'))\r\n  waitPromise (done, f = this.noop, ms = 10) {\r\n    return new Promise((resolve, reject) => {\r\n      this.waitOn(done, () => resolve(f()), ms);\r\n    })\r\n  },\r\n  // Callback: Wait (setTimeout) until done() true, then call f()\r\n  waitOn (done, f, ms = 10) {\r\n    if (done())\r\n      f();\r\n    else\r\n      setTimeout(() => { this.waitOn(done, f, ms); }, ms);\r\n  },\r\n\r\n  // An [async/await](https://davidwalsh.name/async-generators)\r\n  // implementation using generators returning promises.\r\n  //\r\n  // runGenerator runs a generator which yields promises,\r\n  // returning the promise results when they complete.\r\n  // Amazingly enough, the returned promise result replaces the\r\n  // promise initially yielded by the generator function.\r\n  // The `it` argument can be either a generator function or it's iterator.\r\n  runGenerator (it, callback = (lastVal) => {}) {\r\n    it = this.typeOf(it) === 'generator' ? it : it()\r\n    ;(function iterate (val) { // asynchronously iterate over generator\r\n      const ret = it.next(val);\r\n      if (!ret.done) // wait on promise, `then` calls iterate w/ a value\r\n        if (ret.value.then)\r\n          ret.value.then(iterate); // iterate takes the promise's value\r\n        else // avoid synchronous recursion\r\n          setTimeout(() => iterate(ret.value), 0);\r\n      else\r\n        callback(ret.value);\r\n    }());\r\n  },\r\n  // Promise version of runGenerator.\r\n  // The `it` argument can be either a generator function or it's iterator.\r\n  runGeneratorPromise (it) {\r\n    return new Promise((resolve, reject) => {\r\n      this.runGenerator(it, resolve);\r\n    })\r\n  },\r\n  // Used like this, main() is entirely sync:\r\n  // ```\r\n  // function* main() {\r\n  //   var path = 'http://s3.amazonaws.com/backspaces/'\r\n  //   var val1 = yield util.xhrPromise(path + 'lorem1.txt')\r\n  //   console.log( 'val1', val1 )\r\n  //   var val2 = yield util.xhrPromise(path + 'lorem2.txt')\r\n  //   console.log( 'val2', val2 )\r\n  // }\r\n  // util.runGenerator( main )\r\n  // ```\r\n\r\n  // Run a possibly async fcn, calling thenFcn when async fcn is done.\r\n  // The fcn can return a generator or a promise.\r\n  // If neither, run fcn & thenFcn synchronously\r\n  runAsyncFcn (fcn, thenFcn) {\r\n    const startup = fcn();\r\n    if (this.typeOf(startup) === 'generator')\r\n      this.runGenerator(startup, thenFcn);\r\n    else if (this.typeOf(startup) === 'promise')\r\n      startup.then(thenFcn);\r\n    else\r\n      thenFcn();\r\n  },\r\n\r\n// ### Canvas/Image\r\n\r\n  // Get an image in this page by its ID\r\n  getCanvasByID: (id) => document.getElementById(id),\r\n  // Create a blank canvas of a given width/height\r\n  createCanvas (width, height) {\r\n    const can = document.createElement('canvas');\r\n    Object.assign(can, {width, height});\r\n    return can\r\n  },\r\n  // As above, but returing the context object.\r\n  // NOTE: ctx.canvas is the canvas for the ctx, and can be use as an image.\r\n  createCtx (width, height, type = '2d', glAttributes = {}) {\r\n    const can = this.createCanvas(width, height);\r\n    return this.getContext(can, type, glAttributes)\r\n  },\r\n  getContext (canvas, type = '2d', glAttributes = {}) {\r\n    if (typeof canvas === 'string') canvas = this.getCanvasByID(canvas);\r\n    if (type[0] !== '2') type = 'webgl';\r\n    const ctx = canvas.getContext(type, glAttributes);\r\n    if (!ctx) this.error('getContext error');\r\n    return ctx\r\n  },\r\n  // Duplicate a ctx's image. Returns the new ctx (who's canvas is ctx.caanvas)\r\n  cloneCtx (ctx0) {\r\n    const ctx = this.createCtx(ctx0.canvas.width, ctx0.canvas.height);\r\n    ctx.drawImage(ctx0.canvas, 0, 0);\r\n    return ctx\r\n  },\r\n  // Resize a ctx/canvas and preserve data.\r\n  resizeCtx (ctx, width, height) {\r\n    const copy = this.cloneCtx(ctx);\r\n    ctx.canvas.width = width;\r\n    ctx.canvas.height = height;\r\n    ctx.drawImage(copy.canvas, 0, 0);\r\n  },\r\n  // Return the (complete) ImageData object for this context object\r\n  ctxImageData (ctx) {\r\n    return ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)\r\n  },\r\n  // Fill this context with the given image. Will scale image to fit ctx size.\r\n  fillCtxWithImage (ctx, img) {\r\n    this.setIdentity(ctx); // set/restore identity\r\n    ctx.drawImage(img, 0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    ctx.restore();\r\n  },\r\n  // Return an image/png base64 [dataUrl](https://goo.gl/fyBPnL)\r\n  // string for this ctx object.\r\n  ctxToDataUrl: (ctx) => ctx.canvas.toDataURL('image/png'),\r\n\r\n  // Convert a dataUrl back into am image.\r\n  dataUrlToImage (dataUrl) { // async in some browsers?? http://goo.gl/kIk2U\r\n    const img = new Image();\r\n    img.src = dataUrl;\r\n    return img\r\n  },\r\n  // Return a ctx object for this base64 data url\r\n  dataUrlToCtx (dataUrl) { // async in some browsers?? http://goo.gl/kIk2U\r\n    const img = this.dataUrlToImage(dataUrl);\r\n    const ctx = this.createCtx(img.width, img.height);\r\n    ctx.drawImage(img, 0, 0);\r\n    return ctx\r\n  },\r\n\r\n  setCtxSmoothing (ctx, smoothing) {\r\n    // Don'cha love  standards!\r\n    const aliases = ['imageSmoothingEnabled', 'mozImageSmoothingEnabled', 'oImageSmoothingEnabled', 'webkitImageSmoothingEnabled', 'msImageSmoothingEnabled'];\r\n    for (const name of aliases)\r\n      if (ctx[name])\r\n        return (ctx[name] = smoothing) // lets hope the first one works. Sheesh!\r\n  },\r\n\r\n  // Install identity transform for this context.\r\n  // Call ctx.restore() to revert to previous transform.\r\n  setIdentity (ctx) {\r\n    ctx.save(); // NOTE: Does not change state, only saves current state.\r\n    ctx.setTransform(1, 0, 0, 1, 0, 0); // or ctx.resetTransform()\r\n  },\r\n  // Set ctx.canvas size, ctx scale, origin to the model's world.\r\n  setWorldTransform (ctx, world) {\r\n    ctx.canvas.width = world.width;\r\n    ctx.canvas.height = world.height;\r\n    ctx.save();\r\n    ctx.scale(world.patchSize, -world.patchSize);\r\n    ctx.translate(-world.minXcor, -world.maxYcor);\r\n  },\r\n\r\n// ### Canvas 2D Context Text Drawing\r\n\r\n  // Draw string of the given color at the xy location, in ctx pixel coords.\r\n  // Push/pop identity transform.\r\n  ctxDrawText (ctx, string, x, y, cssColor) {\r\n    this.setIdentity(ctx);\r\n    ctx.fillStyle = cssColor;\r\n    ctx.fillText(string, x, y);\r\n    ctx.restore();\r\n  },\r\n\r\n  // Convert an image, or part of an image, to a context.\r\n  // img may be another canvas.\r\n  // * x, y are top/left in image, default to 0, 0.\r\n  // * width, height are size of context, default to image's width, height\r\n  // * thus default is entire image\r\n  //\r\n  // NOTE: to convert a ctx to an \"image\" (drawImage) use ctx.canvas.\r\n  // [See MDN drawImage, third form](https://goo.gl/a5b87N)\r\n  // NOTE: this will distort the origional image, due to browser assumptions.\r\n  // Use imageToBytes for undistorted image content.\r\n  //\r\n  // REMIND: Remove?\r\n  imageToCtx (img, x = 0, y = 0, width = img.width, height = img.height) {\r\n    if ((x + width > img.width) || (y + height > img.height))\r\n      this.error('imageToCtx: parameters outside of image');\r\n    const ctx = this.createCtx(width, height);\r\n    ctx.drawImage(img, x, y, width, height, 0, 0, width, height);\r\n    return ctx\r\n  },\r\n\r\n// ### WebGL/Three.js\r\n\r\n  // Use webgl texture to convert img to Uint8Array w/o alpha premultiply\r\n  // or color profile modification.\r\n  // Img can be Image, ImageData, Canvas: [See MDN](https://goo.gl/a3oyRA).\r\n  // `flipY` is used to invert image to upright.\r\n  imageToBytesCtx: null,\r\n  imageToBytes (img, flipY = false, imgFormat = 'RGBA') {\r\n    // Create the gl context using the image width and height\r\n    if (!this.imageToBytesCtx) {\r\n      this.imageToBytesCtx = this.createCtx(0, 0, 'webgl', {\r\n        premultipliedAlpha: false\r\n      });\r\n    }\r\n\r\n    const {width, height} = img;\r\n    const gl = this.imageToBytesCtx;\r\n    Object.assign(gl.canvas, {width, height});\r\n    // const gl = this.createCtx(width, height, 'webgl', {\r\n    //   premultipliedAlpha: false\r\n    // })\r\n    const fmt = gl[imgFormat];\r\n\r\n    // Create and initialize the texture.\r\n    const texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    if (flipY) // Mainly used for pictures rather than data\r\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n    // Insure [no color profile applied](https://goo.gl/BzBVJ9):\r\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\r\n    // Insure no [alpha premultiply](http://goo.gl/mejNCK).\r\n    // False is the default, but lets make sure!\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\r\n\r\n    // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img)\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, fmt, fmt, gl.UNSIGNED_BYTE, img);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n\r\n    // Create the framebuffer used for the texture\r\n    const framebuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n    gl.framebufferTexture2D(\r\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n\r\n    // See if it all worked. Apparently not async.\r\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\r\n    if (status !== gl.FRAMEBUFFER_COMPLETE)\r\n      this.error(`imageToBytes: status not FRAMEBUFFER_COMPLETE: ${status}`);\r\n\r\n    // If all OK, create the pixels buffer and read data.\r\n    const pixSize = imgFormat === 'RGB' ? 3 : 4;\r\n    const pixels = new Uint8Array(pixSize * width * height);\r\n    // gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)\r\n    gl.readPixels(0, 0, width, height, fmt, gl.UNSIGNED_BYTE, pixels);\r\n\r\n    // Unbind the framebuffer and return pixels\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    return pixels\r\n  }\r\n};\r\n\r\n// An Array superclass with convenience methods used by NetLogo.\r\n// Tipically the items in the array are Objects, NetLogo Agents,\r\n// but generally useful as an ArrayPlus\r\n\r\nclass AgentArray extends Array {\r\n  // Convert an Array to an AgentArray \"in place\".\r\n  // Use array.slice() if a new array is wanted\r\n  static fromArray (array) {\r\n    Object.setPrototypeOf(array, AgentArray.prototype);\r\n    return array\r\n  }\r\n\r\n  // constructor not needed, JS passes on if ctor same as super's\r\n  // constructor () { super() }\r\n\r\n  // Convert between AgentArrays and Arrays\r\n  toArray () { Object.setPrototypeOf(this, Array.prototype); return this }\r\n\r\n  // Remove/Insert object \"o\" from this array. If prop given, assume\r\n  // array sorted by prop and use binary search. Return this for chaining.\r\n  // REMIND: Move util functions here, hopefully simplifying.\r\n  remove (o, prop) {\r\n    util.removeItem(this, o, prop);\r\n    return this\r\n  }\r\n  insert (o, prop) {\r\n    util.insertItem(this, o, prop);\r\n    return this\r\n  }\r\n\r\n  // Return true if there are no items in this set, false if not empty.\r\n  empty () { return this.length === 0 }\r\n  // Return !empty()\r\n  any () { return this.length !== 0 }\r\n  // Return first item in this array. Returns undefined if empty.\r\n  first () { return this[ 0 ] }\r\n  // Return last item in this array. Returns undefined if empty.\r\n  last () { return this[ this.length - 1 ] }\r\n  // Return true if reporter true for all of this set's objects\r\n  all (reporter) { return this.every(reporter) }\r\n  // Return AgentArray of property values for key from this array's objects\r\n  // props (key) { return this.map((a) => a[key]).toArray() }\r\n  props (key) { return this.map((a) => a[key]) }\r\n  // Return AgentArray with reporter(agent) true\r\n  with (reporter) { return this.filter(reporter) }\r\n  // Call fcn(agent) for each agent in AgentArray.\r\n  // Return the AgentArray for chaining.\r\n  // Note: 5x+ faster than this.forEach(fcn) !!\r\n  ask (fcn) { for (let i = 0; i < this.length; i++) fcn(this[i], i); return this }\r\n  // Return count of agents with reporter(agent) true\r\n  count (reporter) {\r\n    return this.reduce((prev, o) => prev + (reporter(o) ? 1 : 0), 0)\r\n  }\r\n\r\n  // Replacements for array methods to avoid calling AgentArray ctor\r\n\r\n  // Return shallow copy of a portion of this AgentArray\r\n  // [See Array.slice](https://goo.gl/Ilgsok)\r\n  // Default is to clone entire AgentArray\r\n  clone (begin = 0, end = this.length) {\r\n    return this.slice(begin, end) // Returns an AgentArray rather than Array!\r\n  }\r\n  // Randomize the AgentArray in place. Use clone first if new AgentArray needed.\r\n  // Return \"this\" for chaining.\r\n  shuffle () { return util.shuffle(this) }\r\n  // Return this AgentArray sorted by the reporter in ascending/descending order.\r\n  // If reporter is a string, convert to a fcn returning that property.\r\n  // Use clone if you don't want to mutate this array.\r\n  sortBy (reporter, ascending = true) {\r\n    util.sortObjs(this, reporter, ascending);\r\n    return this\r\n  }\r\n\r\n  // Return a random agent. Return undefined if empty.\r\n  oneOf () { return util.oneOf(this) }\r\n  // Return a random agent, not equal to agent\r\n  otherOneOf (agent) { return util.otherOneOf(this, agent) }\r\n  // otherOneOf: nOf good enough?\r\n  // Return the first agent having the min/max of given value of f(agent).\r\n  // If reporter is a string, convert to a fcn returning that property\r\n  minOrMaxOf (min, reporter) {\r\n    if (this.empty()) throw Error('min/max OneOf: empty array')\r\n    if (typeof reporter === 'string') reporter = util.propFcn(reporter);\r\n    let o = null;\r\n    let val = min ? Infinity : -Infinity;\r\n    for (let i = 0; i < this.length; i++) {\r\n      const a = this[i];\r\n      const aval = reporter(a);\r\n      if ((min && (aval < val)) || (!min && (aval > val)))\r\n        [o, val] = [a, aval];\r\n    }\r\n    return o\r\n  }\r\n  // The min version of the above\r\n  minOneOf (reporter) { return this.minOrMaxOf(true, reporter) }\r\n  // The max version of the above\r\n  maxOneOf (reporter) { return this.minOrMaxOf(false, reporter) }\r\n\r\n  // Return n random agents as AgentArray.\r\n  // See [Fisher-Yates-Knuth shuffle](https://goo.gl/fWNFf)\r\n  // for better approach for large n.\r\n  nOf (n) {\r\n    if (n > this.length)\r\n      throw Error('nOf: n larger than AgentArray')\r\n    if (n === this.length) return this\r\n    const result = new AgentArray();\r\n    while (result.length < n) {\r\n      const o = this.oneOf();\r\n      if (!(o in result)) result.push(o);\r\n    }\r\n    return result\r\n  }\r\n  // Return a new AgentArray of the n min/max agents of the value of reporter,\r\n  // in ascending order.\r\n  // If reporter is a string, convert to a fcn returning that property\r\n  // NOTE: we do not manage ties, see NetLogo docs.\r\n  minOrMaxNOf (min, n, reporter) {\r\n    if (n > this.length) throw Error('min/max nOf: n larger than AgentArray')\r\n    const as = this.clone().sortBy(reporter);\r\n    return min ? as.clone(0, n) : as.clone(as.length - n)\r\n  }\r\n  minNOf (n, reporter) { return this.minOrMaxNOf(true, n, reporter) }\r\n  maxNOf (n, reporter) { return this.minOrMaxNOf(false, n, reporter) }\r\n\r\n  // Geometry methods for patches, turtles, and other AgentArrays which have x,y.\r\n  // Return all agents within rect, radius, cone from given agent o.\r\n  // If meToo, include given object, default excludes it\r\n  // Typically the AgentArray is a subset of larger sets, reducing\r\n  // the size, then uses these inRect, inRadius or inCone methods\r\n\r\n  // Return all agents within rectangle from given agent o.\r\n  // dx & dy are (float) half width/height of rect\r\n  inRect (o, dx, dy = dx, meToo = false) {\r\n    const agents = new AgentArray();\r\n    const minX = o.x - dx; // ok if max/min off-world, o, a are in-world\r\n    const maxX = o.x + dx;\r\n    const minY = o.y - dy;\r\n    const maxY = o.y + dy;\r\n    this.ask(a => {\r\n      if (minX <= a.x && a.x <= maxX && minY <= a.y && a.y <= maxY) {\r\n        if (meToo || o !== a) agents.push(a);\r\n      }\r\n    });\r\n    return agents\r\n  }\r\n\r\n  // Return all agents in AgentArray within d distance from given object.\r\n  inRadius (o, radius, meToo = false) {\r\n    const agents = new AgentArray();\r\n    // const {x, y} = o // perf?\r\n    const d2 = radius * radius;\r\n    const sqDistance = util.sqDistance; // Local function 2-3x faster, inlined?\r\n    this.ask(a => {\r\n      if (sqDistance(o.x, o.y, a.x, a.y) <= d2)\r\n        if (meToo || o !== a) agents.push(a);\r\n    });\r\n    return agents\r\n  }\r\n\r\n  // As above, but also limited to the angle `coneAngle` around\r\n  // a `direction` from object `o`.\r\n  inCone (o, radius, coneAngle, direction, meToo = false) {\r\n    const agents = new AgentArray();\r\n    this.ask(a => {\r\n      if (util.inCone(a.x, a.y, radius, coneAngle, direction, o.x, o.y))\r\n        if (meToo || o !== a) agents.push(a);\r\n    });\r\n    return agents\r\n  }\r\n}\r\n\r\n// A general color module, supporting css string colors, canvas2d pixel\r\n// colors, webgl and canvas2d Uint8ClampedArray r,g,b,a arrays.\r\n// Notice a JavaScript Array is **not** a color!\r\n\r\nconst Color = {\r\n\r\n// ### CSS Color Strings.\r\n\r\n  // CSS colors in HTML are strings, see [Mozillas Color Reference](\r\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/color_value),\r\n  // taking one of 7 forms:\r\n  //\r\n  // * Names: over 140 color case-insensitive names like\r\n  //   Red, Green, CadetBlue, etc.\r\n  // * Hex, short and long form: #0f0, #ff10a0\r\n  // * RGB: rgb(255, 0, 0), rgba(255, 0, 0, 0.5)\r\n  // * HSL: hsl(120, 100%, 50%), hsla(120, 100%, 50%, 0.8)\r\n  //\r\n  // See [this wikipedia article](https://goo.gl/ev8Kw0)\r\n  // on differences between HSL and HSB/HSV.\r\n\r\n  // Convert 4 r,g,b,a ints in [0-255] (\"a\" defaulted to 255) to a\r\n  // css color string. Alpha \"a\" is converted to float in 0-1 for css string.\r\n  // We use alpha in [0-255] to be compatible with TypedArray conventions.\r\n  rgbaString (r, g, b, a = 255) {\r\n    a = a / 255; const a2 = a.toPrecision(2);\r\n    return (a === 1) ? `rgb(${r},${g},${b})` : `rgba(${r},${g},${b},${a2})`\r\n  },\r\n\r\n  // Convert 4 ints, h,s,l,a, h in [0-360], s,l in [0-100]% a in [0-255] to a\r\n  // css color string. Alpha \"a\" is converted to float in 0-1 for css string.\r\n  //\r\n  // NOTE: h=0 and h=360 are the same, use h in 0-359 for unique colors.\r\n  hslString (h, s, l, a = 255) {\r\n    a = a / 255; const a4 = a.toPrecision(4);\r\n    return (a === 1) ? `hsl(${h},${s}%,${l}%)` : `hsla(${h},${s}%,${l}%,${a4})`\r\n  },\r\n\r\n  // Return a html/css hex color string for an r,g,b opaque color (a=255).\r\n  // Hex strings do not support alpha.\r\n  //\r\n  // Both #nnn and #nnnnnn forms supported.\r\n  // Default is to check for the short hex form.\r\n  hexString (r, g, b, shortOK = true) {\r\n    if (shortOK) {\r\n      const [r0, g0, b0] = [r / 17, g / 17, b / 17];\r\n      if (util.isInteger(r0) && util.isInteger(g0) && util.isInteger(b0))\r\n        return this.hexShortString(r0, g0, b0)\r\n    }\r\n    return `#${(0x1000000 | (b | g << 8 | r << 16)).toString(16).slice(-6)}`\r\n  },\r\n  // Return the 4 char short version of a hex color.  Each of the r,g,b values\r\n  // must be in [0-15].  The resulting color will be equivalent\r\n  // to `r*17`, `g*17`, `b*17`, resulting in the 16 values:\r\n  //\r\n  //     0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255\r\n  //\r\n  // This is equivalent util.aIntRamp(0,255,16), i.e. 16 values per rgb channel.\r\n  hexShortString (r, g, b) {\r\n    if ((r > 15) || (g > 15) || (b > 15)) {\r\n      throw Error(`hexShortString: one of ${[r, g, b]} > 15`)\r\n    }\r\n    return `#${r.toString(16)}${g.toString(16)}${b.toString(16)}`\r\n  },\r\n\r\n  // Tristring is a hybrid string and is our standard.  It returns:\r\n  //\r\n  // * rgbaString if a not 255 (i.e. not opaque)\r\n  // * hexString otherwise\r\n  // * with the hexShortString if appropriate\r\n  triString (r, g, b, a = 255) {\r\n    return (a === 255) ? // eslint-disable-line\r\n      this.hexString(r, g, b, true) : this.rgbaString(r, g, b, a)\r\n  },\r\n\r\n// ### CSS String Conversions\r\n\r\n  // Return 4 element array given any legal CSS string color.\r\n  //\r\n  // Because strings vary widely: CadetBlue, #0f0, rgb(255,0,0),\r\n  // hsl(120,100%,50%), we do not parse strings, instead we let\r\n  // the browser do our work: we fill a 1x1 canvas with the css string color,\r\n  // returning the r,g,b,a canvas ImageData TypedArray.\r\n\r\n  // The shared 1x1 canvas 2D context.\r\n  sharedCtx1x1: util.createCtx(1, 1), // share across calls.\r\n  // Convert any css string to 4 element Uint8ClampedArray TypedArray.\r\n  // If you need a JavaScript Array, use `new Array(...TypedArray)`\r\n  stringToUint8s (string) {\r\n    this.sharedCtx1x1.clearRect(0, 0, 1, 1);\r\n    this.sharedCtx1x1.fillStyle = string;\r\n    this.sharedCtx1x1.fillRect(0, 0, 1, 1);\r\n    return this.sharedCtx1x1.getImageData(0, 0, 1, 1).data\r\n  },\r\n\r\n  // ### Typed Color\r\n  // A Color is a 4 element Uint8ClampedArray, with two properties:\r\n  //\r\n  // * pixelArray: A single element Uint32Array view on the Uint8ClampedArray\r\n  // * string: an optional, lazy evaluated, css color string.\r\n  //\r\n  // This provides a universal color, good for canvas2d pixels, webgl & image\r\n  // TypedArrays, and css/canvas2d strings.\r\n\r\n  // Create Color from r,g,b,a. Use `toColor()` below for strings etc.\r\n  color (r, g, b, a = 255) {\r\n    const u8array = new Uint8ClampedArray([r, g, b, a]);\r\n    u8array.pixelArray = new Uint32Array(u8array.buffer); // one element array\r\n    // Make this an instance of ColorProto\r\n    Object.setPrototypeOf(u8array, ColorProto);\r\n    return u8array\r\n  },\r\n  isColor (color) {\r\n    return color && color.constructor === Uint8ClampedArray && color.pixelArray\r\n  },\r\n  // Create a Color from a css string, pixel, JavaScript or Typed Array.\r\n  // Returns `any` if is Color already. Useful for\r\n  // ```\r\n  // css: `toColor('#ff0a00')`\r\n  // hsl: `toColor('hsl(200,100%,50%)')`\r\n  // named colors: `toColor('CadetBlue')`\r\n  // pixels: `toColor(4294945280)`\r\n  // JavaScript Arrays: `toColor([255,0,0])`\r\n  // ```\r\n  toColor (any) {\r\n    if (this.isColor(any)) return any\r\n    const tc = this.color(0, 0, 0, 0);\r\n    if (util.isInteger(any)) tc.setPixel(any);\r\n    else if (typeof any === 'string') tc.setCss(any);\r\n    else if (Array.isArray(any) || util.isUintArray(any)) tc.setColor(...any);\r\n    else if (util.isFloatArray(any)) tc.setWebgl(any);\r\n    else throw Error('toColor: invalid argument', any)\r\n    return tc\r\n  },\r\n  // Return a random rgb Color, a=255\r\n  randomColor () {\r\n    const r255 = () => util.randomInt(256); // random int in [0,255]\r\n    return this.color(r255(), r255(), r255())\r\n  }\r\n  // A static transparent color, set at end of file\r\n  // transparent: null\r\n};\r\n\r\n// Prototype for Color. Getters/setters for usability, may be slower.\r\nconst ColorProto = {\r\n  // Inherit from Uint8ClampedArray\r\n  __proto__: Uint8ClampedArray.prototype,\r\n\r\n  // Set the Color to new rgba values.\r\n  setColor (r, g, b, a = 255) {\r\n    this.checkColorChange();\r\n    this[0] = r; this[1] = g; this[2] = b; this[3] = a;\r\n  },\r\n  // No real need for getColor, it *is* the typed Uint8 array\r\n  set rgb (rgbaArray) { this.setColor(...rgbaArray); },\r\n  get rgb () { return this },\r\n\r\n  // Set the Color to a new pixel value\r\n  setPixel (pixel) {\r\n    this.checkColorChange();\r\n    this.pixelArray[0] = pixel;\r\n  },\r\n  // Get the pixel value\r\n  getPixel () { return this.pixelArray[0] },\r\n  get pixel () { return this.getPixel() },\r\n  set pixel (pixel) { this.setPixel(pixel); },\r\n\r\n  // Set pixel/rgba values to equivalent of the css string.\r\n  // 'red', '#f00', 'ff0000', 'rgb(255,0,0)', etc.\r\n  //\r\n  // Does *not* set the chached this.string, which will be lazily evaluated\r\n  // to its common triString by getCss(). The above would all return '#f00'.\r\n  setCss (string) {\r\n    return this.setColor(...Color.stringToUint8s(string))\r\n  },\r\n  // Return the triString for this Color, cached in the @string value\r\n  getCss () {\r\n    if (this.string == null) this.string = Color.triString(...this);\r\n    return this.string\r\n  },\r\n  get css () { return this.getCss() },\r\n  set css (string) { this.setCss(string); },\r\n\r\n  // Note: webgl colors are 3 RGB floats (no A) if A is 255.\r\n  setWebgl (floatArray) {\r\n    this.setColor( // OK if float * 255 non-int, setColor stores into uint8 array\r\n      floatArray[0] * 255, floatArray[1] * 255, floatArray[2] * 255,\r\n      floatArray.length === 4 ? floatArray[3] * 255 : undefined);\r\n  },\r\n  getWebgl () {\r\n    if (this.floatArray == null) {\r\n      const floats = [this[0] / 255, this[1] / 255, this[2] / 255];\r\n      if (this[3] !== 255) floats.push(this[3] / 255);\r\n      this.floatArray = new Float32Array(floats);\r\n    }\r\n    return this.floatArray\r\n  },\r\n  get webgl () { return this.getWebgl() },\r\n  set webgl (floatArray) { this.setWebgl(floatArray); },\r\n\r\n  // Housekeeping when the color is modified.\r\n  checkColorChange () {\r\n    // Reset string & webgl on color change.\r\n    this.string = null; // will be lazy evaluated via getCss.\r\n    this.floatArray = null;\r\n  },\r\n  // Return true if color is same value as myself, comparing pixels\r\n  equals (color) { return this.getPixel() === color.getPixel() },\r\n  toString () { return `[${Array.from(this).toString()}]` },\r\n  // Return a [distance metric](\r\n  // http://www.compuphase.com/cmetric.htm) between two colors.\r\n  // Max distance is roughly 765 (3*255), for black & white.\r\n  // For our purposes, omitting the sqrt will not effect our results\r\n  rgbDistance (r, g, b) {\r\n    const [r1, g1, b1] = this;\r\n    const rMean = Math.round((r1 + r) / 2);\r\n    const [dr, dg, db] = [r1 - r, g1 - g, b1 - b];\r\n    const [dr2, dg2, db2] = [dr * dr, dg * dg, db * db];\r\n    const distanceSq =\r\n      (((512 + rMean) * dr2) >> 8) + (4 * dg2) + (((767 - rMean) * db2) >> 8);\r\n    return distanceSq // Math.sqrt(distanceSq)\r\n  }\r\n};\r\n\r\n// A colormap is simply an array of typedColors with several utilities such\r\n// as randomColor, closestColor etc.\r\n// This allows the colors to be simple integer indices\r\n// into the Array. They are also designed to be webgl-ready, being a\r\n// GLSL \"Uniform\" variable TypedArray for colors.\r\n\r\nconst ColorMap = {\r\n// ### Color Array Utilities\r\n  // Several utilities for creating color arrays\r\n\r\n// ### Gradients\r\n\r\n  // Ask the browser to use the canvas gradient feature\r\n  // to create nColors given the gradient color stops and locs.\r\n  // See Mozilla [Gradient Doc](\r\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient),\r\n  //\r\n  // This is a powerful browser feature, can be\r\n  // used to create all the MatLab colormaps.\r\n  //\r\n  // Stops are css strings or rgba arrays.\r\n  // Locs are floats from 0-1, default is equally spaced.\r\n  gradientImageData (nColors, stops, locs) {\r\n    // Convert the color stops to css strings\r\n    stops = stops.map((c) => Array.isArray(c) ? Color.rgbaString(...c) : c);\r\n    const ctx = util.createCtx(nColors, 1);\r\n    // Install default locs if none provide\r\n    if (!locs) locs = util.aRamp(0, 1, stops.length);\r\n    // Create a new gradient and fill it with the color stops\r\n    const grad = ctx.createLinearGradient(0, 0, nColors, 0);\r\n    util.repeat(stops.length, (i) => grad.addColorStop(locs[i], stops[i]));\r\n    // Draw the gradient, returning the image data TypedArray\r\n    ctx.fillStyle = grad;\r\n    ctx.fillRect(0, 0, nColors, 1);\r\n    return util.ctxImageData(ctx).data\r\n  },\r\n\r\n// ### Array Conversion Utilities\r\n\r\n  // Convert a Uint8Array into Array of 4 element typedColors.\r\n  // Useful for converting ImageData objects like gradients to colormaps.\r\n  // WebGL ready: the array.typedArray is suitable for Uniforms.\r\n  typedArraytoColors (typedArray) {\r\n    const array = [];\r\n    util.step(typedArray.length, 4,\r\n      // Note: can't share subarray as color's typed array:\r\n      // it's buffer is for entire array, not just subarray.\r\n      (i) => array.push(Color.color(...typedArray.subarray(i, i + 4))));\r\n    array.typedArray = typedArray;\r\n    return array\r\n  },\r\n  // Convert an Array of Arrays to an Array of typedColors.\r\n  // Webgl ready as above.\r\n  arraysToColors (array) {\r\n    const typedArray = new Uint8ClampedArray(array.length * 4);\r\n    util.repeat(array.length, (i) => {\r\n      const a = array[i];\r\n      if (a.length === 3) a.push(255);\r\n      typedArray.set(a, i * 4);\r\n    });\r\n    return this.typedArraytoColors(typedArray)\r\n  },\r\n\r\n  // Permute the values of 3 arrays. Ex:\r\n  //\r\n  // [1,2],[3],[4,5] -> [ [1,3,4],[1,3,5],[2,3,4],[2,3,5] ]\r\n  permuteArrays (A1, A2 = A1, A3 = A1) {\r\n    const array = [];\r\n    for (const a3 of A3) // sorta odd const works with ths, but...\r\n      for (const a2 of A2)\r\n        for (const a1 of A1)\r\n          array.push([a1, a2, a3]);\r\n    return array\r\n  },\r\n  // Use permuteArrays to create uniformly spaced color ramp permutation.\r\n  // Ex: if numRs is 3, permuteArrays's A1 would be [0, 127, 255]\r\n  permuteRGBColors (numRs, numGs = numRs, numBs = numRs) {\r\n    const toRamp = (num) => util.aIntRamp(0, 255, num);\r\n    const ramps = [numRs, numGs, numBs].map(toRamp);\r\n    return this.permuteArrays(...ramps)\r\n  },\r\n\r\n// ### ColorMaps\r\n\r\n  // ColorMaps are Arrays of TypedColors with these additional methods. Webgl\r\n  // ready if made w/ `typedArraytoColors` or `arraysToColors` above.\r\n  // Used to be memory effecent (shared colors), webgl compatible,  and for\r\n  // MatLab-like color-as-data.\r\n  ColorMapProto: {\r\n    // Inherit from Array\r\n    __proto__: Array.prototype,\r\n    // Create a [sparse array](https://goo.gl/lQlq5k) of index[pixel] = pixel.\r\n    // Used by indexOf below for exact match of a color within the colormap.\r\n    createIndex () {\r\n      this.index = [];\r\n      util.repeat(this.length, (i) => {\r\n        const px = this[i].getPixel();\r\n        this.index[px] = i;\r\n        if (this.cssNames) this.index[this.cssNames[i]] = i;\r\n      });\r\n    },\r\n    // Return a random index into the colormap array\r\n    randomIndex () { return util.randomInt(this.length) },\r\n    // Return a random color within the colormap\r\n    randomColor () { return this[this.randomIndex()] },\r\n    // Return the index of a typedColor within the colormap,\r\n    // undefined if no exact match.\r\n    // Use the `closest` methods below for nearest, not exact, match.\r\n    indexOf (color) {\r\n      if (this.index) return this.index[color.getPixel()]\r\n      for (let i = 0; i < this.length; i++)\r\n        if (color.equals(this[i])) return i\r\n      return undefined\r\n    },\r\n    // Return color scaled by number within [min, max].\r\n    // A linear interpolation (util.lerp) in [0, length-1].\r\n    // Used to match data directly to a color as in MatLab.\r\n    //\r\n    // Ex: scaleColor(25, 0, 50) returns the color in the middle of the colormap\r\n    scaleColor (number, min, max) {\r\n      number = util.clamp(number, min, max);\r\n      const scale = util.lerpScale(number, min, max);\r\n      const index = Math.round(util.lerp(0, this.length - 1, scale));\r\n      return this[index]\r\n    },\r\n    // Return the Uint8 array used to create the typedColors,\r\n    // undefined if not webgl ready.\r\n    webglArray () { return this.typedArray },\r\n\r\n    // Debugging: Return a string with length and array of colors\r\n    toString () { return `${this.length} ${util.arraysToString(this)}` },\r\n\r\n    // Iterate through the colormap colors, returning the index of the\r\n    // min typedColor.rgbDistance value from r, g, b\r\n    rgbClosestIndex (r, g, b) {\r\n      let minDist = Infinity;\r\n      let ixMin = 0;\r\n      for (var i = 0; i < this.length; i++) {\r\n        const d = this[i].rgbDistance(r, g, b);\r\n        if (d < minDist) {\r\n          minDist = d;\r\n          ixMin = i;\r\n          if (d === 0) return ixMin\r\n        }\r\n      }\r\n      return ixMin\r\n    },\r\n    // Return the color with the rgbClosestIndex value\r\n    rgbClosestColor (r, g, b) { return this[this.rgbClosestIndex(r, g, b)] },\r\n\r\n    // Calculate the closest cube index for the given r, g, b values.\r\n    // Faster than rgbClosestIndex, does direct calculation, not iteration.\r\n    cubeClosestIndex (r, g, b) {\r\n      const cube = this.cube;\r\n      const rgbSteps = cube.map(c => 255 / (c - 1));\r\n      const rgbLocs = [r, g, b].map((c, i) => Math.round(c / rgbSteps[i]));\r\n      const [rLoc, gLoc, bLoc] = rgbLocs;\r\n      return (rLoc) + (gLoc * cube[0]) + (bLoc * cube[0] * cube[1])\r\n    },\r\n    cubeClosestColor (r, g, b) { return this[this.cubeClosestIndex(r, g, b)] },\r\n\r\n    // Choose the appropriate method for finding closest index.\r\n    // Lets the user specify any color, and let the colormap\r\n    // use the best match.\r\n    closestIndex (r, g, b) {\r\n      return this.cube ? // eslint-disable-line\r\n        this.cubeClosestIndex(r, g, b) : this.rgbClosestIndex(r, g, b)\r\n    },\r\n    // Choose the appropriate method for finding closest color\r\n    closestColor (r, g, b) { return this[this.closestIndex(r, g, b)] }\r\n  },\r\n\r\n// ### Utilities for constructing ColorMaps\r\n\r\n  // Convert an array of rgb(a) Arrays or TypedColors to a webgl-ready colormap.\r\n  basicColorMap (colors) {\r\n    colors = this.arraysToColors(colors);\r\n    Object.setPrototypeOf(colors, this.ColorMapProto);\r\n    return colors\r\n  },\r\n  // Create a gray map (gray: r=g=b)\r\n  // These are typically 256 entries but can be smaller\r\n  // by passing a size parameter and the min/max range.\r\n  grayColorMap (min = 0, max = 255, size = max - min + 1) {\r\n    const ramp = util.aIntRamp(min, max, size);\r\n    return this.basicColorMap(ramp.map((i) => [i, i, i]))\r\n  },\r\n\r\n  // Create a colormap by permuted rgb values.\r\n  //\r\n  // numRs, numGs, numBs are numbers, the number of steps beteen 0-255.\r\n  // Ex: numRs = 3, corresponds to 0, 128, 255.\r\n  // NOTE: the defaults: rgbColorCube(6) creates a `6 * 6 * 6` cube.\r\n  rgbColorCube (numRs, numGs = numRs, numBs = numRs) {\r\n    const array = this.permuteRGBColors(numRs, numGs, numBs);\r\n    const map = this.basicColorMap(array);\r\n    // Save the parameters for fast color calculations.\r\n    map.cube = [numRs, numGs, numBs];\r\n    return map\r\n  },\r\n  // Create a colormap by permuting the values of the given arrays.\r\n  // Similar to above but with arrays that may have arbitrary values.\r\n  rgbColorMap (R, G, B) {\r\n    const array = this.permuteArrays(R, G, B);\r\n    return this.basicColorMap(array)\r\n  },\r\n\r\n  // Create an hsl map, inputs are arrays to be permutted like rgbColorMap.\r\n  // Convert the HSL values to Color.colors, default to bright hue ramp (L=50).\r\n  hslColorMap (H, S = [100], L = [50]) {\r\n    const hslArray = this.permuteArrays(H, S, L);\r\n    const array = hslArray.map(a => Color.toColor(Color.hslString(...a)));\r\n    return this.basicColorMap(array)\r\n  },\r\n\r\n  // Use gradient to build an rgba array, then convert to colormap.\r\n  // Stops are css strings or rgba arrays.\r\n  // locs defaults to evenly spaced, probably what you want.\r\n  //\r\n  // This easily creates all the MatLab colormaps like \"jet\" below.\r\n  gradientColorMap (nColors, stops, locs) {\r\n    const uint8arrays = this.gradientImageData(nColors, stops, locs);\r\n    const typedColors = this.typedArraytoColors(uint8arrays);\r\n    Object.setPrototypeOf(typedColors, this.ColorMapProto);\r\n    return typedColors\r\n  },\r\n  // The most popular MatLab gradient, \"jet\":\r\n  jetColors: [ [0, 0, 127], [0, 0, 255], [0, 127, 255], [0, 255, 255],\r\n    [127, 255, 127], [255, 255, 0], [255, 127, 0], [255, 0, 0], [127, 0, 0] ],\r\n  // Two other popular MatLab 'ramp' gradients are:\r\n  // * One color: from black/white to color, optionally back to white/black.\r\n  // stops = ['black', 'red'] or ['white', 'orange', 'black']\r\n  // The NetLogo map is a concatenation of 14 of these.\r\n  // * Two colors: stops = ['red', 'orange'] (blends the tow, center is white)\r\n\r\n  // The 16 unique [CSS Color Names](https://goo.gl/sxo36X), case insensitive.\r\n  // Aqua == Cyan and Fuchsia == Magenta, 18 total color names.\r\n  // These sorted by hue/saturation/light, hue in 0-300 degrees.\r\n  // In CSS 2.1, the color 'orange' was added to the 16 colors as a 17th color\r\n  // See [Mozilla Color Docs](https://goo.gl/tolSnS) for *lots* more!\r\n  basicColorNames: 'white silver gray black red maroon yellow orange olive lime green cyan teal blue navy magenta purple'.split(' '),\r\n  // Create a named colors colormap\r\n  cssColorMap (cssArray, createNameIndex = false) {\r\n    const array = cssArray.map(str => Color.stringToUint8s(str));\r\n    const map = this.basicColorMap(array);\r\n    map.cssNames = cssArray;\r\n    // REMIND: kinda tacky? Maybe map.name.yellow? Maybe generalize for other\r\n    // map types: map.closest(name)\r\n    if (createNameIndex) {\r\n      cssArray.forEach((name, ix) => { map[name] = map[ix]; });\r\n      if (map.cyan) map.aqua = map.cyan;\r\n      if (map.magenta) map.fuchsia = map.magenta;\r\n    }\r\n    return map\r\n  },\r\n\r\n// ### Shared Global ColorMaps\r\n\r\n  // The shared global colormaps are lazy evaluated to minimize memory use.\r\n  LazyMap (name, map) {\r\n    Object.defineProperty(this, name, {value: map, enumerable: true});\r\n    return map\r\n  },\r\n  get Gray () { return this.LazyMap('Gray', this.grayColorMap()) },\r\n  get LightGray () { return this.LazyMap('LightGray', this.grayColorMap(200)) },\r\n  get DarkGray () { return this.LazyMap('DarkGray', this.grayColorMap(0, 100)) },\r\n  get Jet () {\r\n    return this.LazyMap('Jet', this.gradientColorMap(256, this.jetColors))\r\n  },\r\n  get Rgb256 () { return this.LazyMap('Rgb256', this.rgbColorCube(8, 8, 4)) },\r\n  get Rgb () { return this.LazyMap('Rgb', this.rgbColorCube(16)) },\r\n  get Basic16 () { // 17 unique + 2 \"aliases\" = 19 names. \"16\" historic\r\n    return this.LazyMap('Basic16', this.cssColorMap(this.basicColorNames, true))\r\n  }\r\n};\r\n\r\n// AgentSets are arrays that are factories for their own agents/objects.\r\n// They are the base for Patches, Turtles and Links.\r\n\r\n// Vocab: AgentSets are NetLogo collections: Patches, Turtles, and Links.\r\n// Agent is an object in an AgentSet: Patch, Turtle, Link.\r\n\r\nclass AgentSet extends AgentArray {\r\n  // Magic to return AgentArray's rather than AgentSets\r\n  // Symbol.species: https://goo.gl/Zsxwxd\r\n  static get [Symbol.species] () { return AgentArray }\r\n\r\n  // Create an empty `AgentSet` and initialize the `ID` counter for add().\r\n  // If baseSet is supplied, the new agentset is a subarray of baseSet.\r\n  // This sub-array feature is how breeds are managed, see class `Model`\r\n  constructor (model, AgentClass, name, baseSet = null) {\r\n    super(); // create empty AgentArray\r\n    baseSet = baseSet || this; // if not a breed, set baseSet to this\r\n    // AgentSets know their model, name, baseSet, world.\r\n    // Object.assign(this, {model, name, baseSet, AgentClass, world: model.world})\r\n    Object.assign(this, {model, name, baseSet, AgentClass});\r\n    // BaseSets know their breeds and keep the ID global\r\n    if (this.isBaseSet()) {\r\n      this.breeds = {}; // will contain breedname: breed entries\r\n      this.ID = 0;\r\n    // Breeds add themselves to baseSet.\r\n    } else {\r\n      this.baseSet.breeds[name] = this;\r\n    }\r\n    // Keep a list of this set's variables; see `own` below\r\n    this.ownVariables = [];\r\n    // Create a proto for our agents by having a defaults and instance layer\r\n    // this.AgentClass = AgentClass\r\n    this.agentProto = new AgentClass(this);\r\n    this.protoMixin(this.agentProto, AgentClass);\r\n    // }\r\n  }\r\n  // All agents have:\r\n  // vars: id, agentSet, model, world, breed (getter)\r\n  //   baseSet by name: turtles/patches/links\r\n  // methods: setBreed, getBreed, isBreed\r\n  // getter/setter: breed\r\n  protoMixin (agentProto, AgentClass) {\r\n    Object.assign(agentProto, {\r\n      agentSet: this,\r\n      model: this.model\r\n      // world: this.world\r\n    });\r\n    agentProto[this.baseSet.name] = this.baseSet;\r\n\r\n    // if (this.isBaseSet()) {\r\n    // Model.reset should not redefine these.\r\n    if (!AgentClass.prototype.setBreed) {\r\n      Object.assign(AgentClass.prototype, {\r\n        setBreed (breed) { breed.setBreed(this); },\r\n        getBreed () { return this.agentSet },\r\n        isBreed (breed) { return this.agentSet === breed }\r\n      });\r\n      Object.defineProperty(AgentClass.prototype, 'breed', {\r\n        get: function () { return this.agentSet }\r\n      });\r\n    }\r\n  }\r\n\r\n  // Create a subarray of this AgentSet. Example: create a people breed of turtles:\r\n  // `people = turtles.newBreed('people')`\r\n  newBreed (name) {\r\n    return new AgentSet(this.model, this.AgentClass, name, this)\r\n  }\r\n\r\n  // Is this a baseSet or a derived \"breed\"\r\n  isBreedSet () { return this.baseSet !== this }\r\n  isBaseSet () { return this.baseSet === this }\r\n\r\n  // with (reporter) { return this.filter(reporter) }\r\n  // if (this.isBreedSet()) array = array.filter((a) => a.agentSet === this)\r\n\r\n  // Return breeds in a subset of an AgentSet.\r\n  // Ex: patches.inRect(5).withBreed(houses)\r\n  withBreed (breed) {\r\n    return this.with(a => a.agentSet === breed)\r\n  }\r\n\r\n  // Abstract method used by subclasses to create and add their instances.\r\n  create () { console.log(`AgentSet: Abstract method called: ${this}`); }\r\n\r\n  // Add an agent to the list.  Only used by agentset factory methods. Adds\r\n  // the `id` property to all agents. Increment `ID`.\r\n  // Returns the object for chaining. The set will be sorted by `id`.\r\n  addAgent (o) { // o only for breeds adding themselves to their baseSet\r\n    o = o || Object.create(this.agentProto); // REMIND: Simplify! Too slick.\r\n    if (this.isBreedSet())\r\n      this.baseSet.addAgent(o);\r\n    else\r\n      o.id = this.ID++;\r\n    this.push(o);\r\n    return o\r\n  }\r\n  clear () { while (this.any()) this.last().die(); } // die() is an agent method\r\n  // Remove an agent from the agentset, returning the agentset for chaining.\r\n  // Note removeAgent(agent) different than remove(agent) which simply removes\r\n  // the agent from it's array\r\n  removeAgent (o) {\r\n    // Remove me from my baseSet\r\n    if (this.isBreedSet()) this.baseSet.remove(o, 'id');\r\n    // Remove me from my set.\r\n    this.remove(o, 'id');\r\n    return this\r\n  }\r\n\r\n  // AgentSets often need a random color. We use a standard shared ColorMap map.\r\n  randomColor () { return ColorMap.Basic16.randomColor() }\r\n\r\n  // Get/Set default values for this agentset's agents.\r\n  // If name ends with \"color\", use value = toColor(value)\r\n  setDefault (name, value) {\r\n    if (name.match(/color$/i))\r\n      value = Color.toColor(value);\r\n    this.agentProto[name] = value;\r\n  }\r\n  getDefault (name) { return this.agentProto[name] }\r\n  // Used when getter/setter's need to know if get/set default\r\n  settingDefault (agent) { return agent.id == null }\r\n\r\n  // Declare variables of an agent class.\r\n  // `varnames` is a string of space separated names\r\n  own (varnames) {\r\n    // if (this.isBreedSet())\r\n    //   this.ownVariables = util.clone(this.baseSet.ownVariables)\r\n    for (const name of varnames.split(' ')) {\r\n      this.setDefault(name, null);\r\n      this.ownVariables.push(name);\r\n    }\r\n  }\r\n\r\n  // Move an agent from its AgentSet/breed to be in this AgentSet/breed.\r\n  setBreed (a) { // change agent a to be in this breed\r\n    // Return if `a` is already of my breed\r\n    if (a.agentSet === this) return\r\n    // Remove/insert breeds (not baseSets) from their agentsets\r\n    if (a.agentSet.isBreedSet()) a.agentSet.remove(a, 'id');\r\n    if (this.isBreedSet()) this.insert(a, 'id');\r\n\r\n    // Make list of `a`'s vars and my ownvars.\r\n    const avars = a.agentSet.ownVariables;\r\n    // First remove `a`'s vars not in my ownVariables\r\n    for (const avar of avars)\r\n      if (!this.ownVariables.includes(avar))\r\n        delete a[avar];\r\n    // Now add ownVariables to `a`'s vars, default to 0.\r\n    // If ownvar already in avars, it is not modified.\r\n    for (const ownvar of this.ownVariables)\r\n      if (!avars.includes(ownvar))\r\n        a[ownvar] = 0; // NOTE: NL uses 0, maybe we should use null?\r\n\r\n    // Give `a` my defaults/statics\r\n    return Object.setPrototypeOf(a, this.agentProto)\r\n  }\r\n}\r\n\r\n// The Animator runs the Model's step() and draw() methods.\r\n\r\n// Because not all models have the same animator requirements, we build a class\r\n// for customization by the programmer.  See these URLs for more info:\r\n// * [JavaScript timers docs](\r\n//    https://developer.mozilla.org/en-US/docs/JavaScript/Timers)\r\n// * [Using timers & requestAnimationFrame together](http://goo.gl/ymEEX)\r\n\r\nclass Animator {\r\n  // Create initial animator for the model, specifying rate (fps) and\r\n  // multiStep. Called by Model during initialization, use setRate to modify.\r\n  // If multiStep, run the draw() and step() methods separately by\r\n  // draw() using requestAnimationFrame and step() using setTimeout.\r\n  constructor (model, rate = 60, multiStep = false) {\r\n    Object.assign(this, {model, rate, multiStep});\r\n    this.reset();\r\n  }\r\n  // Adjust animator. Call before model.start()\r\n  // in setup() to change default settings\r\n  setRate (rate, multiStep = false) {\r\n    Object.assign(this, {rate, multiStep});\r\n    this.resetTimes();\r\n  }\r\n  // start/stop model, called by Model.\r\n  // Often used for debugging and resetting model.\r\n  start () {\r\n    if (!this.stopped) return // avoid multiple starts\r\n    this.resetTimes();\r\n    this.stopped = false;\r\n    this.animate();\r\n  }\r\n  stop () {\r\n    this.stopped = true;\r\n    if (this.animHandle) cancelAnimationFrame(this.animHandle);\r\n    if (this.timeoutHandle) clearTimeout(this.timeoutHandle);\r\n    this.animHandle = this.timeoutHandle = null;\r\n  }\r\n  // Internal utility: reset time instance variables\r\n  resetTimes () {\r\n    this.startMS = this.now();\r\n    this.startTick = this.ticks;\r\n    this.startDraw = this.draws;\r\n  }\r\n  // Reset used by model.reset when resetting model.\r\n  reset () { this.stop(); this.ticks = this.draws = 0; }\r\n  // Two handlers used by animation loop\r\n  step () { this.ticks++; this.model.step(); }\r\n  draw () { this.draws++; this.model.draw(); }\r\n  // step and draw the model once\r\n  once () { this.step(); this.draw(); }\r\n  // Get current time, with high resolution timer if available\r\n  now () { return performance.now() }\r\n  // Time in ms since starting animator\r\n  ms () { return this.now() - this.startMS }\r\n  // Get ticks/draws per second. They will differ if multiStep.\r\n  ticksPerSec () {\r\n    const dt = this.ticks - this.startTick;\r\n    return dt === 0 ? 0 : Math.round(dt * 1000 / this.ms()) // avoid divide by 0\r\n  }\r\n  drawsPerSec () {\r\n    const dt = this.draws - this.startDraw;\r\n    return dt === 0 ? 0 : Math.round(dt * 1000 / this.ms())\r\n  }\r\n  // Return a status string for debugging and logging performance\r\n  toString () {\r\n    return `ticks: ${this.ticks}, draws: ${this.draws}, rate: ${this.rate} tps/dps: ${this.ticksPerSec()}/${this.drawsPerSec()}`\r\n  }\r\n  // Animation via setTimeout and requestAnimationFrame.\r\n  // Arrow functions are required for callbacks for lexical scope.\r\n  animateSteps () {\r\n    this.step();\r\n    if (!this.stopped)\r\n      this.timeoutHandle = setTimeout(() => this.animateSteps(), 10);\r\n  }\r\n  animateDraws () {\r\n    if (this.drawsPerSec() < this.rate) { // throttle drawing to @rate\r\n      if (!this.multiStep) this.step();\r\n      this.draw();\r\n    }\r\n    if (!this.stopped)\r\n      this.animHandle = requestAnimationFrame(() => this.animateDraws());\r\n  }\r\n  // Called once by start() to get animateSteps & animateDraws iterating.\r\n  animate () {\r\n    if (this.multiStep) this.animateSteps();\r\n    this.animateDraws();\r\n  }\r\n}\r\n\r\n// A **DataSet** is an object with width/height and an array\r\n// whose length = width * height\r\n//\r\n// The data array can be a TypedArray or a javascript Array\r\n// Notice that it is very much like an ImageData object!\r\n\r\nclass DataSet {\r\n  // **Static methods:** called via DataSet.foo(), similar to Math.foo().\r\n  // Generally useful utilities for use with TypedArrays & JS Arrays\r\n\r\n  // Return an empty dataset of given width, height, dataType\r\n  static emptyDataSet (width, height, Type) {\r\n    return new DataSet(width, height, new Type(width * height))\r\n  }\r\n\r\n  // The **DataSet Class** constructor and methods\r\n\r\n  // constructor: Stores the three DataSet components.\r\n  // Checks data is right size, throws an error if not.\r\n  constructor (width, height, data) {\r\n    if (data.length !== width * height)\r\n      throw Error(`new DataSet length: ${data.length} !== ${width} * ${height}`)\r\n    else\r\n      Object.assign(this, {width, height, data});\r\n      // [this.width, this.height, this.data] = [width, height, data]\r\n  }\r\n\r\n  // Get/Set name, useful for storage key.\r\n  setName (string) { this.name = string; return this }\r\n  getName () { return this.name ? this.name : this.makeName() }\r\n  makeName () {\r\n    const {width, height} = this;\r\n    const sum = util.arraySum(this.data).toFixed(2);\r\n    return `${this.dataType().name}-${width}-${height}-${sum}`\r\n  }\r\n\r\n  // Checks x,y are within DataSet. Throw error if not.\r\n  checkXY (x, y) {\r\n    if (!this.inBounds(x, y))\r\n      throw Error(`DataSet.checkXY: x,y out of range: ${x}, ${y}`)\r\n  }\r\n  // true if x,y in dataset bounds\r\n  inBounds (x, y) {\r\n    return (util.between(x, 0, this.width - 1) && util.between(y, 0, this.height - 1))\r\n  }\r\n\r\n  dataType () { return this.data.constructor }\r\n  type () { return this.constructor }\r\n\r\n  // Given x,y in data space, return index into data\r\n  toIndex (x, y) { return x + (y * this.width) }\r\n\r\n  // Given index into data, return dataset [x, y] position\r\n  toXY (i) { return [i % this.width, Math.floor(i / this.width)] }\r\n\r\n  // Get dataset value at x,y, assuming that x,y valididated previously\r\n  // getXY (x, y) { return this.data[this.toIndex(Math.floor(x), Math.floor(y))] }\r\n  getXY (x, y) { return this.data[this.toIndex(x, y)] }\r\n\r\n  // Set the data value at x,y to num. assume x,y valid\r\n  // setxy (x, y, num) { this.data[this.toIndex(Math.floor(x), Math.floor(y))] = num }\r\n  setxy (x, y, num) { this.data[this.toIndex(x, y)] = num; }\r\n\r\n  // Wrapper for sampling, defaults to \"nearest\". Checks x,y valid as well.\r\n  // Use this for individual sampling.\r\n  sample (x, y, useNearest = true) {\r\n    this.checkXY(x, y);\r\n    return useNearest ? this.nearest(x, y) : this.bilinear(x, y)\r\n  }\r\n\r\n  // Nearest neighbor sampling, w/o x,y validity check, i.e. our inner loops\r\n  nearest (x, y) {\r\n    return this.getXY(Math.round(x), Math.round(y))\r\n  }\r\n\r\n  // Billinear sampling w/o x,y validity check, i.e. our inner loops\r\n  bilinear (x, y) {\r\n    // Billinear sampling works by making two linear interpolations (lerps)\r\n    // in the x direction, and a third in the y direction, between the\r\n    // two x results. See wikipedia:\r\n    // [bilinear sampling](http://en.wikipedia.org/wiki/Bilinear_interpolation)\r\n    // The diagram shows the three lerps\r\n\r\n    // const [x0, y0] = [Math.floor(x), Math.floor(y)] // replaced by next line for speed\r\n    const x0 = Math.floor(x);\r\n    const y0 = Math.floor(y);\r\n    const i = this.toIndex(x0, y0);\r\n    const w = this.width;\r\n    // const [dx, dy] = [(x - x0), (y - y0)] // dx, dy = 0 if x, y on boundary. commented out for speed\r\n    // const [dx1, dy1] = [1 - dx, 1 - dy] // dx1, dy1 = 1 if x, y on boundary\r\n    const dx = x - x0;\r\n    const dy = y - y0;\r\n    const dx1 = 1 - dx;\r\n    const dy1 = 1 - dy;\r\n    const f00 = this.data[i];\r\n    // Edge case: fij is 0 if beyond data array; undefined -> 0.\r\n    // This cancels the given component's factor in the result.\r\n    const f10 = this.data[i + 1] || 0; // 0 at bottom right corner\r\n    const f01 = this.data[i + w] || 0; // 0 at all bottom row\r\n    const f11 = this.data[i + 1 + w] || 0; // 0 at end of next to bottom row\r\n    // This is a bit involved but:\r\n    // ```\r\n    // If dx = 0; dx1 = 1, dy != 0\r\n    // -> vertical linear interpolation\r\n    // fxy = f00(1-dy) + f01(dy) i.e. y-lerp\r\n    //\r\n    // If dx != 0; dy = 0, dx !=0\r\n    // -> horizontal linear interpolation\r\n    // fxy = f00(1-dx) + f10(dx) i.e. x-lerp\r\n    // ```\r\n    return (f00 * dx1 * dy1) + (f10 * dx * dy1) +\r\n           (f01 * dx1 * dy) + (f11 * dx * dy)\r\n  }\r\n\r\n  // Return a copy of this, with new data array\r\n  copy () {\r\n    return new DataSet(this.width, this.height, util.copyArray(this.data))\r\n  }\r\n\r\n  // Return new (empty) dataset, defaulting to this type\r\n  emptyDataSet (width, height, type = this.dataType()) {\r\n    return DataSet.emptyDataSet(width, height, type) // see static above\r\n  }\r\n\r\n  // Return new (empty) array of this type\r\n  emptyArray (length) {\r\n    const Type = this.type();\r\n    return new Type(length)\r\n  }\r\n\r\n  // Create new dataset of size width/height/type by resampling each point.\r\n  // Type is not this.type() due to integer/float differences. Default Array.\r\n  // If same size, return a copy of this.\r\n  resample (width, height, useNearest = true, Type = Array) {\r\n    if (width === this.width && height === this.height) return this.copy()\r\n    const ds = DataSet.emptyDataSet(width, height, Type);\r\n    const xScale = (this.width - 1) / (width - 1);\r\n    const yScale = (this.height - 1) / (height - 1);\r\n    for (let y = 0; y < height; y++)\r\n      for (let x = 0; x < width; x++)\r\n        ds.setxy(x, y, this.sample(x * xScale, y * yScale, useNearest));\r\n    return ds\r\n  }\r\n\r\n  // Return a rectangular subset of the dataset.\r\n  // Returned dataset is of same array type as this.\r\n  subset (x, y, width, height) {\r\n    if ((x + width) > this.width || (y + height) > this.height)\r\n      throw Error('DataSet.subSet: params out of range')\r\n    const ds = this.emptyDataSet(width, height);\r\n    for (let i = 0; i < width; i++)\r\n      for (let j = 0; j < height; j++)\r\n        ds.setxy(i, j, this.getXY(i + x, j + y));\r\n    return ds\r\n  }\r\n\r\n  // Return maped dataset by applying f to each dataset element\r\n  map (f) {\r\n    return new DataSet(this.width, this.height, this.data.map(f))\r\n  }\r\n\r\n  // Return the column of data at position x as this array's type\r\n  col (x) {\r\n    const [w, h, data] = [this.width, this.height, this.data];\r\n    if (x >= w)\r\n      throw Error(`col: x out of range width: ${w} x: ${x}`)\r\n    const colData = this.emptyArray(h);\r\n    for (let i = 0; i < h; i++)\r\n      colData[i] = data[x + i * w];\r\n    return colData\r\n  }\r\n\r\n  // Return the row of data at position y as this array's type\r\n  row (y) {\r\n    const [w, h] = [this.width, this.height];\r\n    if (y >= h)\r\n      throw Error(`row: y out of range height: ${h} x: ${y}`)\r\n    return this.data.slice(y * w, (y + 1) * w)\r\n  }\r\n\r\n  // Convert this dataset's data to new type. Precision may be lost.\r\n  // Does nothing if current data is already of this Type.\r\n  convertType (type) {\r\n    this.data = util.convertArray(this.data, type);\r\n  }\r\n\r\n  // Concatinate a dataset of equal height to my right to my east.\r\n  // New DataSet is of same type as this.\r\n  //\r\n  // NOTE: concatWest is dataset.concatEast(this)\r\n  concatEast (ds) {\r\n    const [w, h] = [this.width, this.height];\r\n    const [w1, h1] = [ds.width, ds.height];\r\n    if (h !== h1)\r\n      throw Error(`concatEast: heights not equal ${h}, ${h1}`)\r\n    const ds1 = this.emptyDataSet((w + w1), h);\r\n    for (let x = 0; x < h; x++) // copy this into new dataset\r\n      for (let y = 0; y < w; y++)\r\n        ds1.setxy(x, y, this.getXY(x, y));\r\n    for (let x = 0; x < h1; x++) // copy ds to the left side\r\n      for (let y = 0; y < w1; y++)\r\n        ds1.setxy(x + w, y, ds.getXY(x, y));\r\n    return ds1\r\n  }\r\n\r\n  // Concatinate a dataset of equal width to my south, returning new DataSet.\r\n  // New DataSet is of same type as this.\r\n  //\r\n  // NOTE: concatNorth is dataset.concatSouth(this)\r\n  concatSouth (dataset) {\r\n    const [w, h, data] = [this.width, this.height, this.data];\r\n    if (w !== dataset.width)\r\n      throw Error(`concatSouth: widths not equal ${w}, ${dataset.width}`)\r\n    const data1 = util.concatArrays(data, dataset.data);\r\n    return new DataSet(w, h + dataset.height, data1)\r\n  }\r\n\r\n  // return dataset x,y given x,y in a euclidean space defined by tlx, tly, w, h\r\n  // x,y is in topleft-bottomright box: [tlx,tly,tlx+w,tly-h], y positive util.\r\n  // Ex: NetLogo's coords: x, y, minXcor, maxYcor, numX, numY\r\n  transformCoords (x, y, tlx, tly, w, h) {\r\n    const xs = (x - tlx) * (this.width - 1) / w;\r\n    const ys = (tly - y) * (this.height - 1) / h;\r\n    return [xs, ys]\r\n  }\r\n\r\n  // get a sample using a transformed euclidean coord system; see above\r\n  coordSample (x, y, tlx, tly, w, h, useNearest = true) {\r\n    const [xs, ys] = this.transformCoords(x, y, tlx, tly, w, h);\r\n    return this.sample(xs, ys, useNearest)\r\n  }\r\n\r\n  // Return Array 3x3 neighbor values of the given x,y of the dataset.\r\n  // Off-edge neighbors revert to nearest edge value.\r\n  neighborhood (x, y, array = []) {\r\n    array.length = 0;  // in case user supplied an array to reduce GC\r\n    const clampNeeded = (x === 0) || (x === this.width - 1) ||\r\n                        (y === 0) || (y === this.height - 1);\r\n    for (let dy = -1; dy <= +1; dy++) {\r\n      for (let dx = -1; dx <= +1; dx++) {\r\n        let x0 = x + dx;\r\n        let y0 = y + dy;\r\n        if (clampNeeded) {\r\n          x0 = util.clamp(x0, 0, this.width - 1);\r\n          y0 = util.clamp(y0, 0, this.height - 1);\r\n        }\r\n        array.push(this.data[this.toIndex(x0, y0)]);\r\n      }\r\n    }\r\n    return array\r\n  }\r\n\r\n  // Return a new dataset of this array type convolved with the\r\n  // given kernel 3x3 matrix. See [Convolution article](https://goo.gl/gCfXmU)\r\n  //\r\n  // If cropped, do not convolve the edges, returning a smaller dataset.\r\n  // If not, convolve the edges by extending edge values, returning\r\n  // dataset of same size.\r\n  convolve (kernel, factor = 1, crop = false) {\r\n    const [x0, y0, h, w] = crop // optimization not needed, only called once\r\n     ? [1, 1, this.height - 1, this.width - 1]\r\n     : [0, 0, this.height, this.width];\r\n    const newDS = this.emptyDataSet(w, h);\r\n    const newData = newDS.data;\r\n    let i = 0;\r\n    for (let y = y0; y < h; y++) {\r\n      for (let x = x0; x < w; x++) {\r\n        const nei = this.neighborhood(x, y);\r\n        let sum2 = 0;\r\n        for (let i2 = 0; i2 < kernel.length; i2++) {\r\n          // sum2 += kernel[i2] * nei[i2] // Chrome can't optimize compound let\r\n          sum2 = sum2 + kernel[i2] * nei[i2];\r\n        }\r\n        newData[i++] = sum2 * factor; // newDS.data[newDS.toIndex(x, y)] = sum2 * factor\r\n      }\r\n    }\r\n    return newDS\r\n  }\r\n\r\n  // A few common convolutions.  dzdx/y are also called horiz/vert Sobel\r\n  dzdx (n = 2, factor = 1 / 8) {\r\n    return this.convolve([-1, 0, 1, -n, 0, n, -1, 0, 1], factor)\r\n  }\r\n  dzdy (n = 2, factor = 1 / 8) {\r\n    return this.convolve([1, n, 1, 0, 0, 0, -1, -n, -1], factor)\r\n  }\r\n  laplace8 () {\r\n    return this.convolve([-1, -1, -1, -1, 8, -1, -1, -1, -1])\r\n  }\r\n  laplace4 () {\r\n    return this.convolve([0, -1, 0, -1, 4, -1, 0, -1, 0])\r\n  }\r\n  blur (factor = 0.0625) { // 1/16 = 0.0625\r\n    return this.convolve([1, 2, 1, 2, 4, 2, 1, 2, 1], factor)\r\n  }\r\n  edge () {\r\n    return this.convolve([1, 1, 1, 1, -7, 1, 1, 1, 1])\r\n  }\r\n\r\n  // Create two new Array convolved datasets, slope and aspect, common in\r\n  // the use of an elevation data set. See Esri tutorials for\r\n  // [slope](http://goo.gl/ZcOl08) and [aspect](http://goo.gl/KoI4y5)\r\n  //\r\n  // It also returns the two derivitive DataSets, dzdx, dzdy for\r\n  // those wanting to use the results of the two convolutions.\r\n  //\r\n  // Use this.convertType to convert to typed array\r\n  slopeAndAspect (cellSize = 1, noNaNs = true, posAngle = true) {\r\n    const dzdx = this.dzdx(); // sub left z from right\r\n    const dzdy = this.dzdy(); // sub bottom z from top\r\n    let [aspect, slope] = [[], []];\r\n    const [h, w] = [dzdx.height, dzdx.width];\r\n    for (let y = 0; y < h; y++) {\r\n      for (let x = 0; x < w; x++) {\r\n        let [gx, gy] = [dzdx.getXY(x, y), dzdy.getXY(x, y)];\r\n        slope.push(Math.atan(util.distance(gx, gy)) / cellSize); // radians\r\n        if (noNaNs)\r\n          while (gx === gy) {\r\n            gx += util.randomNormal(0, 0.0001);\r\n            gy += util.randomNormal(0, 0.0001);\r\n          }\r\n        // radians in [-PI,PI], downhill\r\n        let rad = (gx === gy && gy === 0) ? NaN : Math.atan2(-gy, -gx);\r\n        // positive radians in [0,2PI] if desired\r\n        if (posAngle && rad < 0) rad += 2 * Math.PI;\r\n        aspect.push(rad);\r\n      }\r\n    }\r\n    slope = new DataSet(w, h, slope);\r\n    aspect = new DataSet(w, h, aspect);\r\n    return { slope, aspect, dzdx, dzdy }\r\n  }\r\n\r\n  // REMIND: limit to data that can be 24 bit. Error otherwise.\r\n  // DataType of Int8, 16, Int24 OK, others need testing.\r\n  // Possibly use precision to minimize byte size to 3, rgb?\r\n  //\r\n  // Convert dataset to an image context object.\r\n  //\r\n  // This can be used to \"visualize\" the data by normalizing\r\n  // which will scale the data to use the entire RGB space.\r\n  // It can also be used to create tiles or image-as-data if\r\n  // the defaults are used.\r\n  //\r\n  // Due to\r\n  // [alpha-premultiply](https://en.wikipedia.org/wiki/Alpha_compositing),\r\n  // the best we can do as data is 24 bit ints.\r\n  // You can simulate floats/fixed by multiplying the dataset\r\n  // the dividing on conversion back.\r\n  //\r\n  // Our preferred transport is in the works, likely in the\r\n  // tile datasets via blobs or arraybuffers. Sigh.\r\n  toContext (normalize = false, gray = false, alpha = 255) {\r\n    const [w, h, data] = [this.width, this.height, this.data];\r\n    let idata;\r\n    if (normalize) {\r\n      idata = gray\r\n        ? util.normalize8(data) : util.normalizeInt(data, 0, Math.pow(2, 24) - 1);\r\n    } else {\r\n      idata = data.map((a) => Math.round(a));\r\n    }\r\n    const ctx = util.createCtx(w, h);\r\n    const id = ctx.getImageData(0, 0, w, h);\r\n    const ta = id.data; // ta short for typed array\r\n    for (let i = 0; i < idata.length; i++) {\r\n      const [num, j] = [idata[i], 4 * i]; // j = byte index into ta\r\n      if (gray) {\r\n        ta[j] = ta[j + 1] = ta[j + 2] = Math.floor(num); ta[j + 3] = alpha;\r\n      } else {\r\n        ta[j] = (num >> 16) & 0xff;\r\n        ta[j + 1] = (num >> 8) & 0xff;\r\n        ta[j + 2] = num & 0xff;\r\n        ta[j + 3] = alpha; // if not 255, image will be premultiplied.\r\n      }\r\n    }\r\n    ctx.putImageData(id, 0, 0);\r\n    return ctx\r\n  }\r\n\r\n  // Convert dataset to a canvas, which can be used as an image\r\n  toCanvas (normalize = false, gray = false, alpha = 255) {\r\n    return this.toContext(gray, normalize, alpha).canvas\r\n  }\r\n  // Convert dataset to a base64 string\r\n  toDataUrl (normalize = false, gray = false, alpha = 255) {\r\n    return util.ctxToDataUrl(this.toContext(gray, normalize, alpha))\r\n  }\r\n\r\n  // Return max/min of data\r\n  max () {\r\n    return this.data.reduce(function (a, b) {\r\n      return Math.max(a, b)\r\n    })\r\n  }\r\n  min () {\r\n    return this.data.reduce(function (a, b) {\r\n      return Math.min(a, b)\r\n    })\r\n  }\r\n  // Test that this has same width, height, data as dataset.\r\n  // Note: does not require equal array type (Array or TypedArray)\r\n  equals (dataset) {\r\n    return this.width === dataset.width &&\r\n      this.height === dataset.height &&\r\n      util.arraysEqual(this.data, dataset.data)\r\n  }\r\n}\r\n\r\n// An .asc GIS file: a text file with a header:\r\n//\r\n//     ncols 195\r\n//     nrows 195\r\n//     xllcorner -84.355652\r\n//     yllcorner 39.177963\r\n//     cellsize 0.000093\r\n//     NODATA_value -9999\r\n//\r\n// ..followed by a ncols X nrows matrix of numbers\r\n\r\nclass AscDataSet extends DataSet {\r\n  constructor (ascString, Type = Array, options = {}) {\r\n    const textData = ascString.split('\\n');\r\n    const header = {};\r\n    util.repeat(6, (i) => {\r\n      const keyVal = textData[i].split(/\\s+/);\r\n      header[keyVal[0].toLowerCase()] = parseFloat(keyVal[1]);\r\n    });\r\n    const data = [];\r\n    util.repeat(header.nrows, (i) => {\r\n      const nums = textData[6 + i].trim().split(' ');\r\n      for (const num of nums)\r\n        data.push(parseFloat(num));\r\n    });\r\n    super(header.ncols, header.nrows, util.convertArray(data, Type));\r\n    this.header = header;\r\n    Object.assign(this, options);\r\n  }\r\n}\r\n\r\n// Export/Import DataSets\r\n// import DataSet from './DataSet.js'\r\n// Private utility functions:\r\n\r\n// Create a legal dataset JSON object, defaulting to base64 data string.\r\n// This is the object that JSON.stringify will use for IO\r\nfunction jsonObject (dataset, useBase64, meta) {\r\n  return {\r\n    width: dataset.width,\r\n    height: dataset.height,\r\n    data: arrayToString(dataset.data, useBase64),\r\n    dataType: dataset.dataType().name,\r\n    meta: meta\r\n  }\r\n}\r\n// Convert an array, Typed or JS, to a string for dataset's data array\r\nfunction arrayToString (array, useBase64) {\r\n  if (useBase64) {\r\n    const data = util.arrayToBuffer(array);\r\n    return util.bufferToBase64(data)\r\n  }\r\n  return JSON.stringify(util.convertArray(array, Array))\r\n}\r\n// Convert a string, base64 or JSON, to an array of the given Type\r\nfunction stringToArray (string, dataTypeName) {\r\n  const dataType = window[dataTypeName];\r\n  if (isBase64(string)) {\r\n    const uint8array = util.base64ToBuffer(string);\r\n    return util.bufferToArray(uint8array, dataType)\r\n  }\r\n  return util.convertArray(JSON.parse(string), dataType)\r\n}\r\nfunction isBase64 (arrayString) {\r\n  // Base64 does not allow '[', only A-Z, a-z, 0-9, +, /\r\n  // https://en.wikipedia.org/wiki/Base64\r\n  return arrayString[0] !== '['\r\n}\r\n\r\nconst DataSetIO = {\r\n  // JSON import/export. The JSON returned looks like:\r\n  // ```\r\n  // {\r\n  //   width: dataset.width,\r\n  //   height: dataset.height,\r\n  //   data: string, // json or base64 string of DataSet array\r\n  //   dataType: string, // name of data array type: TypedArray or Array\r\n  //   type: string, // dataset class name\r\n  // }\r\n  // ```\r\n\r\n  // Create JSON string from DataSet, see jsonObject above\r\n  dataSetToJson (dataset, useBase64 = true, meta = {}) {\r\n    const obj = jsonObject(dataset, useBase64, meta);\r\n    return JSON.stringify(obj)\r\n  },\r\n\r\n  // Convert the jsonObject string to a basic dataset: width, height, data.\r\n  // The data array will be the same type as the original dataset.\r\n  jsonToDataSet (jsonString) {\r\n    const jsonObj = JSON.parse(jsonString);\r\n    const data = stringToArray(jsonObj.data, jsonObj.dataType);\r\n    return new DataSet(jsonObj.width, jsonObj.height, data)\r\n  },\r\n\r\n  // IndexedDB uses the [Structured Clone Algorithm](https://goo.gl/x8H9HK).\r\n  // DataSets can be directly stored and retrieved, they satisfy\r\n  // the SCA requirements.\r\n  toIndexedDB (dataset) {\r\n    return dataset // place holder for IDB sugar if needed\r\n  }\r\n};\r\n\r\n// A small Int24/Uint24 module, mainly for rgb image data\r\n\r\n// A shared 4 element Uint8Array array and two 1 element 32bit views\r\nconst byteArray = new Uint8Array(4);\r\nconst uint24array = new Uint32Array(byteArray.buffer);\r\nconst int24array = new Int32Array(byteArray.buffer);\r\n\r\nconst Int24 = {\r\n\r\n  maxUint24: (2 ** 24) - 1,\r\n  minUint24: 0,\r\n  maxInt24: (2 ** 23) - 1,\r\n  minInt24: 0 - (2 ** 23), // REMIND: rollup bug\r\n\r\n  checkInt24 (int) {\r\n    if (int < this.minInt24 || int > this.maxInt24)\r\n      throw Error(`Int24: Range error ${int}`)\r\n  },\r\n  checkUint24 (int) {\r\n    if (int < this.minUint24 || int > this.maxUint24)\r\n      throw Error(`Uint24: Range error ${int}`)\r\n  },\r\n\r\n  // RGB most common case but any 3 sequential bytes OK\r\n  rgbToInt24 (r, g, b) {\r\n    // byteArray.set([r, g, b, b > 127 ? 255 : 0]) // slow!\r\n    byteArray[0] = r;\r\n    byteArray[1] = g;\r\n    byteArray[2] = b;\r\n    byteArray[3] = b > 127 ? 255 : 0;\r\n    return int24array[0]\r\n  },\r\n  rgbToUint24 (r, g, b) {\r\n    byteArray[0] = r;\r\n    byteArray[1] = g;\r\n    byteArray[2] = b;\r\n    byteArray[3] = 0;\r\n    return uint24array[0]\r\n  },\r\n  int24ToRGB (int24) {\r\n    this.checkInt24(int24);\r\n    int24array[0] = int24;\r\n    // return byteArray.slice(0, 3) // slow!\r\n    return [byteArray[0], byteArray[1], byteArray[2]]\r\n  },\r\n  uint24ToRGB (uint24) {\r\n    this.checkUint24(uint24);\r\n    uint24array[0] = uint24;\r\n    return [byteArray[0], byteArray[1], byteArray[2]]\r\n  }\r\n\r\n};\r\n\r\n// Flyweight object creation, see Patch/Patches.\r\n\r\n// Class Link instances form a link between two turtles, forming a graph.\r\n\r\n// The core default variables needed by a Link.\r\n// Use links.setDefault(name, val) to change\r\n// Modelers add additional \"own variables\" as needed.\r\n// const linkVariables = { // Core variables for patches. Not 'own' variables.\r\n//   // id: null,             // unique id, promoted by agentset's add() method\r\n//   // defaults: null,       // pointer to defaults/proto object\r\n//   // agentSet: null,       // my agentset/breed\r\n//   // model: null,      // my model\r\n//   // world: null,          // my agent/agentset's world\r\n//   // links: null,          // my baseSet\r\n//\r\n//   end0: 0,              // Turtles: end0 & 1 are turtle ends of the link\r\n//   end1: 0,\r\n//   color: Color.toColor('yellow'), // Note: links must have A = 255, opaque.\r\n//   // z: 1, // possibly a z offset from the turtles?\r\n//\r\n//   // Line width. In Three.js/webgl this is always 1. See\r\n//   // [Drawing Lines is Hard!](https://mattdesl.svbtle.com/drawing-lines-is-hard)\r\n//   width: 1\r\n// }\r\nclass Link {\r\n  static defaultVariables () { // Core variables for patches. Not 'own' variables.\r\n    return {\r\n      end0: null,       // Turtles: end0 & 1 are turtle ends of the link\r\n      end1: null,\r\n      typedColor: null, // A Color.color, converted by getter/setters below\r\n      width: 1          // THREE: must be 1. Canvas2D (unsupported) has widths.\r\n    }\r\n  }\r\n  // Initialize a Link\r\n  constructor () {\r\n    // const vars = Link.defaultVariables()\r\n    // Object.assign(this, vars)\r\n    // this.color = null // avoid getter/setter used by assign\r\n    Object.assign(this, Link.defaultVariables());\r\n  }\r\n  init (from, to) {\r\n    this.end0 = from;\r\n    this.end1 = to;\r\n    from.links.push(this);\r\n    to.links.push(this);\r\n  }\r\n  // Remove this link from its agentset\r\n  die () {\r\n    this.agentSet.removeAgent(this);\r\n    util.removeItem(this.end0.links, this);\r\n    util.removeItem(this.end1.links, this);\r\n  }\r\n\r\n  bothEnds () { return [this.end0, this.end1] }\r\n  length () { return this.end0.distance(this.end1) }\r\n  otherEnd (turtle) {\r\n    if (turtle === this.end0) return this.end1\r\n    if (turtle === this.end1) return this.end0\r\n    throw Error(`Link.otherEnd: turtle not a link turtle: ${turtle}`)\r\n  }\r\n\r\n  // Use typedColor as the real color. Amazingly enough, setdefaults\r\n  // of 'color' ends up calling setter, thus making typedColor the default name.\r\n  // Whew!\r\n  setColor (color) {\r\n    const typedColor = Color.toColor(color); // Convert to Color.color\r\n    const fixedColor = this.links.renderer.fixedColor; // Model set to Color.color\r\n    if (fixedColor && !typedColor.equals(fixedColor)) {\r\n      util.warn(`links.setColor: fixedColor != color ${fixedColor.toString()}`);\r\n    } else {\r\n      this.typedColor = typedColor;\r\n    }\r\n  }\r\n  getColor () { return this.typedColor }\r\n  set color (color) { this.setColor(color); }\r\n  get color () { return this.getColor() }\r\n  // color prop can be used by *must* be Color.colors\r\n}\r\n\r\n// Links are a collection of all the Link objects between turtles.\r\nclass Links extends AgentSet {\r\n  // constructor (model, AgentClass, name) {\r\n  //   // AgentSet sets these variables:\r\n  //   // model, name, baseSet, world: model.world & agentProto: new AgentClass\r\n  //   super(model, AgentClass, name)\r\n  //   // Skip if an basic Array ctor or a breedSet. See AgentSet comments.\r\n  //   // if (typeof model === 'number' || this.isBreedSet()) return\r\n  //\r\n  //   // this.labels = [] // sparse array for labels\r\n  // }\r\n\r\n  // Factory: Add 1 or more links from the from turtle to the to turtle(s) which\r\n  // can be a single turtle or an array of turtles. The optional init\r\n  // proc is called on the new link after inserting in the agentSet.\r\n  create (from, to, initFcn = (link) => {}) {\r\n    if (!Array.isArray(to)) to = [to];\r\n    return to.map((t) => { // REMIND: skip dups\r\n      const link = this.addAgent();\r\n      link.init(from, t);\r\n      initFcn(link);\r\n      if (!link.color) link.color = this.randomColor();\r\n      return link\r\n    }) // REMIND: return single link if to not an array?\r\n  }\r\n}\r\n\r\n// class World defines the coordinate system for the model.\r\n// It will be upgraded with methods converting from other\r\n// transforms like GIS and DataSets.\r\n\r\nclass World {\r\n  static defaultOptions (size = 13, max = 16) {\r\n    return {\r\n      patchSize: size,\r\n      minX: -max,\r\n      maxX: max,\r\n      minY: -max,\r\n      maxY: max\r\n    }\r\n  }\r\n  // Initialize the world w/ defaults overridden w/ options.\r\n  constructor (options = {}) {\r\n    Object.assign(this, World.defaultOptions()); // initial this w/ defaults\r\n    Object.assign(this, options); // override defaults with options\r\n    this.setWorld();\r\n  }\r\n  // Complete properties derived from patchSize, minX/Y, maxX/Y\r\n  setWorld () {\r\n    this.numX = this.maxX - this.minX + 1;\r\n    this.numY = this.maxY - this.minY + 1;\r\n    this.width = this.numX * this.patchSize;\r\n    this.height = this.numY * this.patchSize;\r\n    this.minXcor = this.minX - 0.5;\r\n    this.maxXcor = this.maxX + 0.5;\r\n    this.minYcor = this.minY - 0.5;\r\n    this.maxYcor = this.maxY + 0.5;\r\n    this.centerX = (this.minX + this.maxX) / 2;\r\n    this.centerY = (this.minY + this.maxY) / 2;\r\n  }\r\n  isOnWorld (x, y) {\r\n    return (this.minXcor <= x) && (x <= this.maxXcor) &&\r\n           (this.minYcor <= y) && (y <= this.maxYcor)\r\n  }\r\n  setCtxTransform (ctx) {\r\n    ctx.canvas.width = this.width;\r\n    ctx.canvas.height = this.height;\r\n    ctx.save();\r\n    ctx.scale(this.patchSize, -this.patchSize);\r\n    ctx.translate(-(this.minXcor), -(this.maxYcor));\r\n  }\r\n}\r\n\r\n// Patches are the world other agentsets live on. They create a coord system\r\n// from Model's world values: size, minX, maxX, minY, maxY\r\nclass Patches extends AgentSet {\r\n  constructor (model, AgentClass, name) {\r\n    // AgentSet sets these variables:\r\n    // model, name, baseSet, world: model.world, agentProto: new AgentClass\r\n    // REMIND: agentProto: defaults, agentSet, world, [name]=agentSet.baseSet\r\n    super(model, AgentClass, name);\r\n\r\n    // Skip if a breedSet (don't rebuild patches!).\r\n    if (this.isBreedSet()) return\r\n\r\n    this.populate();\r\n    this.setPixels();\r\n    this.labels = []; // sparse array for labels\r\n  }\r\n  // Set up all the patches.\r\n  populate () {\r\n    util.repeat(this.model.world.numX * this.model.world.numY, (i) => {\r\n      this.addAgent(); // Object.create(this.agentProto))\r\n    });\r\n  }\r\n  // Setup pixels ctx used for patch.color: `draw` and `importColors`\r\n  setPixels () {\r\n    const {numX, numY} = this.model.world;\r\n    // const ctx = this.model.contexts.patches\r\n    // const pixels = this.pixels = {are1x1: patchSize === 1}\r\n    // pixels.ctx = pixels.are1x1 ? ctx : util.createCtx(numX, numY)\r\n    this.pixels = {\r\n      ctx: util.createCtx(numX, numY)\r\n    };\r\n    this.setImageData();\r\n  }\r\n  // Create the pixels object used by `setPixels` and `installColors`\r\n  setImageData () {\r\n    const pixels = this.pixels;\r\n    pixels.imageData = util.ctxImageData(pixels.ctx);\r\n    pixels.data8 = pixels.imageData.data;\r\n    pixels.data = new Uint32Array(pixels.data8.buffer);\r\n  }\r\n\r\n  setDefault (name, value) {\r\n    if (name === 'color') {\r\n      this.ask(p => { p.setColor(value); });\r\n      util.logOnce(`patches.setDefault(color, value): color default not supported. Clearing to value`);\r\n    } else {\r\n      super.setDefault(name, value);\r\n    }\r\n  }\r\n  // Get/Set label. REMIND: not implemented.\r\n  // Set removes label if label is null or undefined.\r\n  // Get returns undefined if no label.\r\n  setLabel (patch, label) { // REMIND: does this work for breeds?\r\n    if (label == null) // null or undefined\r\n      delete this.labels[patch.id];\r\n    else\r\n      this.labels[patch.id] = label;\r\n  }\r\n  getLabel (patch) {\r\n    return this.labels[patch.id]\r\n  }\r\n\r\n  // Return the offsets from a patch for its 8 element neighbors.\r\n  // Specialized to be faster than inRect below.\r\n  neighborsOffsets (x, y) {\r\n    const {minX, maxX, minY, maxY, numX} = this.model.world;\r\n    if (x === minX) {\r\n      if (y === minY) return [-numX, -numX + 1, 1]\r\n      if (y === maxY) return [1, numX + 1, numX]\r\n      return [-numX, -numX + 1, 1, numX + 1, numX]\r\n    }\r\n    if (x === maxX) {\r\n      if (y === minY) return [-numX - 1, -numX, -1]\r\n      if (y === maxY) return [numX, numX - 1, -1]\r\n      return [-numX - 1, -numX, numX, numX - 1, -1]\r\n    }\r\n    if (y === minY) return [-numX - 1, -numX, -numX + 1, 1, -1]\r\n    if (y === maxY) return [1, numX + 1, numX, numX - 1, -1]\r\n    return [-numX - 1, -numX, -numX + 1, 1, numX + 1, numX, numX - 1, -1]\r\n  }\r\n  // Return the offsets from a patch for its 4 element neighbors (N,S,E,W)\r\n  neighbors4Offsets (x, y) {\r\n    const numX = this.model.world.numX;\r\n    return this.neighborsOffsets(x, y)\r\n      .filter((n) => Math.abs(n) === 1 || Math.abs(n) === numX) // slightly faster\r\n      // .filter((n) => [1, -1, numX, -numX].indexOf(n) >= 0)\r\n      // .filter((n) => [1, -1, numX, -numX].includes(n)) // slower than indexOf\r\n  }\r\n  // Return my 8 patch neighbors\r\n  neighbors (patch) {\r\n    const {id, x, y} = patch;\r\n    const offsets = this.neighborsOffsets(x, y);\r\n    const as = new AgentArray(offsets.length);\r\n    offsets.forEach((o, i) => { as[i] = this[o + id]; });\r\n    return as\r\n    // offsets.forEach((o, i, a) => { a[i] = this[o + id] })\r\n    // return this.asAgentSet(offsets)\r\n  }\r\n  // Return my 4 patch neighbors\r\n  neighbors4 (patch) {\r\n    const {id, x, y} = patch;\r\n    const offsets = this.neighbors4Offsets(x, y);\r\n    const as = new AgentArray(offsets.length);\r\n    offsets.forEach((o, i) => { as[i] = this[o + id]; });\r\n    return as\r\n  }\r\n\r\n  // Return a random valid int x,y point in patch space\r\n  randomPt () {\r\n    // const {minXcor, maxXcor, minYcor, maxYcor} = this.model.world\r\n    // return [util.randomFloat2(minXcor, maxXcor), util.randomFloat2(minYcor, maxYcor)]\r\n    const {minX, maxX, minY, maxY} = this.model.world;\r\n    return [util.randomInt2(minX, maxX), util.randomInt2(minY, maxY)]\r\n  }\r\n\r\n  installPixels () {\r\n    const pixels = this.pixels;\r\n    pixels.ctx.putImageData(pixels.imageData, 0, 0);\r\n    return pixels\r\n  }\r\n  // REMIND: Three .. need pixels -> texture\r\n  // Draw the patches onto the ctx using the pixel image data colors.\r\n  // draw (ctx = this.model.contexts.patches) {\r\n  //   const {pixels} = this\r\n  //   pixels.ctx.putImageData(pixels.imageData, 0, 0)\r\n  //   if (!pixels.are1x1)\r\n  //     util.fillCtxWithImage(ctx, pixels.ctx.canvas)\r\n  //   for (const i in this.labels) { // `for .. in`: skips sparse array gaps.\r\n  //     const label = this.labels[i]\r\n  //     const {labelOffset: offset, labelColor: color} = this[i]\r\n  //     const [x, y] = this.patchXYToPixelXY(...this.patchIndexToXY(i))\r\n  //     util.ctxDrawText(ctx, label, x + offset[0], y + offset[1], color.getCss())\r\n  //   }\r\n  // }\r\n  // REMIND: No drawing layer yet\r\n  // // Draws, or \"imports\" an image URL into the drawing layer.\r\n  // // The image is scaled to fit the drawing layer.\r\n  // // This is an async function, using es6 Promises.\r\n  // importDrawing (imageSrc) {\r\n  //   util.imagePromise(imageSrc)\r\n  //   .then((img) => this.installDrawing(img))\r\n  // }\r\n  // // Direct install image into the given context, not async.\r\n  // installDrawing (img, ctx = this.model.contexts.drawing) {\r\n  //   util.fillCtxWithImage(ctx, img)\r\n  // }\r\n  importColors (imageSrc) {\r\n    util.imagePromise(imageSrc)\r\n    .then((img) => this.installColors(img));\r\n  }\r\n  // Direct install image into the patch colors, not async.\r\n  installColors (img) {\r\n    util.fillCtxWithImage(this.pixels.ctx, img);\r\n    this.setImageData();\r\n  }\r\n\r\n  // Import/export DataSet to/from patch variable `patchVar`.\r\n  // `useNearest`: true for fast rounding to nearest; false for bi-linear.\r\n  importDataSet (dataSet, patchVar, useNearest = false) {\r\n    if (this.isBreedSet()) { // REMIND: error\r\n      util.warn('Patches: exportDataSet called with breed, using patches');\r\n      this.baseSet.importDataSet(dataSet, patchVar, useNearest);\r\n    }\r\n    const {numX, numY} = this.model.world;\r\n    const dataset = dataSet.resample(numX, numY, useNearest);\r\n    this.ask(p => { p[patchVar] = dataset.data[p.id]; });\r\n    // for (const patch of this)\r\n    //   patch[patchVar] = dataset.data[patch.id]\r\n  }\r\n  exportDataSet (patchVar, Type = Array) {\r\n    if (this.isBreedSet()) {\r\n      util.warn('Patches: exportDataSet called with breed, using patches');\r\n      this.baseSet.exportDataSet(patchVar, Type);\r\n    }\r\n    const {numX, numY} = this.model.world;\r\n    // let data = util.arrayProps(this, patchVar)\r\n    let data = this.props(this, patchVar);\r\n    data = util.convertArray(data, Type);\r\n    return new DataSet(numX, numY, data)\r\n  }\r\n\r\n  // Return true if x,y floats are within patch world.\r\n  // isOnWorld (x, y) {\r\n  //   const {minXcor, maxXcor, minYcor, maxYcor} = this.model.world\r\n  //   return (minXcor <= x) && (x <= maxXcor) && (minYcor <= y) && (y <= maxYcor)\r\n  // }\r\n  // Return the patch id/index given valid integer x,y in patch coords\r\n  patchIndex (x, y) {\r\n    const {minX, maxY, numX} = this.model.world;\r\n    return (x - minX) + (numX * (maxY - y))\r\n  }\r\n  // patchXYToIndex (x, y) {\r\n  //   const {minX, maxY, numX} = this.model.world\r\n  //   return (x - minX) + (numX * (maxY - y))\r\n  // }\r\n  // // Return the patch x,y patch coords given a valid patches id/index\r\n  // patchIndexToXY (ix) {\r\n  //   const {minX, maxY, numX} = this.model.world\r\n  //   return [(ix % numX) + minX, maxY - Math.floor(ix / numX)]\r\n  // }\r\n  // // Convert to/from pixel coords & patch coords\r\n  // pixelXYToPatchXY (x, y) {\r\n  //   const {patchSize, minXcor, maxYcor} = this.model.world\r\n  //   return [minXcor + (x / patchSize), maxYcor - (y / patchSize)]\r\n  // }\r\n  // patchXYToPixelXY (x, y) {\r\n  //   const {patchSize, minXcor, maxYcor} = this.model.world\r\n  //   return [(x - minXcor) * patchSize, (maxYcor - y) * patchSize]\r\n  // }\r\n\r\n  // Utils for NetLogo patch location methods.\r\n  // All return `undefined` if not onworld.\r\n  // Note that foo == null checks for both undefined and null (== vs ===)\r\n  // and is considered an OK practice.\r\n\r\n  // Return patch at x,y float values according to topology.\r\n  // Return undefined if off-world\r\n  patch (x, y) {\r\n    if (!this.model.world.isOnWorld(x, y)) return undefined\r\n    const intX = x === this.model.world.maxXcor\r\n      ? this.model.world.maxX : Math.round(x); // handle n.5 round up to n + 1\r\n    const intY = y === this.model.world.maxYcor\r\n      ? this.model.world.maxY : Math.round(y);\r\n    return this.patchXY(intX, intY)\r\n  }\r\n  // Return the patch at x,y where both are valid integer patch coordinates.\r\n  patchXY (x, y) { return this[this.patchIndex(x, y)] }\r\n\r\n  // Patches in rectangle dx, dy from p, dx, dy integers.\r\n  // Both dx & dy are half width/height of rect\r\n  patchRect (p, dx, dy = dx, meToo = true) {\r\n    // Return cached rect if one exists.\r\n    // if (p.pRect && p.pRect.length === dx * dy) return p.pRect\r\n    if (p.rectCache) {\r\n      const index = this.cacheIndex(dx, dy, meToo);\r\n      const rect = p.rectCache[index];\r\n      // const rect = p.rectCache[this.cacheIndex(dx, dy, meToo)]\r\n      if (rect) return rect\r\n    }\r\n    const rect = new AgentArray();\r\n    let {minX, maxX, minY, maxY} = this.model.world;\r\n    minX = Math.max(minX, p.x - dx);\r\n    maxX = Math.min(maxX, p.x + dx);\r\n    minY = Math.max(minY, p.y - dy);\r\n    maxY = Math.min(maxY, p.y + dy);\r\n    for (let y = minY; y <= maxY; y++) {\r\n      for (let x = minX; x <= maxX; x++) {\r\n        const pnext = this.patchXY(x, y);\r\n        if (p !== pnext || meToo) rect.push(pnext);\r\n      }\r\n    }\r\n    return rect\r\n  }\r\n\r\n  // Performance: create a cached rect of this size in sparse array.\r\n  // Index of cached rect is dx * dy + meToo ? 0 : -1.\r\n  // This works for edge rects that are not that full size.\r\n  // patchRect will use this if matches dx, dy, meToo.\r\n  cacheIndex (dx, dy = dx, meToo = true) {\r\n    return (2 * dx + 1) * (2 * dy + 1) + (meToo ? 0 : -1)\r\n  }\r\n  cacheRect (dx, dy = dx, meToo = true, clear = true) {\r\n    const index = this.cacheIndex(dx, dy, meToo);\r\n    this.ask(p => {\r\n      if (!p.rectCache || clear) p.rectCache = [];\r\n      const rect = this.inRect(p, dx, dy, meToo);\r\n      p.rectCache[index] = rect;\r\n    });\r\n  }\r\n\r\n// Return patches within the patch rect, default is square & meToo\r\n  // inRect (patch, dx, dy = dx, meToo = true) {\r\n  //   return this.inRect(patch, dx, dy, meToo)\r\n  // }\r\n  // Patches in circle radius (integer) from patch\r\n  // inRadius (patch, radius, meToo = true) {\r\n  //   const rSq = radius * radius\r\n  //   const result = new AgentArray()\r\n  //   const sqDistance = util.sqDistance // 10% faster\r\n  //   const pRect = this.inRect(patch, radius, radius, meToo)\r\n  //   for (let i = 0; i < pRect.length; i++) {\r\n  //     const p = pRect[i]\r\n  //     if (sqDistance(patch.x, patch.y, p.x, p.y) <= rSq) result.push(p)\r\n  //   }\r\n  //   return result\r\n  // }\r\n  inRect (patch, dx, dy = dx, meToo = true) {\r\n    const pRect = this.patchRect(patch, dx, dy, meToo);\r\n    if (this.isBaseSet()) return pRect\r\n    return pRect.withBreed(this)\r\n  }\r\n  inRadius (patch, radius, meToo = true) {\r\n    const pRect = this.inRect(patch, radius, radius, meToo);\r\n    return pRect.inRadius(patch, radius, meToo)\r\n  }\r\n  // Patches in cone from p in direction `angle`, with `coneAngle` and `radius`\r\n  inCone (patch, radius, coneAngle, direction, meToo = true) {\r\n    const pRect = this.inRect(patch, radius, radius, meToo);\r\n    return pRect.inCone(patch, radius, coneAngle, direction, meToo)\r\n\r\n    // const result = new AgentArray()\r\n    // for (let i = 0; i < pRect.length; i++) {\r\n    //   const p = pRect[i]\r\n    //   const isIn = util.inCone(p.x, p.y, radius, coneAngle, direction, patch.x, patch.y)\r\n    //   if (isIn && (patch !== p || meToo)) result.push(p)\r\n    // }\r\n    // return result\r\n  }\r\n\r\n  // Return patch at distance and angle from obj's (patch or turtle)\r\n  // x, y (floats). If off world, return undefined.\r\n  // To use heading: patchAtDirectionAndDistance(obj, util.angle(heading), distance)\r\n  // Does not take into account the angle of the obj .. turtle.theta for example.\r\n  patchAtDirectionAndDistance (obj, angle, distance) {\r\n    let {x, y} = obj;\r\n    x = x + distance * Math.cos(angle);\r\n    y = y + distance * Math.sin(angle);\r\n    return this.patch(x, y)\r\n  }\r\n  // patchLeftAndAhead (dTheta, distance) {\r\n  //   return this.patchAtDirectionAndDistance(dTheta, distance)\r\n  // }\r\n  // patchRightAndAhead (dTheta, distance) {\r\n  //   return this.patchAtDirectionAndDistance(-dTheta, distance)\r\n  // }\r\n\r\n  // Diffuse the value of patch variable `p.v` by distributing `rate` percent\r\n  // of each patch's value of `v` to its neighbors.\r\n  // If a color map is given, scale the patch color via variable's value\r\n  // If the patch has less than 4/8 neighbors, return the extra to the patch.\r\n  diffuse (v, rate, colorMap = null, min = 0, max = 1) {\r\n    this.diffuseN(8, v, rate, colorMap, min, max);\r\n  }\r\n  diffuse4 (v, rate, colorMap = null, min = 0, max = 1) {\r\n    this.diffuseN(4, v, rate, colorMap, min, max);\r\n  }\r\n  diffuseN (n, v, rate, colorMap = null, min = 0, max = 1) {\r\n    // Note: for-of loops removed: chrome can't optimize them\r\n    // test/apps/patches.js 22fps -> 60fps\r\n    // zero temp variable if not yet set\r\n    if (this[0]._diffuseNext === undefined)\r\n      // for (const p of this) p._diffuseNext = 0\r\n      for (let i = 0; i < this.length; i++) this[i]._diffuseNext = 0;\r\n\r\n    // pass 1: calculate contribution of all patches to themselves and neighbors\r\n    // for (const p of this) {\r\n    for (let i = 0; i < this.length; i++) {\r\n      const p = this[i];\r\n      const dv = p[v] * rate;\r\n      const dvn = dv / n;\r\n      const neighbors = (n === 8) ? p.neighbors : p.neighbors4;\r\n      const nn = neighbors.length;\r\n      p._diffuseNext += p[v] - dv + (n - nn) * dvn;\r\n      // for (const n of neighbors) n._diffuseNext += dvn\r\n      for (let i = 0; i < neighbors.length; i++) neighbors[i]._diffuseNext += dvn;\r\n    }\r\n    // pass 2: set new value for all patches, zero temp,\r\n    // modify color if colorMap given\r\n    // for (const p of this) {\r\n    for (let i = 0; i < this.length; i++) {\r\n      const p = this[i];\r\n      p[v] = p._diffuseNext;\r\n      p._diffuseNext = 0;\r\n      if (colorMap)\r\n        p.setColor(colorMap.scaleColor(p[v], min, max));\r\n    }\r\n  }\r\n}\r\n\r\n// Class Patch instances represent a rectangle on a grid.  They hold variables\r\n// that are in the patches the turtles live on.  The set of all patches\r\n// is the world on which the turtles live and the model runs.\r\n\r\n// Flyweight object creation:\r\n// Objects within AgentSets use \"prototypal inheritance\" via Object.create().\r\n// Here, the Patch class is given to Patches for use creating Proto objects\r\n// (new Patch(agentSet)), but only once per model/breed.\r\n// The flyweight Patch objects are created via Object.create(protoObject),\r\n// This lets the new Patch(agentset) obhect be \"defaults\".\r\nclass Patch {\r\n  static defaultVariables () { // Core variables for patches. Not 'own' variables.\r\n    return {\r\n      // id: null,             // unique id, promoted by agentset's add() method\r\n      // agentSet: null,       // my agentset/breed\r\n      // model: null,          // my model\r\n      // patches: null,        // my patches/baseSet, set by ctor\r\n\r\n      turtles: undefined,      // the turtles on me. Laxy evalued, see turtlesHere below\r\n      labelOffset: [0, 0],  // text pixel offset from the patch center\r\n      labelColor: Color.color(0, 0, 0) // the label color\r\n      // Getter variables: label, color, x, y, neighbors, neighbors4\r\n    }\r\n  }\r\n  // Initialize a Patch given its Patches AgentSet.\r\n  constructor () {\r\n    Object.assign(this, Patch.defaultVariables());\r\n  }\r\n  // Getter for x,y derived from patch id, thus no setter.\r\n  get x () {\r\n    return (this.id % this.model.world.numX) + this.model.world.minX\r\n  }\r\n  get y () {\r\n    return this.model.world.maxY - Math.floor(this.id / this.model.world.numX)\r\n  }\r\n  isOnEdge () {\r\n    const {x, y, model} = this;\r\n    const {minX, maxX, minY, maxY} = model.world;\r\n    return x === minX || x === maxX || y === minY || y === maxY\r\n  }\r\n\r\n  // Getter for neighbors of this patch.\r\n  // Uses lazy evaluation to promote neighbors to instance variables.\r\n  // To avoid promotion, use `patches.neighbors(this)`.\r\n  // Promotion makes getters accessed only once.\r\n  // defineProperty required: can't set this.neighbors when getter defined.\r\n  get neighbors () { // lazy promote neighbors from getter to instance prop.\r\n    const n = this.patches.neighbors(this);\r\n    Object.defineProperty(this, 'neighbors', {value: n, enumerable: true});\r\n    return n\r\n  }\r\n  get neighbors4 () {\r\n    const n = this.patches.neighbors4(this);\r\n    Object.defineProperty(this, 'neighbors4', {value: n, enumerable: true});\r\n    return n\r\n  }\r\n  // Similar for caching turtles here\r\n  // get turtles () {\r\n  //   Object.defineProperty(this, 'turtles', {value: [], enumerable: true})\r\n  //   return this.turtles\r\n  // }\r\n\r\n  // Manage colors by directly setting pixels in Patches pixels object.\r\n  // With getter/setters, slight performance hit but worth it!\r\n  setColor (color) {\r\n    this.patches.pixels.data[this.id] = Color.toColor(color).getPixel();\r\n  }\r\n  // Optimization: If shared color provided, sharedColor is modified and\r\n  // returned. Otherwise new color returned.\r\n  getColor (sharedColor = null) {\r\n    const pixel = this.patches.pixels.data[this.id];\r\n    if (sharedColor) {\r\n      sharedColor.pixel = pixel;\r\n      return sharedColor\r\n    }\r\n    return Color.toColor(pixel)\r\n  }\r\n  get color () { return this.getColor() }\r\n  set color (color) { this.setColor(color); }\r\n\r\n  // Set label. Erase label via setting to undefined.\r\n  setLabel (label) {\r\n    this.patches.setLabel(this, label);\r\n  }\r\n  getLabel () {\r\n    this.patches.getLabel(this);\r\n  }\r\n  get label () { return this.getLabel() }\r\n  set label (label) { return this.setLabel(label) }\r\n\r\n  // Promote this.turtles on first call to turtlesHere.\r\n  turtlesHere () {\r\n    if (this.turtles == null) {\r\n      // this.patches.forEach((patch) => { patch.turtles = [] })\r\n      // this.model.turtles.forEach((turtle) => {\r\n      //   turtle.patch.turtles.push(this)\r\n      // })\r\n      this.patches.ask(p => { p.turtles = []; });\r\n      this.model.turtles.ask(t => { t.patch.turtles.push(t); });\r\n\r\n      // for (const patch of this.patches)\r\n      //   patch.turtles = []\r\n      // for (const turtle of this.model.turtles)\r\n      //   turtle.patch.turtles.push(turtle)\r\n    }\r\n    return this.turtles\r\n  }\r\n  // Returns above but returning only turtles of this breed.\r\n  breedsHere (breed) {\r\n    const turtles = this.turtlesHere();\r\n    return turtles.withBreed(breed)\r\n    // return turtles.filter((turtle) => turtle.agentSet === breed)\r\n  }\r\n\r\n  // 6 methods in both Patch & Turtle modules\r\n  // Distance from me to x, y. REMIND: No off-world test done\r\n  distanceXY (x, y) { return util.distance(this.x, this.y, x, y) }\r\n  // Return distance from me to object having an x,y pair (turtle, patch, ...)\r\n  distance (agent) { return this.distanceXY(agent.x, agent.y) }\r\n  // Return angle towards agent/x,y\r\n  // Use util.heading to convert to heading\r\n  towards (agent) { return this.towardsXY(agent.x, agent.y) }\r\n  towardsXY (x, y) { return util.radiansToward(this.x, this.y, x, y) }\r\n  // Return patch w/ given parameters. Return undefined if off-world.\r\n  // Return patch dx, dy from my position.\r\n  patchAt (dx, dy) { return this.patches.patch(this.x + dx, this.y + dy) }\r\n  patchAtDirectionAndDistance (direction, distance) {\r\n    return this.patches.patchAtDirectionAndDistance(this, direction, distance)\r\n  }\r\n\r\n  // Use the agentset versions so that breeds can considered.\r\n  // Otherwise we'd have to use the patch breed just to be consistant.\r\n  // inRect (patch, dx, dy = dx, meToo = true) {\r\n  //   return this.patches.inRect(this, dx, dy, meToo)\r\n  // }\r\n  // inRadius (radius, meToo = true) { // radius is integer\r\n  //   return this.patches.inRadius(this, radius, meToo)\r\n  // }\r\n  // inCone (radius, coneAngle, direction, meToo = true) {\r\n  //   return this.patches.inRadius(this, radius, coneAngle, direction, meToo)\r\n  // }\r\n\r\n  // Breed get/set mathods and getter/setter versions.\r\n  // setBreed (breed) { breed.setBreed(this) }\r\n  // get breed () { return this.agentSet }\r\n  // isBreed (name) { return this.agentSet.name === name }\r\n\r\n  sprout (num = 1, breed = this.model.turtles, initFcn = (turtle) => {}) {\r\n    return breed.create(num, (turtle) => {\r\n      turtle.setxy(this.x, this.y);\r\n      initFcn(turtle);\r\n    })\r\n  }\r\n}\r\n\r\n// Turtles are the world other agentsets live on. They create a coord system\r\n// from Model's world values: size, minX, maxX, minY, maxY\r\nclass Turtles extends AgentSet {\r\n  // constructor (model, AgentClass, name) {\r\n  //   // // AgentSet sets these variables:\r\n  //   // // model, name, baseSet, world: model.world & agentProto: new AgentClass\r\n  //   super(model, AgentClass, name)\r\n  //   // // Skip if an basic Array ctor or a breedSet. See AgentSet comments.\r\n  //   //\r\n  //   // // if (typeof model === 'number' || this.isBreedSet()) return\r\n  //   //\r\n  //   // // this.model.world = model.world\r\n  //   // // this.labels = [] // sparse array for labels\r\n  //   // // this.spriteSheet = new SpriteSheet()\r\n  //   // // this.colorMap = ColorMap.Basic16\r\n  // }\r\n  create (num = 1, initFcn = (turtle) => {}) {\r\n    return util.repeat(num, (i, a) => {\r\n      const turtle = this.addAgent();\r\n      turtle.theta = util.randomFloat(Math.PI * 2);\r\n      if (this.renderer.useSprites) // fake sprite for initialization\r\n        turtle.sprite =\r\n          {shape: turtle.shapeFcn, color: this.randomColor(), needsUpdate: true};\r\n      initFcn(turtle);\r\n      a.push(turtle);\r\n    })\r\n  }\r\n  // clear () {\r\n  //   while (this.any()) this.last.die() // die a turtle method\r\n  // }\r\n\r\n  // Return a random valid float x,y point in turtle coord space.\r\n  randomPt () {\r\n    const {minXcor, maxXcor, minYcor, maxYcor} = this.model.world;\r\n    return [util.randomFloat2(minXcor, maxXcor), util.randomFloat2(minYcor, maxYcor)]\r\n    // const {minX, maxX, minY, maxY} = this.model.world\r\n    // return [util.randomInt2(minX, maxX), util.randomInt2(minY, maxY)]\r\n  }\r\n\r\n  // Return an array of this breed within the array of patchs\r\n  inPatches (patches) {\r\n    let array = new AgentArray(); // []\r\n    for (const p of patches) array.push(...p.turtlesHere());\r\n    // REMIND: can't use withBreed .. its not an AgentSet. Move to AgentArray\r\n    if (this.isBreedSet()) array = array.filter((a) => a.agentSet === this);\r\n    return array\r\n  }\r\n  // Return an array of turtles/breeds within the patchRect, dx/y integers\r\n  // Note: will return turtle too. Also slightly inaccurate due to being\r\n  // patch based, not turtle based.\r\n  inPatchRect (turtle, dx, dy = dx, meToo = false) {\r\n    // meToo: true for patches, could have several turtles on patch\r\n    const patches = this.model.patches.inRect(turtle.patch, dx, dy, true);\r\n    const agents = this.inPatches(patches);\r\n    if (!meToo) util.removeItem(agents, turtle); // don't use agents.removeAgent: breeds\r\n    return agents // this.inPatches(patches)\r\n  }\r\n  // Return the members of this agentset that are within radius distance\r\n  // from me, using a patch rect.\r\n  inRadius (turtle, radius, meToo = false) {\r\n    const agents = this.inPatchRect(turtle, radius, radius, true);\r\n    return agents.inRadius(turtle, radius, meToo)\r\n  }\r\n  inCone (turtle, radius, coneAngle, meToo = false) {\r\n    const agents = this.inPatchRect(turtle, radius, radius, true);\r\n    return agents.inCone(turtle, radius, coneAngle, turtle.theta, meToo)\r\n  }\r\n\r\n  // Circle Layout: position the turtles in this breed in an equally\r\n  // spaced circle of the given radius, with the initial turtle\r\n  // at the given start angle (default to pi/2 or \"up\") and in the\r\n  // +1 or -1 direction (counter clockwise or clockwise)\r\n  // defaulting to -1 (clockwise).\r\n  layoutCircle (radius, center = [0, 0], startAngle = Math.PI / 2, direction = -1) {\r\n    const dTheta = 2 * Math.PI / this.length;\r\n    const [x0, y0] = center;\r\n    this.ask((turtle, i) => {\r\n      turtle.setxy(x0, y0);\r\n      turtle.theta = startAngle + (direction * dTheta * i);\r\n      turtle.forward(radius);\r\n    });\r\n  }\r\n}\r\n\r\n// Flyweight object creation, see Patch/Patches.\r\n\r\n// Class Turtle instances represent the dynamic, behavioral element of modeling.\r\n// Each turtle knows the patch it is on, and interacts with that and other\r\n// patches, as well as other turtles.\r\n\r\nclass Turtle {\r\n  static defaultVariables () {\r\n    return { // Core variables for turtles. Not 'own' variables.\r\n      x: 0,             // x, y, z in patchSize units.\r\n      y: 0,             // Use turtles.setDefault('z', num) to change default height\r\n      z: 0,\r\n      theta: 0,         // my euclidean direction, radians from x axis, counter-clockwise\r\n      size: 1,          // size in patches, default to one patch\r\n\r\n      // patch: null,   // the patch I'm on .. uses getter below\r\n      // links: null,   // the links having me as an end point .. lazy promoted below\r\n      atEdge: 'clamp',  // What to do if I wander off world. Can be 'clamp', 'wrap'\r\n                        // 'bounce', or a function, see handleEdge() method\r\n      sprite: null,\r\n      typedColor: null,\r\n      typedStrokeColor: null,\r\n      shapeFcn: `default`\r\n\r\n      // spriteFcn: 'default',\r\n      // spriteColor: Color.color(255, 0, 0),\r\n\r\n      // labelOffset: [0, 0],  // text pixel offset from the turtle center\r\n      // labelColor: Color.color(0, 0, 0) // the label color\r\n    }\r\n  }\r\n  // Initialize a Turtle given its Turtles AgentSet.\r\n  constructor () {\r\n    Object.assign(this, Turtle.defaultVariables());\r\n  }\r\n  die () {\r\n    this.agentSet.removeAgent(this); // remove me from my baseSet and breed\r\n    if (this.hasOwnProperty('links')) // don't promote links\r\n      while (this.links.length > 0) this.links[0].die();\r\n    if (this.patch.turtles != null)\r\n      util.removeItem(this.patch.turtles, this);\r\n  }\r\n  // // Breed get/set mathods.\r\n  // setBreed (breed) { breed.setBreed(this) }\r\n  // get breed () { return this.agentSet }\r\n\r\n  // Factory: create num new turtles at this turtle's location. The optional init\r\n  // proc is called on the new turtle after inserting in its agentSet.\r\n  hatch (num = 1, agentSet = this.agentSet, init = (turtle) => {}) {\r\n    return agentSet.create(num, (turtle) => {\r\n      turtle.setxy(this.x, this.y);\r\n      // turtle.color = this.color // REMIND: sprite vs color\r\n      // hatched turtle inherits parents' ownVariables\r\n      for (const key of agentSet.ownVariables)\r\n        if (turtle[key] == null) turtle[key] = this[key];\r\n      init(turtle);\r\n    })\r\n  }\r\n  // Getter for links for this turtle. REMIND: use new AgentSet(0)?\r\n  // Uses lazy evaluation to promote links to instance variables.\r\n  // REMIND: Let links create the array as needed, less \"tricky\"\r\n  get links () { // lazy promote links from getter to instance prop.\r\n    Object.defineProperty(this, 'links', {value: [], enumerable: true});\r\n    return this.links\r\n  }\r\n  // Getter for the patchs and the patch I'm on. Return null if off-world.\r\n  get patch () { return this.model.patches.patch(this.x, this.y) }\r\n  // get patches () { return this.model.patches }\r\n\r\n  // Heading vs Euclidean Angles. Direction for clarity when ambiguity.\r\n  get heading () { return util.heading(this.theta) }\r\n  set heading (heading) { this.theta = util.angle(heading); }\r\n  get direction () { return this.theta }\r\n  set direction (theta) { this.theta = theta; }\r\n\r\n  // setColor (anyColor) { this.color = Color.toColor(anyColor) }\r\n  // getColor () {\r\n  //   if (this.color) return\r\n  //   return this.color || this.sprite\r\n  // }\r\n\r\n  // Create my sprite via shape: sprite, fcn, string, or image/canvas\r\n  setSprite (shape = this.shape, color = this.color, strokeColor = this.strokeColor) {\r\n    if (shape.sheet) { this.sprite = shape; return } // src is a sprite\r\n    const ss = this.model.spriteSheet;\r\n    color = color || this.turtles.randomColor();\r\n    this.sprite = ss.newSprite(shape, color, strokeColor);\r\n  }\r\n  setSize (size) { this.size = size; } // * this.model.world.patchSize }\r\n\r\n  setColor (color) {\r\n    // if (this.turtles.settingDefault(this)) console.log(`setting default color ${color}`)\r\n    // if (!this.id) console.log(`setting default color ${color}`)\r\n    const typedColor = Color.toColor(color); // Convert to Color.color\r\n    const fixedColor = this.turtles.renderer.fixedColor; // Model set to Color.color\r\n    if (fixedColor && !typedColor.equals(fixedColor)) {\r\n      util.warn(`turtle.setColor: fixedColor != color ${fixedColor.toString()}`);\r\n    // } else if (this.sprite && !settingDefault) {\r\n    } else if (this.sprite) { // default sprite should always be null\r\n      this.sprite.color = typedColor;\r\n      this.sprite.needsUpdate = true;\r\n    } else { // will set default color or instance color (if not fixed etc)\r\n      this.typedColor = typedColor;\r\n    }\r\n  }\r\n  getColor () { return this.sprite ? this.sprite.color : this.typedColor }\r\n  set color (color) { this.setColor(color); }\r\n  get color () { return this.getColor() }\r\n\r\n  setStrokeColor (color) {\r\n    const typedColor = Color.toColor(color); // Convert to Color.color\r\n    const fixedColor = this.turtles.renderer.fixedColor; // Model set to Color.color\r\n    if (fixedColor) {\r\n      util.warn(`turtle.setStrokeColor: fixedColor ${fixedColor.toString()}`);\r\n    } else if (this.sprite) { // default sprite should always be null\r\n      this.sprite.strokeColor = typedColor;\r\n      this.sprite.needsUpdate = true;\r\n    } else { // will set default color or instance color\r\n      this.typedStrokeColor = typedColor;\r\n    }\r\n  }\r\n  getStrokeColor () {\r\n    return this.sprite ? this.sprite.strokeColor : this.typedStrokeColor\r\n  }\r\n  set strokdColor (color) { this.setStrokeColor(color); }\r\n  get strokdColor () { return this.getStrokeColor() }\r\n\r\n  setShape (shape) {\r\n    const fixedShape = this.turtles.renderer.fixedShape;\r\n    if (fixedShape && fixedShape !== shape) {\r\n      util.warn(`turtle.setShape: fixedShape ${fixedShape}`);\r\n    } else if (this.sprite) {\r\n      this.sprite.shape = shape;\r\n      this.sprite.needsUpdate = true;\r\n    } else {\r\n      this.shapeFcn = shape;\r\n    }\r\n  }\r\n  getShape () { return this.sprite ? this.sprite.shape : this.shapeFcn }\r\n  set shape (shape) { this.setShape(shape); }\r\n  get shape () { return this.getShape() }\r\n\r\n  // setDrawSprite (fcn, color, color2) {\r\n  //   this.sprite = this.model.spriteSheet.addDrawing(fcn, color)\r\n  // }\r\n\r\n  // Set x, y position. If z given, override default z.\r\n  // Call handleEdge(x, y) if x, y off-world.\r\n  setxy (x, y, z = null) {\r\n    const p0 = this.patch;\r\n    if (z) this.z = z; // don't promote z if null, use default z instead.\r\n    if (this.model.world.isOnWorld(x, y)) {\r\n      this.x = x;\r\n      this.y = y;\r\n    } else {\r\n      this.handleEdge(x, y);\r\n      // const {minXcor, maxXcor, minYcor, maxYcor} = this.model.world\r\n      // if (this.wrap) {\r\n      //   this.x = util.wrap(x, minXcor, maxXcor)\r\n      //   this.y = util.wrap(y, minYcor, maxYcor)\r\n      // } else {\r\n      //   this.x = util.clamp(x, minXcor, maxXcor)\r\n      //   this.y = util.clamp(y, minYcor, maxYcor)\r\n      // }\r\n    }\r\n    const p = this.patch;\r\n    if (p.turtles != null && p !== p0) {\r\n      util.removeItem(p0.turtles, this);\r\n      p.turtles.push(this);\r\n    }\r\n  }\r\n  // Handle turtle if x,y off-world\r\n  handleEdge (x, y) {\r\n    if (util.isString(this.atEdge)) {\r\n      const {minXcor, maxXcor, minYcor, maxYcor} = this.model.world;\r\n      if (this.atEdge === 'wrap') {\r\n        this.x = util.wrap(x, minXcor, maxXcor);\r\n        this.y = util.wrap(y, minYcor, maxYcor);\r\n      } else if (this.atEdge === 'clamp' || this.atEdge === 'bounce') {\r\n        this.x = util.clamp(x, minXcor, maxXcor);\r\n        this.y = util.clamp(y, minYcor, maxYcor);\r\n        if (this.atEdge === 'bounce') {\r\n          if (this.x === minXcor || this.x === maxXcor)\r\n            this.theta = Math.PI - this.theta;\r\n          else\r\n            this.theta = -this.theta;\r\n        }\r\n      } else {\r\n        throw Error(`turtle.handleEdge: bad atEdge: ${this.atEdge}`)\r\n      }\r\n    } else {\r\n      this.atEdge(this);\r\n    }\r\n  }\r\n  // Place the turtle at the given patch/turtle location\r\n  moveTo (agent) { this.setxy(agent.x, agent.y); }\r\n  // Move forward (along theta) d units (patch coords),\r\n  forward (d) {\r\n    this.setxy(this.x + d * Math.cos(this.theta), this.y + d * Math.sin(this.theta));\r\n  }\r\n  // Change current direction by rad radians which can be + (left) or - (right).\r\n  rotate (rad) { this.theta = util.mod(this.theta + rad, Math.PI * 2); }\r\n  right (rad) { this.rotate(-rad); }\r\n  left (rad) { this.rotate(rad); }\r\n\r\n  // Set my direction towards turtle/patch or x,y.\r\n  // \"direction\" is euclidean radians.\r\n  face (agent) { this.theta = this.towards(agent); }\r\n  faceXY (x, y) { this.theta = this.towardsXY(x, y); }\r\n\r\n  // Return the patch ahead of this turtle by distance (patchSize units).\r\n  // Return undefined if off-world.\r\n  patchAhead (distance) {\r\n    return this.patchAtDirectionAndDistance(this.theta, distance)\r\n  }\r\n  // Use patchAhead to determine if this turtle can move forward by distance.\r\n  canMove (distance) { return this.patchAhead(distance) != null } // null / undefined\r\n  patchLeftAndAhead (angle, distance) {\r\n    return this.patchAtDirectionAndDistance(angle + this.theta, distance)\r\n  }\r\n  patchRightAndAhead (angle, distance) {\r\n    return this.patchAtDirectionAndDistance(angle - this.theta, distance)\r\n  }\r\n\r\n  // 6 methods in both Patch & Turtle modules\r\n  // Distance from me to x, y. REMIND: No off-world test done\r\n  distanceXY (x, y) { return util.distance(this.x, this.y, x, y) }\r\n  // Return distance from me to object having an x,y pair (turtle, patch, ...)\r\n  // distance (agent) { this.distanceXY(agent.x, agent.y) }\r\n  distance (agent) { return util.distance(this.x, this.y, agent.x, agent.y) }\r\n  // Return angle towards agent/x,y\r\n  // Use util.heading to convert to heading\r\n  towards (agent) { return this.towardsXY(agent.x, agent.y) }\r\n  towardsXY (x, y) { return util.radiansToward(this.x, this.y, x, y) }\r\n  // Return patch w/ given parameters. Return undefined if off-world.\r\n  // Return patch dx, dy from my position.\r\n  patchAt (dx, dy) { return this.model.patches.patch(this.x + dx, this.y + dy) }\r\n  // Note: angle is absolute, w/o regard to existing angle of turtle.\r\n  // Use Left/Right versions below\r\n  patchAtDirectionAndDistance (direction, distance) {\r\n    return this.model.patches.patchAtDirectionAndDistance(this, direction, distance)\r\n  }\r\n\r\n  // // Return turtles/breeds within radius from me\r\n  // inRadius (radius, meToo = false) {\r\n  //   return this.agentSet.inRadius(this, radius, meToo)\r\n  // }\r\n  // // Return turtles/breeds within cone from me\r\n  // // Note: agentSet rather than turtles to allow for breeds\r\n  // inCone (radius, coneAngle, meToo = false) {\r\n  //   return this.agentSet.inCone(this, radius, coneAngle, this.theta, meToo)\r\n  // }\r\n\r\n  // Link methods. Note: this.links returns all links linked to me.\r\n  // See links getter above.\r\n\r\n  // Return other end of link from me. Link must include me!\r\n  otherEnd (l) { return l.end0 === this ? l.end1 : l.end0 }\r\n  // Return all turtles linked to me\r\n  linkNeighbors () { return this.links.map((l) => this.otherEnd(l)) }\r\n}\r\n\r\n// Sprites are images/drawings within a sprite-sheet.\r\nclass SpriteSheet {\r\n  constructor (spriteSize = 64, spritesPerRow = 16, usePowerOf2 = true) {\r\n    Object.assign(this, {spriteSize, cols: spritesPerRow, usePowerOf2});\r\n    this.rows = 1;\r\n    this.nextCol = 0;\r\n    this.nextRow = 0;\r\n    this.sprites = {};\r\n    this.paths = Object.assign({}, paths); // installPaths()\r\n    if (usePowerOf2) this.checkPowerOf2();\r\n    this.ctx = util.createCtx(this.width, this.height);\r\n    this.texture = null; // THREE use optional\r\n  }\r\n\r\n  // getters for derived values.\r\n  // width & height in pixels\r\n  get width () { return this.spriteSize * this.cols }\r\n  get height () { return this.spriteSize * this.rows }\r\n  // next col, row in pixels\r\n  get nextX () { return this.spriteSize * this.nextCol }\r\n  get nextY () { return this.spriteSize * this.nextRow }\r\n  // id = number of sprites\r\n  get id () { return Object.keys(this.sprites).length }\r\n\r\n  // REMIND: this is a place holder for deleting sheet and it's sprites.\r\n  // Non-trivial.\r\n  clear () {\r\n    Object.assign(this.ctx.canvas, {width: this.width, height: this.spriteSize});\r\n  }\r\n\r\n  // Return a sprite. Create it if not in sprites cache.\r\n  // Src can be: image, canvas, function name, function.\r\n  // If src is a canvas, it must have a src string w/o / or . chars.\r\n  // If src is function or name of path below, colors can be css\r\n  // or Color module's Color object.\r\n  newSprite (src, color, strokeColor) {\r\n    // Normalize color names to Color.color objects\r\n    if (color) color = Color.toColor(color);\r\n    if (strokeColor) strokeColor = Color.toColor(strokeColor);\r\n\r\n    // create a normalized name:\r\n    const name = this.spriteName(src, color, strokeColor);\r\n    // If sprite of ths name already exists, return it.\r\n    if (this.sprites[name]) return this.sprites[name]\r\n\r\n    // Make a new sprite.\r\n    const sprite = util.isImageable(src)\r\n      ? this.addImage(src)\r\n      : this.addDrawing(src, color, strokeColor);\r\n    Object.assign(sprite, {src, color, strokeColor, needsUpdate: false});\r\n\r\n    // Add normalized colors and shape name to new sprite.\r\n    // if (color) {\r\n    //   sprite.color = color\r\n    //   if (strokeColor) sprite.strokeColor = strokeColor\r\n    //   sprite.shape = name.replace(/#.*/, '') // drop #xxxxxx from name\r\n    // }\r\n\r\n    // Add sprite to cache and return it.\r\n    this.sprites[name] = sprite;\r\n    return sprite\r\n  }\r\n\r\n  // Install a new named function in the paths object below.\r\n  // Used to add \"car\", \"thug\", \"spider\" etc drawings.\r\n  installDrawing (fcn, name = fcn.name) { this.paths[name] = fcn; }\r\n\r\n// These are internal, experts only, use newSprite above for normal use.\r\n\r\n  // Make a unique, normalized sprite name. See note on src, colors above.\r\n  // Color names are hex css formats, see newSprite's name transformation.\r\n  spriteName (src, fillColor, strokeColor) {\r\n    let name;\r\n    // If src is an image, construct a name.\r\n    if (util.isImageable(src)) {\r\n      name = src.src;\r\n      name = name.replace(/^.*\\//, ''); // remove path\r\n      name = name.replace(/\\..*/, '.img'); // replace .png/jpg/.. w/ \".img\"\r\n    } else {\r\n      // ditto for draw function or name of function in paths obj below\r\n      name = src.name || src;\r\n      if (!name.endsWith('2')) strokeColor = null;\r\n      name = `${name}${fillColor.css}${strokeColor ? strokeColor.css : ''}`;\r\n    }\r\n    return name\r\n  }\r\n\r\n  // Add an image/canvas to sprite sheet.\r\n  addImage (img) {\r\n    this.checkSheetSize(); // Resize ctx if nextRow === rows\r\n    const [x, y, size] = [this.nextX, this.nextY, this.spriteSize];\r\n    this.ctx.drawImage(img, x, y, size, size);\r\n    const id = this.id; // Object.keys(this.sprites).length\r\n    const {nextRow: row, nextCol: col} = this;\r\n    const sprite = {id, x, y, row, col, size, sheet: this};\r\n    sprite.uvs = this.getUVs(sprite);\r\n    this.incrementRowCol();\r\n    if (this.texture) this.texture.needsUpdate = true;\r\n    return sprite\r\n  }\r\n  // Use above to add a drawing to sprite sheet\r\n  addDrawing (drawFcn, fillColor, strokeColor, useHelpers = true) {\r\n    const img = this.createFcnCanvas(drawFcn, fillColor, strokeColor, useHelpers);\r\n    return this.addImage(img) // return sprite\r\n  }\r\n\r\n  // Resize ctx if too small for next row/col\r\n  checkSheetSize () {\r\n    if (this.nextRow === this.rows) { // this.nextCol should be 0\r\n      this.rows = (this.usePowerOf2) ? this.rows * 2 : this.rows + 1;\r\n      util.resizeCtx(this.ctx, this.width, this.height);\r\n      // Recalculate existing sprite uvs.\r\n      util.forEach(this.sprites, (sprite) => { sprite.uvs = this.getUVs(sprite); });\r\n    }\r\n  }\r\n  // Advance nextCol/Row. Done after checkSheetSize enlarged ctx if needed.\r\n  incrementRowCol () {\r\n    this.nextCol += 1;\r\n    if (this.nextCol < this.cols) return\r\n    this.nextCol = 0;\r\n    this.nextRow += 1;\r\n  }\r\n\r\n  // Create a sprite image. See [Drawing shapes with canvas](https://goo.gl/uBwxMq)\r\n  //\r\n  // The drawFcn args: drawFcn(ctx).\r\n  // The ctx fill & stroke styles are pre-filled w/ fillColor, strokeColor.\r\n  //\r\n  // If useHelpers:\r\n  // - Transform to -1 -> +1 coords\r\n  // - drawFcn is surrounded with ctx beginPath & closePath, fill fcns.\r\n  //\r\n  // If not using helpers, ctx.canvas.width/height is the size of drawing,\r\n  // top/left canvas coordinates.\r\n  createFcnCanvas (drawFcn, fillColor, strokeColor, useHelpers = true) {\r\n    const ctx = util.createCtx(this.spriteSize, this.spriteSize);\r\n    ctx.fillStyle = fillColor.css || fillColor;\r\n    if (strokeColor)\r\n      ctx.strokeStyle = strokeColor.css || strokeColor;\r\n    if (useHelpers) {\r\n      ctx.scale(this.spriteSize / 2, this.spriteSize / 2);\r\n      ctx.translate(1, 1);\r\n      ctx.beginPath();\r\n    }\r\n\r\n    if (util.isString(drawFcn)) {\r\n      this.paths[drawFcn](ctx);\r\n    } else {\r\n      drawFcn(ctx);\r\n    }\r\n\r\n    if (useHelpers) {\r\n      ctx.closePath();\r\n      ctx.fill();\r\n    }\r\n\r\n    const name = drawFcn.name || drawFcn;\r\n    ctx.canvas.src = `${name}${fillColor}`;\r\n    return ctx.canvas\r\n  }\r\n\r\n  // Return standard agentscript quad:\r\n  //      3   2\r\n  //      -----\r\n  //      |  /|\r\n  //      | / |\r\n  //      |/  |\r\n  //      -----\r\n  //      0   1\r\n  // I.e. botLeft, botRight, topRight, topLeft\r\n  // getUVs (sprite) {\r\n  //   const {row, col} = sprite\r\n  //   const {rows, cols} = this\r\n  //   const x0 = col / cols\r\n  //   const y0 = row / rows\r\n  //   const x1 = (col + 1) / cols\r\n  //   const y1 = (row + 1) / rows\r\n  //   // return [[x0, y1], [x1, y1], [x1, y0], [x0, y0]]\r\n  //   return [x0, y1, x1, y1, x1, y0, x0, y0]\r\n  // }\r\n  getUVs (sprite) { // note v's are measured from the bottom.\r\n    const {row, col} = sprite;\r\n    const {rows, cols} = this;\r\n    const u0 = col / cols;\r\n    const v0 = (rows - (row + 1)) / rows;\r\n    const u1 = (col + 1) / cols;\r\n    const v1 = (rows - row) / rows;\r\n    // return [[x0, y1], [x1, y1], [x1, y0], [x0, y0]]\r\n    return [u0, v0, u1, v0, u1, v1, u0, v1]\r\n  }\r\n  // Return uv's object: {topLeft, topRight, botLeft, botRight}\r\n  // getUVsObj (sprite) { // REMIND\r\n  //   const uvs = this.getUVs\r\n  //   return {\r\n  //     botLeft: uvs[0],\r\n  //     botRight: uvs[1],\r\n  //     topRight: uvs[2],\r\n  //     topLeft: uvs[3]\r\n  //   }\r\n  // }\r\n\r\n  checkPowerOf2 () {\r\n    const {width, height} = this;\r\n    if (!(util.isPowerOf2(width) && util.isPowerOf2(height)))\r\n      throw Error(`SpriteSheet non power of 2: ${width}x${height}`)\r\n  }\r\n}\r\n\r\nconst paths = {\r\n  poly (ctx, points) {\r\n    points.forEach((pt, i) => {\r\n      if (i === 0) ctx.moveTo(pt[0], pt[1]);\r\n      else ctx.lineTo(pt[0], pt[1]);\r\n    });\r\n  },\r\n  default (ctx) { this.dart(ctx); },\r\n  arrow (ctx) {\r\n    this.poly(ctx,\r\n      [[1, 0], [0, 1], [0, 0.4], [-1, 0.4], [-1, -0.4], [0, -0.4], [0, -1]]);\r\n  },\r\n  bug (ctx) {\r\n    ctx.strokeStyle = ctx.fillStyle;\r\n    this.bug2(ctx);\r\n  },\r\n  bug2 (ctx) {\r\n    ctx.lineWidth = 0.1;\r\n    this.poly(ctx, [[0.8, 0.45], [0.4, 0], [0.8, -0.45]]);\r\n    ctx.stroke();\r\n    ctx.beginPath();\r\n    ctx.arc(0.24, 0, 0.26, 0, 2 * Math.PI);\r\n    ctx.arc(-0.1, 0, 0.26, 0, 2 * Math.PI);\r\n    ctx.arc(-0.54, 0, 0.4, 0, 2 * Math.PI);\r\n  },\r\n  circle (ctx) { ctx.arc(0, 0, 1, 0, 2 * Math.PI); },\r\n  dart (ctx) { this.poly(ctx, [[1, 0], [-1, 0.8], [-0.5, 0], [-1, -0.8]]); },\r\n  frame (ctx) {\r\n    const inset = 0.4;\r\n    ctx.fillRect(-1, -1, 2, 2);\r\n    ctx.fill();\r\n    ctx.clearRect(-1 + inset, -1 + inset, 2 - (2 * inset), 2 - (2 * inset));\r\n  },\r\n  frame2 (ctx) {\r\n    const inset = 0.4;\r\n    ctx.fillRect(-1, -1, 2, 2);\r\n    ctx.fill();\r\n    ctx.fillStyle = ctx.strokeStyle;\r\n    ctx.fillRect(-1 + inset, -1 + inset, 2 - (2 * inset), 2 - (2 * inset));\r\n  },\r\n  // person (ctx) {\r\n  //   this.poly(ctx, [ [0.3, -0.4], [0.6, 0], [0.25, 0.2], [0.25, -0.1],\r\n  //   [0.2, 0.3], [0.5, 1], [0.1, 1], [0, 0.5],\r\n  //   [-0.1, 1], [-0.5, 1], [-0.2, 0.3], [-0.25, -0.1],\r\n  //   [-0.25, 0.2], [-0.6, 0], [-0.3, -0.4]])\r\n  //   ctx.closePath()\r\n  //   ctx.arc(0, -0.7, 0.3, 0, 2 * Math.PI)\r\n  // },\r\n  person (ctx) {\r\n    ctx.strokeStyle = ctx.fillStyle;\r\n    this.person2(ctx);\r\n  },\r\n  person2 (ctx) {\r\n    this.poly(ctx, [ [0.3, -0.4], [0.6, 0], [0.25, 0.2], [0.25, -0.1],\r\n    [0.2, 0.3], [0.5, 1], [0.1, 1], [0, 0.5],\r\n    [-0.1, 1], [-0.5, 1], [-0.2, 0.3], [-0.25, -0.1],\r\n    [-0.25, 0.2], [-0.6, 0], [-0.3, -0.4]]);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    ctx.beginPath();\r\n    ctx.fillStyle = ctx.strokeStyle;\r\n    ctx.arc(0, -0.7, 0.3, 0, 2 * Math.PI);\r\n  },\r\n  ring (ctx) { // transparent\r\n    const [rOuter, rInner] = [1, 0.6];\r\n    ctx.arc(0, 0, rOuter, 0, 2 * Math.PI, false);\r\n    ctx.lineTo(rInner, 0);\r\n    ctx.arc(0, 0, rInner, 0, 2 * Math.PI, true);\r\n  },\r\n  ring2 (ctx) { // fileStyle is outer color, strokeStyle inner color\r\n    const [rOuter, rInner] = [1, 0.6];\r\n    ctx.arc(0, 0, rOuter, 0, 2 * Math.PI); // x, y, r, ang0, ang1, cclockwise\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    ctx.beginPath();\r\n    ctx.fillStyle = ctx.strokeStyle;\r\n    ctx.arc(0, 0, rInner, 0, 2 * Math.PI); // x, y, r, ang0, ang1, cclockwise\r\n  },\r\n  square (ctx) { ctx.fillRect(-1, -1, 2, 2); },\r\n  triangle (ctx) { this.poly(ctx, [[1, 0], [-1, -0.8], [-1, 0.8]]); }\r\n};\r\n\r\n// Meshes used by the Three.js view module\r\n\r\n// Utility classes meant to be subclassed:\r\n\r\n// ============= BaseMesh =============\r\n// An abstract class for all Meshes. It needs the particular Three.js\r\n// instance to allow for differences in models on the same page.\r\nclass BaseMesh { // static options(): https://goo.gl/sKdxoY\r\n  constructor (view, options = this.constructor.options()) {\r\n    const { scene, model } = view;\r\n    Object.assign(this, { scene, model, view, options });\r\n    this.mesh = null;\r\n    this.name = this.constructor.name;\r\n    this.fixedColor = options.color;\r\n    this.fixedSize = options.pointSize;\r\n    this.fixedShape =\r\n      (this.name === 'PatchesMesh') ? 'Patch'\r\n      : (this.name === 'PointsMesh') ? 'Point'\r\n      : (this.name === 'LinksMesh') ? 'Link' : undefined;\r\n    this.useSprites = this.name.match(/sprites/i) != null;\r\n    // BaseMesh,\r\n    // CanvasMesh,\r\n    // PatchesMesh,\r\n    // QuadSpritesMesh,\r\n    // PointsMesh,\r\n    // LinksMesh\r\n  }\r\n  dispose () {\r\n    if (!this.mesh) return\r\n    if (this.mesh.parent !== this.scene) console.log('mesh parent not scene');\r\n    this.mesh.parent.remove(this.mesh);\r\n    this.mesh.geometry.dispose();\r\n    this.mesh.material.dispose();\r\n    if (this.mesh.material.map) this.mesh.material.map.dispose();\r\n  }\r\n  init () { throw Error('init is abstract, must be overriden') }\r\n  update () { throw Error('update is abstract, must be overriden') }\r\n\r\n  // Utilities\r\n  createQuad (r, z = 0) { // r is radius of xy quad: [-r,+r], z is quad z\r\n    const vertices = [-r, -r, z, r, -r, z, r, r, z, -r, r, z];\r\n    const indices = [0, 1, 2, 0, 2, 3];\r\n    return {vertices, indices}\r\n  }\r\n  get spriteSheetTexture () {\r\n    if (!this.model.spriteSheet.texture) {\r\n      const texture = new THREE.CanvasTexture(this.model.spriteSheet.ctx.canvas);\r\n      this.model.spriteSheet.texture = texture;\r\n    }\r\n    return this.model.spriteSheet.texture\r\n  }\r\n}\r\n\r\n// ============= CanvasMesh =============\r\n\r\nclass CanvasMesh extends BaseMesh {\r\n  init (canvas) {\r\n    if (this.mesh) this.dispose();\r\n    const {textureOptions, z} = this.options;\r\n    Object.assign(this, { canvas, z, textureOptions });\r\n    const {width, height, numX, numY, centerX, centerY} = this.model.world;\r\n\r\n    const texture = new THREE.CanvasTexture(canvas);\r\n    for (const key in textureOptions) {\r\n      texture[key] = THREE[textureOptions[key]];\r\n    }\r\n\r\n    const geometry = new THREE.PlaneGeometry(width, height, numX, numY);\r\n    geometry.translate(centerX, centerY, 0);\r\n\r\n    const material = new THREE.MeshBasicMaterial({\r\n      map: texture,\r\n      shading: THREE.FlatShading,\r\n      side: THREE.DoubleSide,\r\n      transparent: true\r\n    });\r\n\r\n    this.mesh = new THREE.Mesh(geometry, material);\r\n    this.mesh.position.z = z;\r\n    this.scene.add(this.mesh);\r\n  }\r\n  update () {\r\n    // REMIND: have canvas owner set a flag\r\n    this.mesh.material.map.needsUpdate = true;\r\n  }\r\n}\r\n\r\n// Several classes for patches, turtles, links, etc.\r\n\r\n// ============= DrawingMesh =============\r\n\r\n// Drawing meshes are a form of Canvas Mesh\r\n\r\n\r\n// ============= PatchesMesh =============\r\n\r\n// Patch meshes are a form of Canvas Mesh\r\nclass PatchesMesh extends CanvasMesh {\r\n  static options () {\r\n    return {\r\n      textureOptions: {\r\n        minFilter: 'NearestFilter',\r\n        magFilter: 'NearestFilter'\r\n      },\r\n      z: 1.0\r\n    }\r\n  }\r\n  init (patches) { // REMIND: pass in patches instead of canvas\r\n    super.init(patches.pixels.ctx.canvas);\r\n  }\r\n  update (patches) {\r\n    patches.installPixels();\r\n    super.update();\r\n  }\r\n}\r\n\r\n// ============= QuadSpritesMesh =============\r\n\r\nclass QuadSpritesMesh extends BaseMesh {\r\n  static options () {\r\n    return {\r\n      z: 2.0\r\n    }\r\n  }\r\n  constructor (view, options) {\r\n    super(view, options);\r\n    this.unitQuad = this.createQuad(0.5, 0);\r\n  }\r\n  init () {\r\n    if (this.mesh) this.dispose();\r\n    const texture = this.spriteSheetTexture;\r\n\r\n    const vertices = new Float32Array();\r\n    const uvs = new Float32Array();\r\n    const indices = new Uint32Array();\r\n    const geometry = new THREE.BufferGeometry();\r\n    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\r\n    geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\r\n    geometry.setIndex(new THREE.BufferAttribute(indices, 1));\r\n    const material = new THREE.MeshBasicMaterial({\r\n      map: texture, alphaTest: 0.5, side: THREE.DoubleSide});\r\n\r\n    this.mesh = new THREE.Mesh(geometry, material);\r\n    this.mesh.position.z = this.options.z;\r\n    this.scene.add(this.mesh);\r\n  }\r\n  // update takes any array of objects with x,y,z,size,sprite .. position & uvs\r\n  // REMIND: optimize by flags for position/uvs need updates\r\n  update (turtles) {\r\n    const mesh = this.mesh;\r\n    const { vertices, indices } = this.unitQuad;\r\n    const patchSize = this.model.world.patchSize;\r\n    const positionAttrib = mesh.geometry.getAttribute('position');\r\n    const uvAttrib = mesh.geometry.getAttribute('uv');\r\n    const indexAttrib = mesh.geometry.getIndex();\r\n    const positions = new Float32Array(vertices.length * turtles.length);\r\n    const uvs = [];\r\n    const indexes = [];\r\n\r\n    for (let i = 0; i < turtles.length; i++) {\r\n      const turtle = turtles[i];\r\n      if (turtle.sprite.needsUpdate) turtle.setSprite();\r\n      const size = turtle.size; // * patchSize\r\n      const theta = turtle.theta;\r\n      const cos = Math.cos(theta);\r\n      const sin = Math.sin(theta);\r\n      const offset = i * vertices.length;\r\n\r\n      for (let j = 0; j < vertices.length; j = j + 3) {\r\n        const x0 = vertices[j];\r\n        const y0 = vertices[j + 1];\r\n        const x = turtle.x; // * patchSize\r\n        const y = turtle.y; // * patchSize\r\n        positions[j + offset] = (size * (x0 * cos - y0 * sin) + x) * patchSize;\r\n        positions[j + offset + 1] = (size * (x0 * sin + y0 * cos) + y) * patchSize;\r\n        positions[j + offset + 2] = turtle.z * patchSize;\r\n      }\r\n      indexes.push(...indices.map((ix) => ix + (i * 4))); // 4\r\n      uvs.push(...turtle.sprite.uvs);\r\n    }\r\n    positionAttrib.setArray(positions);\r\n    positionAttrib.needsUpdate = true;\r\n    uvAttrib.setArray(new Float32Array(uvs));\r\n    uvAttrib.needsUpdate = true;\r\n    indexAttrib.setArray(new Uint32Array(indexes));\r\n    indexAttrib.needsUpdate = true;\r\n  }\r\n}\r\n\r\n// ============= PointsMesh =============\r\n\r\nclass PointsMesh extends BaseMesh {\r\n  static options () {\r\n    return {\r\n      pointSize: 1,\r\n      color: null,\r\n      z: 2.0\r\n    }\r\n  }\r\n  init () {\r\n    if (this.mesh) this.dispose();\r\n    const pointSize = this.options.pointSize * this.model.world.patchSize;\r\n    const color = this.options.color ? new THREE.Color(...this.options.color) : null;\r\n\r\n    const geometry = new THREE.BufferGeometry();\r\n    geometry.addAttribute('position',\r\n      new THREE.BufferAttribute(new Float32Array(), 3));\r\n    if (color == null)\r\n      geometry.addAttribute('color',\r\n        new THREE.BufferAttribute(new Float32Array(), 3));\r\n\r\n    const material = color\r\n    ? new THREE.PointsMaterial({size: pointSize, color: color})\r\n    : new THREE.PointsMaterial({size: pointSize, vertexColors: THREE.VertexColors});\r\n\r\n    this.mesh = new THREE.Points(geometry, material);\r\n    this.mesh.position.z = this.options.z;\r\n    this.scene.add(this.mesh);\r\n  }\r\n  // update takes any array of objects with x,y,z,color .. position & color\r\n  // If non-null color passed to init, only x,y,z .. position used\r\n  // REMIND: optimize by flags for position/uvs need updates\r\n  update (turtles) {\r\n    const positionAttrib = this.mesh.geometry.getAttribute('position');\r\n    // const positionBuff = positionAttrib.array\r\n    const colorAttrib = this.mesh.geometry.getAttribute('color');\r\n    const vertices = [];\r\n    const colors = colorAttrib == null ? null : [];\r\n    const patchSize = this.model.world.patchSize;\r\n\r\n    // const red = [1, 0, 0] // REMIND: add color/shape to turtles\r\n\r\n    for (let i = 0; i < turtles.length; i++) {\r\n      const {x, y, z, color} = turtles[i];\r\n      vertices.push(x * patchSize, y * patchSize, z * patchSize);\r\n      // if (colors != null) colors.push(...red)\r\n      if (colors != null) colors.push(...color.webgl);\r\n    }\r\n    positionAttrib.setArray(new Float32Array(vertices));\r\n    positionAttrib.needsUpdate = true;\r\n    if (colors) {\r\n      colorAttrib.setArray(new Float32Array(colors));\r\n      colorAttrib.needsUpdate = true;\r\n    }\r\n  }\r\n}\r\n\r\n// ============= LinksMesh =============\r\n\r\nclass LinksMesh extends BaseMesh {\r\n  static options () {\r\n    return {\r\n      color: null,\r\n      z: 1.5\r\n    }\r\n  }\r\n  init () {\r\n    if (this.mesh) this.dispose();\r\n    const color = this.options.color ? new THREE.Color(...this.options.color) : null;\r\n\r\n    const geometry = new THREE.BufferGeometry();\r\n    geometry.addAttribute('position',\r\n      new THREE.BufferAttribute(new Float32Array(), 3));\r\n    if (color == null)\r\n      geometry.addAttribute('color',\r\n        new THREE.BufferAttribute(new Float32Array(), 3));\r\n\r\n    const material = color\r\n      ? new THREE.LineBasicMaterial({color: color})\r\n      : new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});\r\n    // const material = color\r\n    // ? new THREE.PointsMaterial({size: pointSize, color: color})\r\n    // : new THREE.PointsMaterial({size: pointSize, vertexColors: THREE.VertexColors})\r\n\r\n    this.mesh = new THREE.LineSegments(geometry, material);\r\n    this.mesh.position.z = this.options.z;\r\n    this.scene.add(this.mesh);\r\n  }\r\n  // update takes any array of objects with color & end0, end1 having x,y,z\r\n  // REMIND: optimize by flags for position/uvs need updates\r\n  update (links) {\r\n    const vertices = [];\r\n    const colors = this.options.color ? null : [];\r\n    for (let i = 0; i < links.length; i++) {\r\n      const {end0, end1, color} = links[i];\r\n      const {x: x0, y: y0, z: z0} = end0;\r\n      const {x: x1, y: y1, z: z1} = end1;\r\n      const ps = this.model.world.patchSize;\r\n      vertices.push(x0 * ps, y0 * ps, z0 * ps, x1 * ps, y1 * ps, z1 * ps);\r\n      if (colors)\r\n        colors.push(...color.webgl, ...color.webgl);\r\n    }\r\n    const positionAttrib = this.mesh.geometry.getAttribute('position');\r\n    positionAttrib.setArray(new Float32Array(vertices));\r\n    positionAttrib.needsUpdate = true;\r\n    if (colors) {\r\n      const colorAttrib = this.mesh.geometry.getAttribute('color');\r\n      colorAttrib.setArray(new Float32Array(colors));\r\n      colorAttrib.needsUpdate = true;\r\n    }\r\n  }\r\n}\r\n\r\nvar Meshes = {\r\n  BaseMesh,\r\n  CanvasMesh,\r\n  PatchesMesh,\r\n  QuadSpritesMesh,\r\n  PointsMesh,\r\n  LinksMesh\r\n};\r\n\r\n// import SpriteSheet from './SpriteSheet.js'\r\nwindow.Meshes = Meshes; // REMIND\r\n\r\nclass Three {\r\n  static defaultOptions (useThreeHelpers = true, useUIHelpers = true) {\r\n    const options = {\r\n    // include me in options so Model can instanciate me!\r\n      Renderer: Three, // REMIND: use string.\r\n      orthoView: false,             // 'Perspective', 'Orthographic'\r\n      clearColor: 0x000000,         // clear to black\r\n      useAxes: useThreeHelpers,     // show x,y,z axes\r\n      useGrid: useThreeHelpers,     // show x,y plane\r\n      useControls: useThreeHelpers, // navigation. REMIND: control name?\r\n      useStats: useUIHelpers,       // show fps widget\r\n      useGUI: useUIHelpers,         // activate dat.gui UI\r\n      // meshes: {\r\n      patches: {\r\n        meshClass: 'PatchesMesh'\r\n      },\r\n      turtles: {\r\n        meshClass: 'QuadSpritesMesh'\r\n        // meshClass: 'PointsMesh'\r\n      },\r\n      links: {\r\n        meshClass: 'LinksMesh'\r\n      }\r\n      // }\r\n    };\r\n    // util.forEach(options.meshes, (val, key) => {\r\n    //   const Mesh = Meshes[val.meshClass]\r\n    //   const meshOptions = Mesh.options()\r\n    //   val.options = meshOptions\r\n    // })\r\n    util.forEach(options, (val, key) => {\r\n      if (val.meshClass) {\r\n        const Mesh = Meshes[val.meshClass];\r\n        const meshOptions = Mesh.options();\r\n        val.options = meshOptions;\r\n      }\r\n    });\r\n\r\n    return options\r\n  }\r\n  static printMeshOptions () {\r\n    const obj = {};\r\n    for (const MeshName in Meshes) {\r\n      const optionsFcn = Meshes[MeshName].options;\r\n      if (optionsFcn) {\r\n        obj[MeshName] = {\r\n          options: Meshes[MeshName].options()\r\n        };\r\n      }\r\n    }\r\n    const str = util.objectToString(obj);\r\n    console.log(str);\r\n  }\r\n\r\n  constructor (model, options = {}) {\r\n    this.model = model;\r\n    // this.spriteSheet = model.spriteSheet // REMIND: Temp\r\n\r\n    // Initialize options\r\n    Object.assign(this, Three.defaultOptions); // install defaults\r\n    Object.assign(this, options); // override defaults\r\n    if (this.Renderer !== Three)\r\n      throw Error('Three ctor: Renderer not Three', this.renderer)\r\n\r\n    // Initialize Three.js\r\n    this.initThree();\r\n    this.initThreeHelpers();\r\n  }\r\n  // Init Three.js core: scene, camera, renderer\r\n  initThree () {\r\n    const {clientWidth, clientHeight} = this.model.div;\r\n    const {orthoView, clearColor} = this;\r\n    // const {width, height, centerX, centerY} = this.model.world\r\n    const {width, height} = this.model.world;\r\n    const [halfW, halfH] = [width / 2, height / 2];\r\n\r\n    // this.spriteSheet.texture = new THREE.CanvasTexture(this.spriteSheet.ctx)\r\n    // this.spriteSheet.setTexture(THREE.CanvasTexture)\r\n\r\n    // REMIND: need world.minZ/maxZ\r\n    const orthographicCam =\r\n      new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, 1, 20 * width);\r\n    orthographicCam.position.set(0, 0, 10 * width);\r\n    orthographicCam.up.set(0, 0, 1);\r\n\r\n    const perspectiveCam =\r\n      new THREE.PerspectiveCamera(45, clientWidth / clientHeight, 1, 10000);\r\n    // perspectiveCam.position.set(width + centerX, -width - centerY, width)\r\n    perspectiveCam.position.set(width, -width, width);\r\n    // perspectiveCam.lookAt(new THREE.Vector3(centerX, centerY, 0))\r\n    perspectiveCam.up.set(0, 0, 1);\r\n\r\n    const scene = new THREE.Scene();\r\n    // scene.position = new THREE.Vector3(centerX, centerY, 0)\r\n    const camera = orthoView ? orthographicCam : perspectiveCam;\r\n\r\n    // if (orthoView)\r\n    //   camera.position.set(0, 0, 100 * width)\r\n    // else\r\n    //   camera.position.set(width, -width, width)\r\n    // camera.up.set(0, 0, 1)\r\n\r\n    const renderer = new THREE.WebGLRenderer();\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n    renderer.setSize(clientWidth, clientHeight);\r\n    renderer.setClearColor(clearColor);\r\n    this.model.div.appendChild(renderer.domElement);\r\n\r\n    // window.addEventListener('resize', () => {\r\n    //   const {clientWidth, clientHeight} = this.model.div\r\n    //   camera.aspect = clientWidth / clientHeight\r\n    //   camera.updateProjectionMatrix()\r\n    //   renderer.setSize(clientWidth, clientHeight)\r\n    // })\r\n    window.addEventListener('resize', () => { this.resize(); });\r\n\r\n    Object.assign(this, {scene, camera, renderer, orthographicCam, perspectiveCam});\r\n  }\r\n  resize () {\r\n    const {clientWidth, clientHeight} = this.model.div;\r\n    const {width, height} = this.model.world;\r\n\r\n    if (this.orthoView) {\r\n      const zoom = Math.min(clientWidth / width, clientHeight / height);\r\n      this.renderer.setSize(zoom * width, zoom * height);\r\n    } else {\r\n      this.camera.aspect = clientWidth / clientHeight;\r\n      this.camera.updateProjectionMatrix();\r\n      this.renderer.setSize(clientWidth, clientHeight);\r\n    }\r\n  }\r\n  toggleCamera () {\r\n    this.orthoView = !this.orthoView;\r\n    if (this.orthoView) {\r\n      this.camera = this.orthographicCam;\r\n    } else {\r\n      this.camera = this.perspectiveCam;\r\n    }\r\n    this.resize();\r\n  }\r\n  // Return a dataURL for the current model step.\r\n  snapshot (useOrtho = true) {\r\n    // Don't set camera, can change w/ toggle below\r\n    const {scene, renderer, model} = this;\r\n    const toggle = useOrtho && this.camera === this.perspectiveCam;\r\n\r\n    if (toggle) { this.toggleCamera(); model.draw(true); }\r\n    renderer.render(scene, this.camera);\r\n    const durl = renderer.domElement.toDataURL();\r\n    if (toggle) this.toggleCamera();\r\n    return durl\r\n  }\r\n  initThreeHelpers () {\r\n    const {scene, renderer, camera} = this;\r\n    const {useAxes, useGrid, useControls, useStats, useGUI} = this;\r\n    const {width} = this.model.world;\r\n    const helpers = {};\r\n\r\n    if (useAxes) {\r\n      helpers.axes = new THREE.AxisHelper(1.5 * width / 2);\r\n      scene.add(helpers.axes);\r\n    }\r\n    if (useGrid) {\r\n      helpers.grid = new THREE.GridHelper(1.25 * width, 10);\r\n      helpers.grid.rotation.x = THREE.Math.degToRad(90);\r\n      scene.add(helpers.grid);\r\n    }\r\n    if (useControls) {\r\n      helpers.controls = new THREE.OrbitControls(camera, renderer.domElement);\r\n    }\r\n    if (useStats) {\r\n      helpers.stats = new Stats();\r\n      // This does not work: helpers.stats.dom.style.position = 'absolute'\r\n      document.body.appendChild(helpers.stats.dom);\r\n    }\r\n    if (useGUI) {\r\n      helpers.gui = new dat.GUI(); // auto adds to body, appendChild not needed\r\n    }\r\n\r\n    Object.assign(this, helpers);\r\n  }\r\n}\r\n\r\n// Class Model is the primary interface for modelers, integrating\r\n// all the parts of a model. It also contains NetLogo's `observer` methods.\r\nclass Model {\r\n  // Static class methods for default settings.\r\n  // Default world is centered, patchSize = 13, min/max = 16\r\n  static defaultWorld (size = 13, max = 16) {\r\n    return World.defaultOptions(size, max)\r\n  }\r\n  // Default renderer is Three.js\r\n  static defaultRenderer () {\r\n    return Three.defaultOptions()\r\n  }\r\n  static printDefaultViewOptions () {\r\n    Three.printMeshOptions();\r\n  }\r\n\r\n  // The Model constructor takes a DOM div and model and renderer options.\r\n  // Default values are given for all constructor arguments.\r\n  constructor (div = document.body,\r\n               worldOptions = Model.defaultWorld(),\r\n               rendererOptions = Model.defaultRenderer()) {\r\n    // Store and initialize the model's div and contexts.\r\n    this.div = util.isString(div) ? document.getElementById(div) : div;\r\n    this.spriteSheet = new SpriteSheet();\r\n\r\n    // Create this model's `world` object\r\n    this.world = new World(worldOptions);\r\n\r\n    // Initialize view\r\n    this.view = new rendererOptions.Renderer(this, rendererOptions);\r\n\r\n    // Initialize meshes.\r\n    this.meshes = {};\r\n    util.forEach(rendererOptions, (val, key) => {\r\n      if (val.meshClass) {\r\n        const Mesh = Meshes[val.meshClass];\r\n        const options = Mesh.options(); // default options\r\n        Object.assign(options, val.options); // override by user's\r\n        if (options.color) // convert options.color rgb array to Color.\r\n          options.color = Color.toColor(new Float32Array(options.color));\r\n        this.meshes[key] = new Meshes[val.meshClass](this.view, options);\r\n      }\r\n    });\r\n\r\n    // Create animator to handle draw/step.\r\n    this.anim = new Animator(this);\r\n\r\n    // Initialize model calling `startup`, `reset` .. which calls `setup`.\r\n    // this.modelReady = false\r\n    // this.startup().then(() => {\r\n    //   // this.reset(); this.setup(); this.modelReady = true\r\n    //   this.reset(); this.modelReady = true\r\n    // })\r\n    this.reset(); // REMIND: Temporary\r\n  }\r\n  // Call fcn(this) when any async\r\n  // whenReady (fcn) {\r\n  //   // util.waitPromise(() => this.modelReady).then(fcn())\r\n  //   util.waitOn(() => this.modelReady, () => fcn(this))\r\n  // }\r\n  // Add additional world variables derived from constructor's `modelOptions`.\r\n  // setWorld () {\r\n  //   const world = this.world\r\n  //   // REMIND: change to xPatches, yPatches?\r\n  //   world.numX = world.maxX - world.minX + 1\r\n  //   world.numY = world.maxY - world.minY + 1\r\n  //   world.width = world.numX * world.patchSize\r\n  //   world.height = world.numY * world.patchSize\r\n  //   world.minXcor = world.minX - 0.5\r\n  //   world.maxXcor = world.maxX + 0.5\r\n  //   world.minYcor = world.minY - 0.5\r\n  //   world.maxYcor = world.maxY + 0.5\r\n  //   world.isOnWorld = (x, y) => // No braces, is lambda expression\r\n  //     (world.minXcor <= x) && (x <= world.maxXcor) &&\r\n  //     (world.minYcor <= y) && (y <= world.maxYcor)\r\n  // }\r\n  // createQuad (r, z = 0) { // r is radius of xy quad: [-r,+r], z is quad z\r\n  //   const vertices = [-r, -r, z, r, -r, z, r, r, z, -r, r, z]\r\n  //   const indices = [0, 1, 2, 0, 2, 3]\r\n  //   return {vertices, indices}\r\n  // }\r\n  // (Re)initialize the model. REMIND: not quite right\r\n  // setAgentSetViewProps (agentSet, mesh) {\r\n  //   agentSet.isMonochrome = mesh.isMonochrome()\r\n  //   agentSet.useSprites = mesh.useSprites()\r\n  // }\r\n  initAgentSet (name, AgentsetClass, AgentClass) {\r\n    const agentset = new AgentsetClass(this, AgentClass, name);\r\n    const mesh = this.meshes[name];\r\n    // const meshName = mesh.constructor.name\r\n    this[name] = agentset;\r\n    // agentset.setDefault('renderer', mesh)\r\n    agentset.renderer = mesh;\r\n    if (mesh.fixedColor) agentset.setDefault('color', mesh.fixedColor);\r\n    // REMIND: Turtles only?\r\n    if (mesh.fixedShape) agentset.setDefault('shape', mesh.fixedShape);\r\n    // this.agentset.fixedColor = agentset.renderer.options.color\r\n    // agentset.useSprites = meshName in ['PointSpritesMesh', 'QuadSpritesMesh']\r\n    // agentset.fixedColor = agentset.renderer.options.color\r\n    // agentset.useSprites = meshName in ['PointSpritesMesh', 'QuadSpritesMesh']\r\n    // agentset.fixedShape =\r\n    mesh.init(agentset);\r\n  }\r\n  reset (restart = false) {\r\n    this.anim.reset();\r\n    this.world.setWorld(); // allow world to change?\r\n\r\n    this.refreshLinks = this.refreshTurtles = this.refreshPatches = true;\r\n\r\n    // Breeds handled by setup\r\n    this.initAgentSet('patches', Patches, Patch);\r\n    this.initAgentSet('turtles', Turtles, Turtle);\r\n    this.initAgentSet('links', Links, Link);\r\n    // this.patches = new Patches(this, Patch, 'patches')\r\n    // this.patches.renderer = this.meshes.patches\r\n    // this.meshes.patches.init(this.patches)\r\n    // this.setAgentSetViewProps(this.patches, this.meshes.patches)\r\n    //\r\n    // this.turtles = new Turtles(this, Turtle, 'turtles')\r\n    // this.turtles.renderer = this.meshes.turtles\r\n    // this.meshes.turtles.init(this.turtles)\r\n    // this.setAgentSetViewProps(this.turtles, this.meshes.turtles)\r\n    //\r\n    // this.links = new Links(this, Link, 'links')\r\n    // this.turtles.links = this.meshes.links\r\n    // this.meshes.links.init(this.links)\r\n    // this.setAgentSetViewProps(this.links, this.meshes.links)\r\n\r\n    // this.setup()\r\n    if (restart) this.start();\r\n  }\r\n\r\n// ### User Model Creation\r\n  // A user's model is made by subclassing Model and over-riding these\r\n  // three abstract methods. `super` need not be called.\r\n\r\n  setup () {} // Your initialization code goes here\r\n  // Update/step your model here\r\n  step () {} // called each step of the animation\r\n\r\n  // Start/stop the animation. Return model for chaining.\r\n  start () {\r\n    // util.waitOn(() => this.modelReady, () => {\r\n    //   this.anim.start()\r\n    // })\r\n    this.anim.start();\r\n    return this\r\n  }\r\n  stop () { this.anim.stop(); }\r\n  // Animate once by `step(); draw()`.\r\n  once () { this.stop(); this.anim.once(); } // stop is no-op if already stopped\r\n\r\n  // Change the world parameters. Requires a reset.\r\n  // Resets Patches, Turtles, Links & reinitializes canvases.\r\n  // If restart argument is true (default), will restart after resetting.\r\n  // resizeWorld (modelOptions, restart = true) {\r\n  //   Object.assign(this.world, modelOptions)\r\n  //   this.setWorld(this.world)\r\n  //   this.reset(restart)\r\n  // }\r\n\r\n  draw (force = this.anim.stopped || this.anim.draws === 1) {\r\n    // const {scene, camera} = this.view\r\n    if (this.div) {\r\n      if (force || this.refreshPatches) {\r\n        if (this.patches.length > 0)\r\n          this.patches.renderer.update(this.patches);\r\n      }\r\n      if (force || this.refreshTurtles) {\r\n        if (this.turtles.length > 0)\r\n          this.turtles.renderer.update(this.turtles);\r\n      }\r\n      if (force || this.refreshLinks) {\r\n        if (this.links.length > 0)\r\n          this.links.renderer.update(this.links);\r\n      }\r\n\r\n      // REMIND: generalize.\r\n      this.view.renderer.render(this.view.scene, this.view.camera);\r\n    }\r\n    if (this.view.stats) this.view.stats.update();\r\n  }\r\n\r\n  // Breeds: create breeds/subarrays of Patches, Agents, Links\r\n  patchBreeds (breedNames) {\r\n    for (const breedName of breedNames.split(' ')) {\r\n      this[breedName] = this.patches.newBreed(breedName);\r\n    }\r\n  }\r\n  turtleBreeds (breedNames) {\r\n    for (const breedName of breedNames.split(' ')) {\r\n      this[breedName] = this.turtles.newBreed(breedName);\r\n    }\r\n  }\r\n  linkBreeds (breedNames) {\r\n    for (const breedName of breedNames.split(' ')) {\r\n      this[breedName] = this.links.newBreed(breedName);\r\n    }\r\n  }\r\n}\r\n\r\n// Parse an RGBA image to a DataSet of the given type.\r\n// We use all 4 bytes of the pixels, thus map exactly onto\r\n// multiples all [TypedArray](https://goo.gl/3OOQzy) sizes.\r\nclass RGBADataSet extends DataSet {\r\n  constructor (img, Type = Float32Array, options = {}) {\r\n    const bytes = util.imageToBytes(img);\r\n    const data = new Type(bytes.buffer); // Parse via a Type view on the buffer\r\n    const dataPerPixel = 4 * data.length / bytes.length;\r\n    const width = dataPerPixel * img.width;\r\n    const height = img.height;\r\n    super(width, height, data);\r\n    Object.assign(this, options);\r\n    this.src = img.src;\r\n  }\r\n}\r\n\r\nclass RGBDataSet extends DataSet {\r\n\r\n  constructor (img, options = {}) {\r\n    super(img.width, img.height, new Float32Array(img.width * img.height));\r\n    Object.assign(this, options);\r\n    const ctx = util.createCtx(img.width, img.height);\r\n    util.fillCtxWithImage(ctx, img);\r\n    const imgData = util.ctxImageData(ctx);\r\n    const convertedData = this.data; // new Float32Array(img.width * img.height)\r\n    for (var i = 0; i < convertedData.length; i++) {\r\n      const r = imgData.data[4 * i];\r\n      const g = imgData.data[4 * i + 1];\r\n      const b = imgData.data[4 * i + 2];\r\n      convertedData[i] = this.rgb2Number(r, g, b);\r\n    }\r\n    this.src = img.src;\r\n    this.ctx = ctx; // REMIND: debug\r\n    // var mydata = new DataSet(img.width, img.height, convertedData)\r\n    // return mydata\r\n  }\r\n\r\n  // Convert RGB to a number.\r\n  // by default this assumes the values are in decimeters, but it can be overwritten.\r\n  //  This funnction gets called in a tight loop for every pixel.\r\n  rgb2Number (r, g, b) {\r\n    var negative = 1;\r\n    if (r > 63) {\r\n      negative = -1;\r\n      r = 0;\r\n    }\r\n    var n = negative * (r * 256 * 256 + g * 256 + b);\r\n    n = n / 10;\r\n    return n\r\n  }\r\n}\r\n\r\n/* eslint-disable */\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3gtYWJtL2Rpc3QvQVMubW9kdWxlLmpzPzIxNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cclxuXHJcbmlmICghVEhSRUUuT3JiaXRDb250cm9scyAmJiBPcmJpdENvbnRyb2xzKSBUSFJFRS5PcmJpdENvbnRyb2xzID0gT3JiaXRDb250cm9scztcclxuXHJcbi8vIEEgc2V0IG9mIHVzZWZ1bCBtaXNjIHV0aWxzIHdoaWNoIHdpbGwgZXZlbnR1YWxseSBtb3ZlIHRvIGluZGl2aWR1YWwgZmlsZXMuXHJcbi8vIE5vdGUgd2UgdXNlIGFycm93IGZ1bmN0aW9ucyBvbmUtbGluZXJzLCBtb3JlIGxpa2VseSB0byBiZSBvcHRpbWl6ZWQuXHJcbi8vIFJFTUlORDogVGVzdCBvcHRpbWl6YXRpb24sIGlmIG5vbmUsIHJlbW92ZSBhcnJvdyBvbmUtbGluZXJzLlxyXG5cclxuY29uc3QgdXRpbCA9IHtcclxuXHJcbi8vICMjIyBUeXBlc1xyXG5cclxuICAvLyBGaXhpbmcgdGhlIGphdmFzY3JpcHQgW3R5cGVvZiBvcGVyYXRvcl0oaHR0cHM6Ly9nb28uZ2wvRWZkems1KVxyXG4gIHR5cGVPZjogKG9iaikgPT4gKHt9KS50b1N0cmluZy5jYWxsKG9iaikubWF0Y2goL1xccyhcXHcrKS8pWzFdLnRvTG93ZXJDYXNlKCksXHJcbiAgaXNPbmVPZjogKG9iaiwgYXJyYXkpID0+IGFycmF5LmluY2x1ZGVzKHV0aWwudHlwZU9mKG9iaikpLFxyXG4gIC8vIGlzVWludEFycmF5OiAob2JqKSA9PiB1dGlsLnR5cGVPZihvYmopLm1hdGNoKC91aW50LiphcnJheS8pLFxyXG4gIGlzVWludEFycmF5OiAob2JqKSA9PiAvXnVpbnQuKmFycmF5JC8udGVzdCh1dGlsLnR5cGVPZihvYmopKSxcclxuICBpc0ludEFycmF5OiAob2JqKSA9PiAvXmludC4qYXJyYXkkLy50ZXN0KHV0aWwudHlwZU9mKG9iaikpLFxyXG4gIGlzRmxvYXRBcnJheTogKG9iaikgPT4gL15mbG9hdC4qYXJyYXkkLy50ZXN0KHV0aWwudHlwZU9mKG9iaikpLFxyXG4gIGlzSW1hZ2U6IChvYmopID0+IHV0aWwudHlwZU9mKG9iaikgPT09ICdpbWFnZScsXHJcbiAgaXNJbWFnZWFibGU6IChvYmopID0+IHV0aWwuaXNPbmVPZihvYmosXHJcbiAgICBbJ2ltYWdlJywgJ2h0bWxpbWFnZWVsZW1lbnQnLCAnaHRtbGNhbnZhc2VsZW1lbnQnXSksXHJcbiAgLy8gSXMgb2JqIFR5cGVkQXJyYXk/IElmIG9iai5idWZmZXIgbm90IHByZXNlbnQsIHdvcmtzLCB0eXBlIGlzICd1bmRlZmluZWQnXHJcbiAgaXNUeXBlZEFycmF5OiAob2JqKSA9PiB1dGlsLnR5cGVPZihvYmouYnVmZmVyKSA9PT0gJ2FycmF5YnVmZmVyJyxcclxuICAvLyBJcyBhIG51bWJlciBhbiBpbnRlZ2VyIChyYXRoZXIgdGhhbiBhIGZsb2F0IHcvIG5vbi16ZXJvIGZyYWN0aW9uYWwgcGFydClcclxuICBpc0ludGVnZXI6IE51bWJlci5pc0ludGVnZXIgfHwgKChudW0pID0+IE1hdGguZmxvb3IobnVtKSA9PT0gbnVtKSxcclxuICAvLyBJcyBvYmogYSBzdHJpbmc/XHJcbiAgaXNTdHJpbmc6IChvYmopID0+IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnLFxyXG4gIC8vIENoZWNrIFtiaWcvbGl0dGxlIGVuZGlhbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW5kaWFubmVzcylcclxuICBpc0xpdHRsZUVuZGlhbiAoKSB7XHJcbiAgICBjb25zdCBkMzIgPSBuZXcgVWludDMyQXJyYXkoWzB4MDEwMjAzMDRdKTtcclxuICAgIHJldHVybiAobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGQzMi5idWZmZXIpKVswXSA9PT0gNFxyXG4gIH0sXHJcblxyXG4gIC8vIFRocm93IGFuIGVycm9yIHdpdGggc3RyaW5nLlxyXG4gIC8vIFVzZSBpbnN0ZWFkIG9mIGB0aHJvdyBtZXNzYWdlYCBmb3IgYmV0dGVyIGRlYnVnZ2luZ1xyXG4gIC8vIGVycm9yOiAobWVzc2FnZSkgPT4geyB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSkgfSxcclxuXHJcbiAgLy8gSWRlbnRpdHkgZmNuLCByZXR1cm5pbmcgaXRzIGFyZ3VtZW50IHVuY2hhbmdlZC4gVXNlZCBpbiBjYWxsYmFja3NcclxuICBpZGVudGl0eTogKG8pID0+IG8sXHJcbiAgLy8gTm8tb3AgZnVuY3Rpb24sIGRvZXMgbm90aGluZy4gVXNlZCBmb3IgZGVmYXVsdCBjYWxsYmFjay5cclxuICBub29wOiAoKSA9PiB7fSxcclxuICAvLyBSZXR1cm4gZnVuY3Rpb24gcmV0dXJuaW5nIGFuIG9iamVjdCdzIHByb3BlcnR5LiAgUHJvcGVydHkgaW4gZmNuIGNsb3N1cmUuXHJcbiAgcHJvcEZjbjogKHByb3ApID0+IChvKSA9PiBvW3Byb3BdLFxyXG5cclxuICAvLyBDb252ZXJ0IEFycmF5IG9yIFR5cGVkQXJyYXkgdG8gZ2l2ZW4gVHlwZSAoQXJyYXkgb3IgVHlwZWRBcnJheSkuXHJcbiAgLy8gUmVzdWx0IHNhbWUgbGVuZ3RoIGFzIGFycmF5LCBwcmVjaXNpb24gbWF5IGJlIGxvc3QuXHJcbiAgY29udmVydEFycmF5IChhcnJheSwgVHlwZSkge1xyXG4gICAgY29uc3QgVHlwZTAgPSBhcnJheS5jb25zdHJ1Y3RvcjtcclxuICAgIGlmIChUeXBlMCA9PT0gVHlwZSkgcmV0dXJuIGFycmF5ICAvLyByZXR1cm4gYXJyYXkgaWYgYWxyZWFkeSBzYW1lIFR5cGVcclxuICAgIHJldHVybiBUeXBlLmZyb20oYXJyYXkpIC8vIFVzZSAuZnJvbSAoYm90aCBUeXBlZEFycmF5cyBhbmQgQXJyYXlzKVxyXG4gIH0sXHJcbiAgLy8gQ29udmVydCB0by9mcm9tIG5ldyBVaW50OEFycmF5IHZpZXcgb250byBhbiBBcnJheSBvciBUeXBlZEFycmF5LlxyXG4gIC8vIEFycmF5cyBjb252ZXJ0ZWQgdG8gQXJyYXlUeXBlLCBkZWZhdWx0IEZsb2F0NjRBcnJheS5cclxuICAvLyBSZXR1cm4gd2lsbCBpbiBnZW5lcmFsIGJlIGEgZGlmZmVyZW50IGxlbmd0aCB0aGFuIGFycmF5XHJcbiAgYXJyYXlUb0J1ZmZlciAoYXJyYXksIEFycmF5VHlwZSA9IEZsb2F0NjRBcnJheSkge1xyXG4gICAgaWYgKGFycmF5LmNvbnN0cnVjdG9yID09PSBBcnJheSkgYXJyYXkgPSBuZXcgQXJyYXlUeXBlKGFycmF5KTtcclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnJheS5idWZmZXIpXHJcbiAgfSxcclxuICBidWZmZXJUb0FycmF5ICh1aW50OGFycmF5LCBUeXBlLCBBcnJheVR5cGUgPSBGbG9hdDY0QXJyYXkpIHtcclxuICAgIGlmIChUeXBlID09PSBBcnJheSkgVHlwZSA9IEFycmF5VHlwZTtcclxuICAgIHJldHVybiAoVHlwZSA9PT0gQXJyYXkpXHJcbiAgICAgID8gQXJyYXkuZnJvbShuZXcgQXJyYXlUeXBlKHVpbnQ4YXJyYXkuYnVmZmVyKSlcclxuICAgICAgOiBuZXcgVHlwZSh1aW50OGFycmF5LmJ1ZmZlcilcclxuICAgIC8vIHJldHVybiBuZXcgVHlwZSh1aW50OGFycmF5LmJ1ZmZlcilcclxuICB9LFxyXG5cclxuICAvLyBDb252ZXJ0IGJldHdlZW4gVWludDhBcnJheSBidWZmZXIgYW5kIGJhc2U2NCBzdHJpbmcuXHJcbiAgLy8gaHR0cHM6Ly9jb29sYWo4Ni5jb20vYXJ0aWNsZXMvdHlwZWRhcnJheS1idWZmZXItdG8tYmFzZTY0LWluLWphdmFzY3JpcHQvXHJcbiAgLy8gU3RhY2sgT3ZlcmZsb3c6IGh0dHBzOi8vZ29vLmdsL3hzY3M4VFxyXG4gIGJ1ZmZlclRvQmFzZTY0ICh1aW50OEFycmF5KSB7XHJcbiAgICBjb25zdCBiaW5zdHIgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodWludDhBcnJheSwgKGNoKSA9PlxyXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxyXG4gICAgKS5qb2luKCcnKTtcclxuICAgIHJldHVybiBidG9hKGJpbnN0cilcclxuICB9LFxyXG4gIGJhc2U2NFRvQnVmZmVyIChiYXNlNjQpIHtcclxuICAgIGNvbnN0IGJpbnN0ciA9IGF0b2IoYmFzZTY0KTtcclxuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShiaW5zdHIubGVuZ3RoKTtcclxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYmluc3RyLCAoY2gsIGkpID0+IHtcclxuICAgICAgdWludDhBcnJheVtpXSA9IGNoLmNoYXJDb2RlQXQoMCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB1aW50OEFycmF5XHJcbiAgfSxcclxuXHJcbi8vICMjIyBEZWJ1Z1xyXG5cclxuICAvLyBQcmludCBhIG1lc3NhZ2UganVzdCBvbmNlLlxyXG4gIGxvZ09uY2UgKG1zZykge1xyXG4gICAgaWYgKCF0aGlzLmxvZ09uY2VNc2dTZXQpIHRoaXMubG9nT25jZU1zZ1NldCA9IG5ldyBTZXQoKTtcclxuICAgIGlmICghdGhpcy5sb2dPbmNlTXNnU2V0Lmhhcyhtc2cpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKG1zZyk7XHJcbiAgICAgIHRoaXMubG9nT25jZU1zZ1NldC5hZGQobXNnKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHdhcm4gKG1zZykge1xyXG4gICAgdGhpcy5sb2dPbmNlKCdXYXJuaW5nOiAnICsgbXNnKTtcclxuICB9LFxyXG5cclxuICAvLyBVc2UgY2hyb21lL2Zmb3gvaWUgY29uc29sZS50aW1lKCkvdGltZUVuZCgpIHBlcmZvcm1hbmNlIGZ1bmN0aW9uc1xyXG4gIHRpbWVpdCAoZiwgcnVucyA9IDFlNSwgbmFtZSA9ICd0ZXN0Jykge1xyXG4gICAgY29uc29sZS50aW1lKG5hbWUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydW5zOyBpKyspIGYoaSk7XHJcbiAgICBjb25zb2xlLnRpbWVFbmQobmFtZSk7XHJcbiAgfSxcclxuXHJcbiAgcHBzIChvYmosIHRpdGxlID0gJycpIHtcclxuICAgIGlmICh0aXRsZSkgY29uc29sZS5sb2codGl0bGUpOyAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgIGxldCBjb3VudCA9IDE7XHJcbiAgICBsZXQgc3RyID0gJyc7XHJcbiAgICB3aGlsZSAob2JqKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgc3RyID0gb2JqLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgb2tleXMgPSBPYmplY3Qua2V5cyhvYmopO1xyXG4gICAgICAgIHN0ciA9IG9rZXlzLmxlbmd0aCA+IDBcclxuICAgICAgICAgID8gYFske29rZXlzLmpvaW4oJywgJyl9XWAgOiBgWyR7b2JqLmNvbnN0cnVjdG9yLm5hbWV9XWA7XHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5sb2coYFske2NvdW50Kyt9XTogJHtzdHJ9YCk7XHJcbiAgICAgIG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIGFkZFRvRG9tOiBhZGQgYW4gZWxlbWVudCB0byB0aGUgZG9ldW1lbnQgYm9keS5cclxuICBhZGRUb0RvbSAoc3JjLCB0eXBlLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XHJcbiAgICBpZiAodHlwZSkge1xyXG4gICAgICB0eXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcclxuICAgICAgc3JjID0gdHlwZS50ZXh0Q29udGVudCA9IHNyYztcclxuICAgIH1cclxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChzcmMpO1xyXG4gIH0sXHJcblxyXG4gIC8vIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBhcnJheSBvZiBhcnJheXNcclxuICBhcnJheXNUb1N0cmluZzogKGFycmF5cykgPT4gYXJyYXlzLm1hcCgoYSkgPT4gYFske2F9XWApLmpvaW4oJywnKSxcclxuXHJcbiAgLy8gUmV0dXJuIGFycmF5IG9mIHN0cmluZ3Mgb2YgZml4ZWQgZmxvYXRzIHRvIGdpdmVuIHByZWNpc2lvblxyXG4gIGZpeGVkU3RyaW5ncyAoYXJyYXksIGRpZ2l0cyA9IDQpIHtcclxuICAgIGFycmF5ID0gdGhpcy5jb252ZXJ0QXJyYXkoYXJyYXksIEFycmF5KTsgLy8gT25seSBBcnJheSBzdG9yZXMgc3RyaW5ncy5cclxuICAgIHJldHVybiBhcnJheS5tYXAoKG4pID0+IG4udG9GaXhlZChkaWdpdHMpKVxyXG4gIH0sXHJcblxyXG4gIC8vIE1lcmdlIGZyb20ncyBrZXkvdmFsIHBhaXJzIGludG8gdG8gdGhlIGdsb2JhbCB3aW5kb3cgbmFtZXNwYWNlXHJcbiAgdG9XaW5kb3cgKG9iaikge1xyXG4gICAgT2JqZWN0LmFzc2lnbih3aW5kb3csIG9iaik7XHJcbiAgICBjb25zb2xlLmxvZygndG9XaW5kb3c6JywgT2JqZWN0LmtleXMob2JqKS5qb2luKCcsICcpKTtcclxuICB9LFxyXG5cclxuLy8gIyMjIEhUTUwsIENTUywgRE9NXHJcblxyXG4gIC8vIFJFU1Q6IFBhcnNlIHRoZSBxdWVyeSwgcmV0dXJuaW5nIGFuIG9iamVjdCBvZiBrZXkvdmFsIHBhaXJzLlxyXG4gIHBhcnNlUXVlcnlTdHJpbmcgKCkge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IHt9O1xyXG4gICAgY29uc3QgcXVlcnkgPSBkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpO1xyXG4gICAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhcmFtID0gcy5zcGxpdCgnPScpO1xyXG4gICAgICAvLyBJZiBqdXN0IGtleSwgbm8gdmFsLCBzZXQgdmFsIHRvIHRydWVcclxuICAgICAgcmVzdWx0c1twYXJhbVswXV0gPSAocGFyYW0ubGVuZ3RoID09PSAxKSA/IHRydWUgOiBwYXJhbVsxXTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdHNcclxuICB9LFxyXG5cclxuICAvLyBDcmVhdGUgZHluYW1pYyBgPHNjcmlwdD5gIHRhZywgYXBwZW5kaW5nIHRvIGA8aGVhZD5gXHJcbiAgLy8gICA8c2NyaXB0IHNyYz1cIi4vdGVzdC9zcmMvdGhyZWUwLmpzXCIgdHlwZT1cIm1vZHVsZVwiPjwvc2NyaXB0PlxyXG4gIHNldFNjcmlwdCAocGF0aCwgcHJvcHMgPSB7fSkge1xyXG4gICAgY29uc3Qgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICBzY3JpcHRUYWcuc3JjID0gcGF0aDtcclxuICAgIC8vIHRoaXMuZm9yRWFjaChwcm9wcywgKHZhbCwga2V5KSA9PiB7IHNjcmlwdFRhZ1trZXldID0gdmFsIH0pXHJcbiAgICBPYmplY3QuYXNzaWduKHNjcmlwdFRhZywgcHJvcHMpO1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpLmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gR2V0IGVsZW1lbnQgKGkuZS4gY2FudmFzKSByZWxhdGl2ZSB4LHkgcG9zaXRpb24gZnJvbSBldmVudC9tb3VzZSBwb3NpdGlvbi5cclxuICBnZXRFdmVudFhZIChlbGVtZW50LCBldnQpIHsgLy8gaHR0cDovL2dvby5nbC8zNTZTOTFcclxuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIFsgZXZ0LmNsaWVudFggLSByZWN0LmxlZnQsIGV2dC5jbGllbnRZIC0gcmVjdC50b3AgXVxyXG4gIH0sXHJcblxyXG4gIC8vIFNldCB0aGUgdGV4dCBmb250LCBhbGlnbiBhbmQgYmFzZWxpbmUgZHJhd2luZyBwYXJhbWV0ZXJzLlxyXG4gIC8vIE9iaiBjYW4gYmUgZWl0aGVyIGEgY2FudmFzIGNvbnRleHQgb3IgYSBET00gZWxlbWVudFxyXG4gIC8vIFNlZSBbcmVmZXJlbmNlXShodHRwOi8vZ29vLmdsL0F2RUFxKSBmb3IgZGV0YWlscy5cclxuICAvLyAqIGZvbnQgaXMgYSBIVE1ML0NTUyBzdHJpbmcgbGlrZTogXCI5cHggc2Fucy1zZXJpZlwiXHJcbiAgLy8gKiBhbGlnbiBpcyBsZWZ0IHJpZ2h0IGNlbnRlciBzdGFydCBlbmRcclxuICAvLyAqIGJhc2VsaW5lIGlzIHRvcCBoYW5naW5nIG1pZGRsZSBhbHBoYWJldGljIGlkZW9ncmFwaGljIGJvdHRvbVxyXG4gIHNldFRleHRQYXJhbXMgKG9iaiwgZm9udCwgYWxpZ24gPSAnY2VudGVyJywgYmFzZWxpbmUgPSAnbWlkZGxlJykge1xyXG4gICAgb2JqLmZvbnQgPSBmb250OyBvYmoudGV4dEFsaWduID0gYWxpZ247IG9iai50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZTtcclxuICB9LFxyXG5cclxuLy8gIyMjIE1hdGhcclxuXHJcbiAgLy8gUmV0dXJuIHJhbmRvbSBpbnQvZmxvYXQgaW4gWzAsbWF4KSBvciBbbWluLG1heCkgb3IgWy1yLzIsci8yKVxyXG4gIHJhbmRvbUludDogKG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KSxcclxuICByYW5kb21JbnQyOiAobWluLCBtYXgpID0+IG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSxcclxuICByYW5kb21GbG9hdDogKG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIG1heCxcclxuICByYW5kb21GbG9hdDI6IChtaW4sIG1heCkgPT4gbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pLFxyXG4gIHJhbmRvbUNlbnRlcmVkOiAocikgPT4gdXRpbC5yYW5kb21GbG9hdDIoLXIgLyAyLCByIC8gMiksXHJcbiAgLy8gbWluOiAoYSwgYikgPT4gKGEgPCBiKSA/IGEgOiBiLCAvLyBNYXRoLm1heC9taW4gbm93IGZhc3RlciwgeWF5IVxyXG4gIC8vIG1heDogKGEsIGIpID0+IChhIDwgYikgPyBiIDogYSxcclxuXHJcbiAgLy8gUmV0dXJuIGZsb2F0IEdhdXNzaWFuIG5vcm1hbCB3aXRoIGdpdmVuIG1lYW4sIHN0ZCBkZXZpYXRpb24uXHJcbiAgcmFuZG9tTm9ybWFsIChtZWFuID0gMC4wLCBzaWdtYSA9IDEuMCkgeyAvLyBCb3gtTXVsbGVyXHJcbiAgICBjb25zdCBbdTEsIHUyXSA9IFsxLjAgLSBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXTsgLy8gdWkgaW4gMCwxXHJcbiAgICBjb25zdCBub3JtID0gTWF0aC5zcXJ0KC0yLjAgKiBNYXRoLmxvZyh1MSkpICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUyKTtcclxuICAgIHJldHVybiBub3JtICogc2lnbWEgKyBtZWFuXHJcbiAgfSxcclxuXHJcbiAgLy8gUmV0dXJuIHdoZXRoZXIgbnVtIGlzIFtQb3dlciBvZiBUd29dKGh0dHA6Ly9nb28uZ2wvdENmZzUpLiBWZXJ5IGNsZXZlciFcclxuICBpc1Bvd2VyT2YyOiAobnVtKSA9PiAobnVtICYgKG51bSAtIDEpKSA9PT0gMCwgLy8gdHdnbCBsaWJyYXJ5XHJcbiAgLy8gUmV0dXJuIG5leHQgZ3JlYXRlciBwb3dlciBvZiB0d28uIFRoZXJlIGFyZSBmYXN0ZXIsIHNlZTpcclxuICAvLyBbU3RhY2sgT3ZlcmZsb3ddKGh0dHBzOi8vZ29vLmdsL3p2RDc4ZSlcclxuICBuZXh0UG93ZXJPZjI6IChudW0pID0+IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobnVtKSkpLFxyXG5cclxuICAvLyBUcmltcyBkZWNpbWFsIGRpZ2l0cyBvZiBmbG9hdCB0byByZWR1Y2Ugc2l6ZS5cclxuICBmaXhlZCAobiwgZGlnaXRzID0gNCkge1xyXG4gICAgY29uc3QgcCA9IE1hdGgucG93KDEwLCBkaWdpdHMpO1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQobiAqIHApIC8gcFxyXG4gIH0sXHJcblxyXG4gIC8vIEEgW21vZHVsdXNdKGh0dHA6Ly9tYXRoanMub3JnL2RvY3MvcmVmZXJlbmNlL2Z1bmN0aW9ucy9tb2QuaHRtbClcclxuICAvLyBmdW5jdGlvbiByYXRoZXIgdGhhbiAlLCB0aGUgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gIC8vIFtgKCh2ICUgbikgKyBuKSAlIG5gXShodHRwOi8vZ29vLmdsL3NwcjI0KSBhbHNvIHdvcmtzLlxyXG4gIG1vZDogKHYsIG4pID0+ICgodiAlIG4pICsgbikgJSBuLCAvLyB2IC0gbiAqIE1hdGguZmxvb3IodiAvIG4pLFxyXG4gIC8vIFdyYXAgdiBhcm91bmQgbWluLCBtYXggdmFsdWVzIGlmIHYgb3V0c2lkZSBtaW4sIG1heFxyXG4gIHdyYXA6ICh2LCBtaW4sIG1heCkgPT4gbWluICsgdXRpbC5tb2QodiAtIG1pbiwgbWF4IC0gbWluKSxcclxuICAvLyBDbGFtcCBhIG51bWJlciB0byBiZSBiZXR3ZWVuIG1pbi9tYXguXHJcbiAgLy8gTXVjaCBmYXN0ZXIgdGhhbiBNYXRoLm1heChNYXRoLm1pbih2LCBtYXgpLCBtaW4pXHJcbiAgY2xhbXAgKHYsIG1pbiwgbWF4KSB7XHJcbiAgICBpZiAodiA8IG1pbikgcmV0dXJuIG1pblxyXG4gICAgaWYgKHYgPiBtYXgpIHJldHVybiBtYXhcclxuICAgIHJldHVybiB2XHJcbiAgfSxcclxuICAvLyBSZXR1cm4gdHJ1ZSBpcyB2YWwgaW4gW21pbiwgbWF4XSBlbmNsdXNpdmVcclxuICBiZXR3ZWVuOiAodmFsLCBtaW4sIG1heCkgPT4gbWluIDw9IHZhbCAmJiB2YWwgPD0gbWF4LFxyXG5cclxuICAvLyBSZXR1cm4gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGxvIGFuZCBoaS5cclxuICAvLyBTY2FsZSBpcyBpbiBbMC0xXSwgYSBwZXJjZW50YWdlLCBhbmQgdGhlIHJlc3VsdCBpcyBpbiBbbG8saGldXHJcbiAgLy8gSWYgbG8+aGksIHNjYWxpbmcgaXMgZnJvbSBoaSBlbmQgb2YgcmFuZ2UuXHJcbiAgLy8gW1doeSB0aGUgbmFtZSBgbGVycGA/XShodHRwOi8vZ29vLmdsL1Fyek1jKVxyXG4gIGxlcnA6IChsbywgaGksIHNjYWxlKSA9PlxyXG4gICAgbG8gPD0gaGkgPyBsbyArIChoaSAtIGxvKSAqIHNjYWxlIDogbG8gLSAobG8gLSBoaSkgKiBzY2FsZSxcclxuICAvLyBDYWxjdWxhdGUgdGhlIGxlcnAgc2NhbGUgZ2l2ZW4gbG8vaGkgcGFpciBhbmQgYSBudW1iZXIgYmV0d2VlbiB0aGVtLlxyXG4gIGxlcnBTY2FsZTogKG51bWJlciwgbG8sIGhpKSA9PiAobnVtYmVyIC0gbG8pIC8gKGhpIC0gbG8pLFxyXG5cclxuLy8gIyMjIEdlb21ldHJ5XHJcblxyXG4gIC8vIERlZ3JlZXMgJiBSYWRpYW5zXHJcbiAgLy8gcmFkaWFuczogKGRlZ3JlZXMpID0+IHV0aWwubW9kKGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLCBNYXRoLlBJICogMiksXHJcbiAgLy8gZGVncmVlczogKHJhZGlhbnMpID0+IHV0aWwubW9kKHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJLCAzNjApLFxyXG4gIHJhZGlhbnM6IChkZWdyZWVzKSA9PiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MCxcclxuICBkZWdyZWVzOiAocmFkaWFucykgPT4gcmFkaWFucyAqIDE4MCAvIE1hdGguUEksXHJcbiAgLy8gSGVhZGluZyAmIEFuZ2xlczpcclxuICAvLyAqIEhlYWRpbmcgaXMgMC11cCAoeS1heGlzKSwgY2xvY2t3aXNlIGFuZ2xlIG1lYXN1cmVkIGluIGRlZ3JlZXMuXHJcbiAgLy8gKiBBbmdsZSBpcyBldWNsaWRlYW46IDAtcmlnaHQgKHgtYXhpcyksIGNvdW50ZXJjbG9ja3dpc2UgaW4gcmFkaWFuc1xyXG4gIGhlYWRpbmcgKHJhZGlhbnMpIHsgLy8gYW5nbGVUb0hlYWRpbmc/XHJcbiAgICBjb25zdCBkZWdyZWVzID0gdGhpcy5kZWdyZWVzKHJhZGlhbnMpO1xyXG4gICAgcmV0dXJuIHRoaXMubW9kKCg5MCAtIGRlZ3JlZXMpLCAzNjApXHJcbiAgfSxcclxuICBhbmdsZSAoaGVhZGluZykgeyAvLyBoZWFkaW5nVG9BbmdsZT9cclxuICAgIGNvbnN0IGRlZ3JlZXMgPSB0aGlzLm1vZCgzNjAgLSBoZWFkaW5nLCAzNjApO1xyXG4gICAgcmV0dXJuIHRoaXMucmFkaWFucyhkZWdyZWVzKVxyXG4gIH0sXHJcbiAgLy8gUmV0dXJuIGFuZ2xlIChyYWRpYW5zKSBpbiAoLXBpLHBpXSB0aGF0IGFkZGVkIHRvIHJhZDAgPSByYWQxXHJcbiAgLy8gU2VlIE5ldExvZ28ncyBbc3VidHJhY3QtaGVhZGluZ3NdKGh0dHA6Ly9nb28uZ2wvQ2pvSHVWKSBmb3IgZXhwbGFuYXRpb25cclxuICBzdWJ0cmFjdFJhZGlhbnMgKHJhZDEsIHJhZDApIHtcclxuICAgIGxldCBkciA9IHRoaXMubW9kKHJhZDEgLSByYWQwLCAyICogTWF0aC5QSSk7XHJcbiAgICBpZiAoZHIgPiBNYXRoLlBJKSBkciA9IGRyIC0gMiAqIE1hdGguUEk7XHJcbiAgICByZXR1cm4gZHJcclxuICB9LFxyXG4gIC8vIEFib3ZlIHVzaW5nIGhlYWRpbmdzIChkZWdyZWVzKSByZXR1cm5pbmcgZGVncmVlcyBpbiAoLTE4MCwgMTgwXVxyXG4gIHN1YnRyYWN0SGVhZGluZ3MgKGRlZzEsIGRlZzApIHtcclxuICAgIGxldCBkQW5nbGUgPSB0aGlzLm1vZChkZWcxIC0gZGVnMCwgMzYwKTtcclxuICAgIGlmIChkQW5nbGUgPiAxODApIGRBbmdsZSA9IGRBbmdsZSAtIDM2MDtcclxuICAgIHJldHVybiBkQW5nbGVcclxuICB9LFxyXG4gIC8vIFJldHVybiBhbmdsZSBpbiBbLXBpLHBpXSByYWRpYW5zIGZyb20gKHgseSkgdG8gKHgxLHkxKVxyXG4gIC8vIFtTZWU6IE1hdGguYXRhbjJdKGh0dHA6Ly9nb28uZ2wvSlM4REYpXHJcbiAgcmFkaWFuc1Rvd2FyZDogKHgsIHksIHgxLCB5MSkgPT4gTWF0aC5hdGFuMih5MSAtIHksIHgxIC0geCksXHJcbiAgLy8gQWJvdmUgdXNpbmcgaGVhZGluZ3MgKGRlZ3JlZXMpIHJldHVybmluZyBkZWdyZWVzIGluIFstOTAsIDkwXVxyXG4gIGhlYWRpbmdUb3dhcmQgKHgsIHksIHgxLCB5MSkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGVhZGluZyh0aGlzLnJhZGlhbnNUb3dhcmQoeCwgeSwgeDEsIHkxKSlcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm4gZGlzdGFuY2UgYmV0d2VlbiAoeCwgeSksICh4MSwgeTEpXHJcbiAgZGlzdGFuY2U6ICh4LCB5LCB4MSwgeTEpID0+IE1hdGguc3FydCh1dGlsLnNxRGlzdGFuY2UoeCwgeSwgeDEsIHkxKSksXHJcbiAgLy8gUmV0dXJuIGRpc3RhbmNlIGJldHdlZW4gKHgsIHkpLCAoeDEsIHkxKVxyXG4gIGh5cG90OiAoeCwgeSwgeDEsIHkxKSA9PiBNYXRoLmh5cG90KHggLSB4MSwgeSAtIHkxKSxcclxuICAvLyBSZXR1cm4gc3F1YXJlZCBkaXN0YW5jZSAuLiBpLmUuIGF2b2lkIE1hdGguc3FydC4gRmFzdGVyIGNvbXBhcmlzb25zXHJcbiAgc3FEaXN0YW5jZTogKHgsIHksIHgxLCB5MSkgPT4gKHggLSB4MSkgKiAoeCAtIHgxKSArICh5IC0geTEpICogKHkgLSB5MSksXHJcbiAgLy8gUmV0dXJuIHRydWUgaWYgeCx5IGlzIHdpdGhpbiBjb25lLlxyXG4gIC8vIENvbmU6IG9yaWdpbiB4MCx5MCBpbiBnaXZlbiBkaXJlY3Rpb24sIHdpdGggY29uZUFuZ2xlIHdpZHRoIGluIHJhZGlhbnMuXHJcbiAgLy8gQWxsIGFuZ2xlcyBpbiByYWRpYW5zXHJcbiAgaW5Db25lICh4LCB5LCByYWRpdXMsIGNvbmVBbmdsZSwgZGlyZWN0aW9uLCB4MCwgeTApIHtcclxuICAgIGlmICh0aGlzLnNxRGlzdGFuY2UoeDAsIHkwLCB4LCB5KSA+IChyYWRpdXMgKiByYWRpdXMpKSByZXR1cm4gZmFsc2VcclxuICAgIGNvbnN0IGFuZ2xlMTIgPSB0aGlzLnJhZGlhbnNUb3dhcmQoeDAsIHkwLCB4LCB5KTsgLy8gYW5nbGUgZnJvbSAxIHRvIDJcclxuICAgIHJldHVybiBjb25lQW5nbGUgLyAyID49IE1hdGguYWJzKHRoaXMuc3VidHJhY3RSYWRpYW5zKGRpcmVjdGlvbiwgYW5nbGUxMikpXHJcbiAgfSxcclxuXHJcbi8vICMjIyBBcnJheXMsIE9iamVjdHMgYW5kIEl0ZXJhdGlvblxyXG5cclxuICAvLyBSZXBlYXQgZnVuY3Rpb24gZihpLCBhKSBuIHRpbWVzLCBpIGluIDAsIG4tMSwgYSBpcyBvcHRpb25hbCBhcnJheVxyXG4gIHJlcGVhdCAobiwgZiwgYSA9IFtdKSB7IGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSBmKGksIGEpOyByZXR1cm4gYSB9LFxyXG4gIC8vIFJlcGVhdCBmdW5jdGlvbiBuL3N0ZXAgdGltZXMsIGluY3JlbWVudGluZyBpIGJ5IHN0ZXAgZWFjaCBzdGVwLlxyXG4gIHN0ZXAgKG4sIHN0ZXAsIGYpIHsgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IHN0ZXApIGYoaSk7IH0sXHJcbiAgLy8gUmV0dXJuIHJhbmdlIFswLCBsZW5ndGgtMV0uIE5vdGU6IDZ4IGZhc3RlciB0aGFuIEFycmF5LmZyb20hXHJcbiAgcmFuZ2UgKGxlbmd0aCkgeyByZXR1cm4gdGhpcy5yZXBlYXQobGVuZ3RoLCAoaSwgYSkgPT4geyBhW2ldID0gaTsgfSkgfSxcclxuICAvLyByYW5nZSAobGVuZ3RoKSB7IHJldHVybiB0aGlzLnJlcGVhdChsZW5ndGgsIChpLCBhKSA9PiB7IGFbaV0gPSBpIH0sIFtdKSB9LFxyXG5cclxuICAvLyBSZXR1cm4ga2V5IGZvciAoZmlyc3QpIGdpdmVuIHZhbHVlIGluIG9iamVjdCwgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAga2V5Rm9yVmFsdWUgKG9iaiwgdmFsdWUpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iailcclxuICAgICAgaWYgKG9ialtrZXldID09PSB2YWx1ZSkgLy8gIGdsIHByb2JsZW1zOiAmJiBvYmouaGFzT3duUHJvcGVydHkoa2V5KVxyXG4gICAgICAgIHJldHVybiBrZXlcclxuICAgIHJldHVybiBudWxsXHJcbiAgfSxcclxuXHJcbiAgLy8gRXhlY3V0ZSBmY24gZm9yIGFsbCBvd24gbWVtYmVyIG9mIGFuIG9iaiBvciBhcnJheSAodHlwZWQgT0spLlxyXG4gIC8vIFJldHVybiBpbnB1dCBhcnJheU9yT2JqLCB0cmFuc2Zvcm1lZCBieSBmY24uXHJcbiAgLy8gLSBVbmxpa2UgZm9yRWFjaCwgZG9lcyBub3Qgc2tpcCB1bmRlZmluZXMuXHJcbiAgLy8gLSBMaWtlIG1hcCwgZm9yRWFjaCwgZXRjLCBmY24gPSBmY24oaXRlbSwga2V5L2luZGV4LCBvYmopLlxyXG4gIC8vIC0gQWx0ZXJuYXRpdmVzIGFyZTogYGZvci4ub2ZgLCBhcnJheSBtYXAsIHJlZHVjZSwgZmlsdGVyIGV0Y1xyXG4gIGZvckVhY2ggKGFycmF5T3JPYmosIGZjbikge1xyXG4gICAgaWYgKGFycmF5T3JPYmouc2xpY2UpIC8vIHR5cGVkICYgc3RkIGFycmF5c1xyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyYXlPck9iai5sZW5ndGg7IGkgPCBsZW47IGkrKylcclxuICAgICAgICBmY24oYXJyYXlPck9ialtpXSwgaSwgYXJyYXlPck9iaik7XHJcbiAgICBlbHNlIC8vIG9ialxyXG4gICAgICBPYmplY3Qua2V5cyhhcnJheU9yT2JqKS5mb3JFYWNoKChrKSA9PiBmY24oYXJyYXlPck9ialtrXSwgaywgYXJyYXlPck9iaikpO1xyXG4gICAgcmV0dXJuIGFycmF5T3JPYmpcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm4gYSBuZXcgc2hhbGxvdyBvZiBhcnJheSwgZWl0aGVyIEFycmF5IG9yIFR5cGVkQXJyYXlcclxuICBjb3B5QXJyYXkgKGFycmF5KSB7IHJldHVybiBhcnJheS5zbGljZSgwKSB9LFxyXG5cclxuICAvLyBSZXR1cm4gYSBuZXcgYXJyYXkgdGhhdCBpcyB0aGUgY29uY2F0aW5hdGlvbiB0d28gYXJyYXlzLlxyXG4gIC8vIFRoZSByZXN1bHRpbmcgVHlwZSBpcyB0aGF0IG9mIHRoZSBmaXJzdCBhcnJheS5cclxuICBjb25jYXRBcnJheXMgKGFycmF5MSwgYXJyYXkyKSB7XHJcbiAgICBjb25zdCBUeXBlID0gYXJyYXkxLmNvbnN0cnVjdG9yO1xyXG4gICAgaWYgKFR5cGUgPT09IEFycmF5KVxyXG4gICAgICByZXR1cm4gYXJyYXkxLmNvbmNhdCh0aGlzLmNvbnZlcnRBcnJheShhcnJheTIsIEFycmF5KSlcclxuICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGUoYXJyYXkxLmxlbmd0aCArIGFycmF5Mi5sZW5ndGgpO1xyXG4gICAgLy8gTk9URTogdHlwZWRBcnJheS5zZXQoKSBhbGxvd3MgYW55IEFycmF5IG9yIFR5cGVkQXJyYXkgYXJnXHJcbiAgICBhcnJheS5zZXQoYXJyYXkxKTsgYXJyYXkuc2V0KGFycmF5MiwgYXJyYXkxLmxlbmd0aCk7XHJcbiAgICByZXR1cm4gYXJyYXlcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm4gYW4gYXJyYXkgd2l0aCBubyBzdWItYXJyYXkgZWxlbWVudHNcclxuICBmbGF0dGVuIChhcnJheSkge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5WzBdKSkgcmV0dXJuIGFycmF5XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGFycmF5LmZvckVhY2goKGEpID0+IHJlc3VsdC5wdXNoKC4uLmEpKTtcclxuICAgIHJldHVybiB0aGlzLmZsYXR0ZW4ocmVzdWx0KVxyXG4gIH0sXHJcblxyXG4gIC8vIFJldHVybiBhcnJheSdzIHR5cGUgKEFycmF5IG9yIFR5cGVkQXJyYXkgdmFyaWFudClcclxuICBhcnJheVR5cGUgKGFycmF5KSB7IHJldHVybiBhcnJheS5jb25zdHJ1Y3RvciB9LFxyXG5cclxuICAvLyBSZXR1cm4gYSBuZXcgSmF2YVNjcmlwdCBBcnJheSBvZiBmbG9hdHMvc3RyaW5ncyB0byBhIGdpdmVuIHByZWNpc2lvbi5cclxuICAvLyBGYWlscyBmb3IgRmxvYXQzMkFycmF5IGR1ZSB0byBmbG9hdDY0LT4zMiBhcnRpZmlhY3RzLCB0aHVzIEFycmF5IGNvbnZlcnNpb25cclxuICBmaXhlZEFycmF5IChhcnJheSwgZGlnaXRzID0gNCkge1xyXG4gICAgYXJyYXkgPSB0aGlzLmNvbnZlcnRBcnJheShhcnJheSwgQXJyYXkpOyAvLyA2NCBiaXQgcm91bmRpbmdcclxuICAgIHJldHVybiBhcnJheS5tYXAoKG4pID0+IHRoaXMuZml4ZWQobiwgZGlnaXRzKSlcclxuICB9LFxyXG5cclxuICAvLyBTaGFsbG93IGNsb25lIG9mIG9iaiBvciBhcnJheVxyXG4gIGNsb25lIChvYmopIHtcclxuICAgIGlmIChvYmouc2xpY2UpIHJldHVybiBvYmouc2xpY2UoMCkgLy8gb2sgZm9yIFR5cGVkQXJyYXlzXHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4geyByZXN1bHRba10gPSBvYmpba107IH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH0sXHJcblxyXG4gIC8vIFtEZWVwIGNsb25lXShodHRwOi8vZ29vLmdsL01JYVR4VSkgYW4gb2JqIG9yIGFycmF5LiBDbGV2ZXIhXHJcbiAgZGVlcENsb25lOiAob2JqKSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpLFxyXG4gIC8vIENvbXBhcmUgT2JqZWN0cyBvciBBcnJheXMgdmlhIEpTT04gc3RyaW5nLiBOb3RlOiBUeXBlZEFycmF5cyAhPT0gQXJyYXlzXHJcbiAgb2JqZWN0c0VxdWFsOiAoYSwgYikgPT4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpLFxyXG4gIC8vIFVzZSBKU09OIHRvIHJldHVybiBwcmV0dHksIHByaW50YWJsZSBzdHJpbmcgb2YgYW4gb2JqZWN0LCBhcnJheSwgb3RoZXJcclxuICAvLyBSZW1vdmUgXCJcInMgYXJvdW5kIGtleXMuXHJcbiAgb2JqZWN0VG9TdHJpbmcgKG9iaikge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgJyAgJylcclxuICAgICAgLnJlcGxhY2UoLyB7Mn1cIi9nLCAnICAnKVxyXG4gICAgICAucmVwbGFjZSgvXCI6IC9nLCAnOiAnKVxyXG4gIH0sXHJcbiAgLy8gTGlrZSBhYm92ZSwgYnV0IGEgc2luZ2xlIGxpbmUgZm9yIHNtYWxsIG9iamVjdHMuXHJcbiAgb2JqZWN0VG9TdHJpbmcxIChvYmopIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopXHJcbiAgICAgIC5yZXBsYWNlKC97XCIvZywgJ3snKVxyXG4gICAgICAucmVwbGFjZSgvLFwiL2csICcsJylcclxuICAgICAgLnJlcGxhY2UoL1wiOi9nLCAnOicpXHJcbiAgfSxcclxuXHJcbiAgLy8gQ3JlYXRlIHJhbmRvbSBhcnJheSBvZiBmbG9hdHMgYmV0d2VlbiBtaW4vbWF4LlxyXG4gIC8vIEFycmF5IFR5cGUgYWxsb3dzIGNvbnZlcnNpb24gdG8gRmxvYXQzMkFycmF5IG9yIGludGVnZXJzIChJbnQzMkFycmF5IGV0YylcclxuICByYW5kb21BcnJheSAobGVuZ3RoLCBtaW4gPSAwLCBtYXggPSAxLCBUeXBlID0gQXJyYXkpIHtcclxuICAgIGNvbnN0IGEgPSBuZXcgVHlwZShsZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcclxuICAgICAgYVtpXSA9IHRoaXMucmFuZG9tRmxvYXQyKG1pbiwgbWF4KTtcclxuICAgIHJldHVybiBhXHJcbiAgfSxcclxuXHJcbiAgLy8gQ3JlYXRlIGEgaGlzdG9ncmFtLCBnaXZlbiBhbiBhcnJheSwgYSBiaW4gc2l6ZSwgYW5kIGFcclxuICAvLyBtaW4gYmluIGRlZmF1bHRpbmcgdG8gbWluIG9mIG9mIHRoZSBhcnJheS5cclxuICAvLyBSZXR1cm4gYW4gb2JqZWN0IHdpdGg6XHJcbiAgLy8gLSBtaW4vbWF4QmluOiB0aGUgZmlyc3QvbGFzdCBiaW4gd2l0aCBkYXRhXHJcbiAgLy8gLSBtaW4vbWF4VmFsOiB0aGUgbWluL21heCB2YWx1ZXMgaW4gdGhlIGFycmF5XHJcbiAgLy8gLSBiaW5zOiB0aGUgbnVtYmVyIG9mIGJpbnNcclxuICAvLyAtIGhpc3Q6IHRoZSBhcnJheSBvZiBiaW5zXHJcbiAgaGlzdG9ncmFtIChhcnJheSwgYmluID0gMSwgbWluID0gTWF0aC5mbG9vcih0aGlzLmFycmF5TWluKGFycmF5KSkpIHtcclxuICAgIGNvbnN0IGhpc3QgPSBbXTtcclxuICAgIGxldCBbbWluQmluLCBtYXhCaW5dID0gW051bWJlci5NQVhfVkFMVUUsIE51bWJlci5NSU5fVkFMVUVdO1xyXG4gICAgbGV0IFttaW5WYWwsIG1heFZhbF0gPSBbTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1JTl9WQUxVRV07XHJcbiAgICBmb3IgKGNvbnN0IGEgb2YgYXJyYXkpIHtcclxuICAgICAgY29uc3QgaSA9IE1hdGguZmxvb3IoYSAvIGJpbikgLSBtaW47XHJcbiAgICAgIGhpc3RbaV0gPSAoaGlzdFtpXSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBoaXN0W2ldICsgMTtcclxuICAgICAgbWluQmluID0gTWF0aC5taW4obWluQmluLCBpKTtcclxuICAgICAgbWF4QmluID0gTWF0aC5tYXgobWF4QmluLCBpKTtcclxuICAgICAgbWluVmFsID0gTWF0aC5taW4obWluVmFsLCBhKTtcclxuICAgICAgbWF4VmFsID0gTWF0aC5tYXgobWF4VmFsLCBhKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgaSBpbiBoaXN0KVxyXG4gICAgICBpZiAoaGlzdFtpXSA9PT0gdW5kZWZpbmVkKSB7IGhpc3RbaV0gPSAwOyB9XHJcbiAgICBjb25zdCBiaW5zID0gbWF4QmluIC0gbWluQmluICsgMTtcclxuICAgIHJldHVybiB7IGJpbnMsIG1pbkJpbiwgbWF4QmluLCBtaW5WYWwsIG1heFZhbCwgaGlzdCB9XHJcbiAgfSxcclxuXHJcbiAgLy8gUmV0dXJuIHNjYWxhciBtYXgvbWluL3N1bS9hdmcgb2YgbnVtZXJpYyBBcnJheSBvciBUeXBlZEFycmF5LlxyXG4gIGFycmF5TWF4OiAoYXJyYXkpID0+IGFycmF5LnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYikpLFxyXG4gIGFycmF5TWluOiAoYXJyYXkpID0+IGFycmF5LnJlZHVjZSgoYSwgYikgPT4gTWF0aC5taW4oYSwgYikpLFxyXG4gIGFycmF5U3VtOiAoYXJyYXkpID0+IGFycmF5LnJlZHVjZSgoYSwgYikgPT4gYSArIGIpLFxyXG4gIGFycmF5QXZnOiAoYXJyYXkpID0+IHV0aWwuYXJyYXlTdW0oYXJyYXkpIC8gYXJyYXkubGVuZ3RoLFxyXG4gIC8vIFJldHVybiByYW5kb20gb25lIG9mIGFycmF5IGl0ZW1zLiBObyBhcnJheS5sZW5ndGggdGVzdHNcclxuICBvbmVPZjogKGFycmF5KSA9PiBhcnJheVt1dGlsLnJhbmRvbUludChhcnJheS5sZW5ndGgpXSxcclxuICBvdGhlck9uZU9mIChhcnJheSwgaXRlbSkge1xyXG4gICAgZG8geyB2YXIgb3RoZXIgPSB0aGlzLm9uZU9mKGFycmF5KTsgfSB3aGlsZSAoaXRlbSA9PT0gb3RoZXIpIC8vIG5vdGUgdmFyIHVzZVxyXG4gICAgcmV0dXJuIG90aGVyXHJcbiAgfSxcclxuICAvLyBDcmVhdGUgYW4gYXJyYXkgb2YgcHJvcGVydGllcyBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHNcclxuICBhcnJheVByb3BzOiAoYXJyYXksIHByb3BOYW1lKSA9PiBhcnJheS5tYXAoKGEpID0+IGFbcHJvcE5hbWVdKSxcclxuICAvLyBSYW5kb20ga2V5L3ZhbCBvZiBvYmplY3RcclxuICBvbmVLZXlPZjogKG9iaikgPT4gdXRpbC5vbmVPZihPYmplY3Qua2V5cyhvYmopKSxcclxuICBvbmVWYWxPZjogKG9iaikgPT4gb2JqW3V0aWwub25lS2V5T2Yob2JqKV0sXHJcblxyXG4gIC8vIFlvdSdkIHRoaW5rIHRoaXMgd2Fzbid0IG5lY2Vzc2FyeSwgYnV0IEkgYWx3YXlzIGZvcmdldC4gRGFtbi5cclxuICAvLyBOT1RFOiB0aGlzLCBsaWtlIHNvcnQsIHNvcnRzIGluIHBsYWNlLiBDbG9uZSBhcnJheSBpZiBuZWVkZWQuXHJcbiAgc29ydE51bXMgKGFycmF5LCBhc2NlbmRpbmcgPSB0cnVlKSB7XHJcbiAgICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4gYXNjZW5kaW5nID8gYSAtIGIgOiBiIC0gYSlcclxuICB9LFxyXG4gIC8vIFNvcnQgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3LyBmY24ob2JqKSBhcyBjb21wYXJlRnVuY3Rpb24uXHJcbiAgLy8gSWYgZmNuIGlzIGEgc3RyaW5nLCBjb252ZXJ0IHRvIHByb3BGY24uXHJcbiAgc29ydE9ianMgKGFycmF5LCBmY24sIGFzY2VuZGluZyA9IHRydWUpIHtcclxuICAgIGlmICh0eXBlb2YgZmNuID09PSAnc3RyaW5nJykgZmNuID0gdGhpcy5wcm9wRmNuKGZjbik7XHJcbiAgICBjb25zdCBjb21wID0gKGEsIGIpID0+IGZjbihhKSAtIGZjbihiKTtcclxuICAgIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiBhc2NlbmRpbmcgPyBjb21wKGEsIGIpIDogLWNvbXAoYSwgYikpXHJcbiAgfSxcclxuICAvLyBSYW5kb21pemUgYXJyYXkgaW4tcGxhY2UuIFVzZSBjbG9uZSgpIGZpcnN0IGlmIG5ldyBhcnJheSBuZWVkZWRcclxuICAvLyBUaGUgYXJyYXkgaXMgcmV0dXJuZWQgZm9yIGNoYWluaW5nOyBzYW1lIGFzIGlucHV0IGFycmF5LlxyXG4gIC8vIFNlZSBbRHVyc3RlbmZlbGQgLyBGaXNoZXItWWF0ZXMtS251dGggc2h1ZmZsZV0oaHR0cHM6Ly9nb28uZ2wvbWZiZFBoKVxyXG4gIHNodWZmbGUgKGFycmF5KSB7XHJcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG4gICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XHJcbiAgICAgIGNvbnN0IHRlbXAgPSBhcnJheVtpXTtcclxuICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcclxuICAgICAgYXJyYXlbal0gPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5XHJcbiAgfSxcclxuICAvLyBSZXR1cm5zIG5ldyBhcnJheSAob2YgdGhpcyB0eXBlKSBvZiB1bmlxdWUgZWxlbWVudHMgaW4gdGhpcyAqc29ydGVkKiBhcnJheS5cclxuICAvLyBTb3J0IG9yIGNsb25lICYgc29ydCBpZiBuZWVkZWQuXHJcbiAgdW5pcSAoYXJyYXksIGYgPSB0aGlzLmlkZW50aXR5KSB7XHJcbiAgICBpZiAodGhpcy5pc1N0cmluZyhmKSkgZiA9IHRoaXMucHJvcEZjbihmKTtcclxuICAgIHJldHVybiBhcnJheS5maWx0ZXIoKGFpLCBpLCBhKSA9PiAoaSA9PT0gMCkgfHwgKGYoYWkpICE9PSBmKGFbaSAtIDFdKSkpXHJcbiAgfSxcclxuICAvLyB1bmlxdWUgPSAoYXJyYXkpID0+IFsuLi5uZXcgU2V0KGFycmF5KV0sXHJcblxyXG4gIC8vIEJpbmFyeSBzZWFyY2g6XHJcbiAgLy8gUmV0dXJuIGFycmF5IGluZGV4IG9mIGl0ZW0sIHdoZXJlIGFycmF5IGlzIHNvcnRlZC5cclxuICAvLyBJZiBpdGVtIG5vdCBmb3VuZCwgcmV0dXJuIGluZGV4IGZvciBpdGVtIGZvciBhcnJheSB0byByZW1haW4gc29ydGVkLlxyXG4gIC8vIGYgaXMgdXNlZCB0byByZXR1cm4gYW4gaW50ZWdlciBmb3Igc29ydGluZywgZGVmYXVsdHMgdG8gaWRlbnRpdHkuXHJcbiAgLy8gSWYgZiBpcyBhIHN0cmluZywgaXQgaXMgdGhlIG9iamVjdCBwcm9wZXJ0eSB0byBzb3J0IGJ5LlxyXG4gIC8vIEFkYXB0ZWQgZnJvbSB1bmRlcnNjb3JlJ3MgXy5zb3J0ZWRJbmRleC5cclxuICBzb3J0ZWRJbmRleCAoYXJyYXksIGl0ZW0sIGYgPSB0aGlzLmlkZW50aXR5KSB7XHJcbiAgICBpZiAodGhpcy5pc1N0cmluZyhmKSkgZiA9IHRoaXMucHJvcEZjbihmKTtcclxuICAgIGNvbnN0IHZhbHVlID0gZihpdGVtKTtcclxuICAgIC8vIFdoeSBub3QgYXJyYXkubGVuZ3RoIC0gMT8gQmVjYXVzZSB3ZSBjYW4gaW5zZXJ0IDEgYWZ0ZXIgZW5kIG9mIGFycmF5LlxyXG4gICAgLy8gbGV0IFtsb3csIGhpZ2hdID0gWzAsIGFycmF5Lmxlbmd0aF1cclxuICAgIGxldCBsb3cgPSAwO1xyXG4gICAgbGV0IGhpZ2ggPSBhcnJheS5sZW5ndGg7XHJcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xyXG4gICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7IC8vIGZsb29yIChsb3craGlnaCkvMlxyXG4gICAgICBpZiAoZihhcnJheVttaWRdKSA8IHZhbHVlKSB7IGxvdyA9IG1pZCArIDE7IH0gZWxzZSB7IGhpZ2ggPSBtaWQ7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBsb3dcclxuICB9LFxyXG4gIC8vIFJldHVybiBpbmRleCBvZiB2YWx1ZSBpbiBhcnJheSB3aXRoIGdpdmVuIHByb3BlcnR5IG9yIC0xIGlmIG5vdCBmb3VuZC5cclxuICAvLyBCaW5hcnkgc2VhcmNoIGlmIHByb3BlcnR5IGlzbnQgbnVsbFxyXG4gIC8vIFByb3BlcnR5IGNhbiBiZSBzdHJpbmcgb3IgZnVuY3Rpb24uXHJcbiAgLy8gVXNlIHByb3BlcnR5ID0gaWRlbnRpdHkgdG8gY29tcGFyZSBvYmpzIGRpcmVjdGx5LlxyXG4gIGluZGV4T2YgKGFycmF5LCBpdGVtLCBwcm9wZXJ0eSkge1xyXG4gICAgaWYgKCFwcm9wZXJ0eSkgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSlcclxuICAgIGNvbnN0IGkgPSB0aGlzLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtLCBwcm9wZXJ0eSk7XHJcbiAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTFcclxuICB9LFxyXG4gIC8vIFRydWUgaWYgaXRlbSBpcyBpbiBhcnJheS4gQmluYXJ5IHNlYXJjaCBpZiBmIGdpdmVuXHJcbiAgY29udGFpbnMgKGFycmF5LCBpdGVtLCBmKSB7IHJldHVybiB0aGlzLmluZGV4T2YoYXJyYXksIGl0ZW0sIGYpID49IDAgfSxcclxuICAvLyBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LiBCaW5hcnkgc2VhcmNoIGlmIGYgZ2l2ZW5cclxuICAvLyBBcnJheSB1bmNoYW5nZWQgaWYgaXRlbSBub3QgZm91bmQuXHJcbiAgcmVtb3ZlSXRlbSAoYXJyYXksIGl0ZW0sIGYpIHtcclxuICAgIGNvbnN0IGkgPSB0aGlzLmluZGV4T2YoYXJyYXksIGl0ZW0sIGYpO1xyXG4gICAgaWYgKGkgIT09IC0xKSBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICBlbHNlIHRoaXMud2FybihgdXRpbC5yZW1vdmVJdGVtOiAke2l0ZW19IG5vdCBpbiBhcnJheSAke2FycmF5LmNvbnN0cnVjdG9yLm5hbWV9YCk7XHJcbiAgICAvLyBlbHNlIHRocm93IEVycm9yKGB1dGlsLnJlbW92ZUl0ZW06IGl0ZW0gJHtpdGVtfSBub3QgaW4gYXJyYXkgJHthcnJheX1gKVxyXG4gIH0sXHJcbiAgLy8gSW5zZXJ0IGFuIGl0ZW0gaW4gYSBzb3J0ZWQgYXJyYXlcclxuICBpbnNlcnRJdGVtIChhcnJheSwgaXRlbSwgZikge1xyXG4gICAgY29uc3QgaSA9IHRoaXMuc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0sIGYpO1xyXG4gICAgaWYgKGFycmF5W2ldID09PSBpdGVtKSB0aGlzLmVycm9yKCdpbnNlcnRJdGVtOiBpdGVtIGFscmVhZHkgaW4gYXJyYXknKTtcclxuICAgIGFycmF5LnNwbGljZShpLCAwLCBpdGVtKTsgLy8gY29weVdpdGhpbj9cclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm4gYXJyYXkgY29tcG9zZWQgb2YgZihhMWksIGEyaSkgY2FsbGVkIHBhaXJ3aXNlIG9uIGJvdGggYXJyYXlzXHJcbiAgYVBhaXJ3aXNlOiAoYTEsIGEyLCBmKSA9PiBhMS5tYXAoKHZhbCwgaSkgPT4gZih2YWwsIGEyW2ldKSksXHJcbiAgYXJyYXlzQWRkOiAoYTEsIGEyKSA9PiB1dGlsLmFQYWlyd2lzZShhMSwgYTIsIChhLCBiKSA9PiBhICsgYiksXHJcbiAgYXJyYXlzU3ViOiAoYTEsIGEyKSA9PiB1dGlsLmFQYWlyd2lzZShhMSwgYTIsIChhLCBiKSA9PiBhIC0gYiksXHJcbiAgYXJyYXlzTXVsOiAoYTEsIGEyKSA9PiB1dGlsLmFQYWlyd2lzZShhMSwgYTIsIChhLCBiKSA9PiBhICogYiksXHJcbiAgYXJyYXlzRXF1YWw6IChhMSwgYTIpID0+IHV0aWwuYXJyYXlzU3ViKGExLCBhMikuZXZlcnkoKGEpID0+IGEgPT09IDApLFxyXG5cclxuICAvLyBSZXR1cm4gYSBcInJhbXBcIiAoYXJyYXkgb2YgdW5pZm9ybWx5IGFzY2VuZGluZy9kZXNjZW5kaW5nIGZsb2F0cylcclxuICAvLyBpbiBbc3RhcnQsc3RvcF0gd2l0aCBudW1JdGVtcyAocG9zaXRpdmUgaW50ZWdlciA+IDEpLlxyXG4gIC8vIE9LIGZvciBzdGFydD5zdG9wLiBXaWxsIGFsd2F5cyBpbmNsdWRlIHN0YXJ0L3N0b3Agdy9pbiBmbG9hdCBhY2N1cmFjeS5cclxuICBhUmFtcCAoc3RhcnQsIHN0b3AsIG51bUl0ZW1zKSB7XHJcbiAgICAvLyBOT1RFOiBzdGFydCArIHN0ZXAqaSwgd2hlcmUgc3RlcCBpcyAoc3RvcC1zdGFydCkvKG51bUl0ZW1zLTEpLFxyXG4gICAgLy8gaGFzIGZsb2F0IGFjY3VyYWN5IHByb2JsZW1zLCBtdXN0IHJlY2FsYyBzdGVwIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAgaWYgKG51bUl0ZW1zIDw9IDEpIHRoaXMuZXJyb3IoJ2FSYW1wOiBudW1JdGVtcyBtdXN0IGJlID4gMScpO1xyXG4gICAgY29uc3QgYSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JdGVtczsgaSsrKVxyXG4gICAgICBhLnB1c2goc3RhcnQgKyAoc3RvcCAtIHN0YXJ0KSAqIChpIC8gKG51bUl0ZW1zIC0gMSkpKTtcclxuICAgIHJldHVybiBhXHJcbiAgfSxcclxuICAvLyBJbnRlZ2VyIHZlcnNpb24gb2YgYVJhbXAsIHN0YXJ0ICYgc3RvcCBpbnRlZ2Vycywgcm91bmRpbmcgZWFjaCBlbGVtZW50LlxyXG4gIC8vIERlZmF1bHQgbnVtSXRlbXMgeWllbGRzIHVuaXQgc3RlcCBiZXR3ZWVuIHN0YXJ0ICYgc3RvcC5cclxuICBhSW50UmFtcCAoc3RhcnQsIHN0b3AsIG51bUl0ZW1zID0gKE1hdGguYWJzKHN0b3AgLSBzdGFydCkgKyAxKSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYVJhbXAoc3RhcnQsIHN0b3AsIG51bUl0ZW1zKS5tYXAoKGEpID0+IE1hdGgucm91bmQoYSkpXHJcbiAgfSxcclxuXHJcbiAgLy8gUmV0dXJuIGFuIGFycmF5IG5vcm1hbGl6ZWQgKGxlcnApIGJldHdlZW4gbG8vaGkgdmFsdWVzXHJcbiAgbm9ybWFsaXplIChhcnJheSwgbG8gPSAwLCBoaSA9IDEpIHtcclxuICAgIGNvbnN0IFttaW4sIG1heF0gPSBbdGhpcy5hcnJheU1pbihhcnJheSksIHRoaXMuYXJyYXlNYXgoYXJyYXkpXTtcclxuICAgIGNvbnN0IHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xyXG4gICAgcmV0dXJuIGFycmF5Lm1hcCgobikgPT4gdGhpcy5sZXJwKGxvLCBoaSwgc2NhbGUgKiAoKG4pIC0gbWluKSkpXHJcbiAgfSxcclxuICAvLyBSZXR1cm4gVWludDhDbGFtcGVkQXJyYXkgbm9ybWFsaXplZCBpbiAwLTI1NVxyXG4gIG5vcm1hbGl6ZTggKGFycmF5KSB7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMubm9ybWFsaXplKGFycmF5LCAtMC41LCAyNTUuNSkpXHJcbiAgfSxcclxuICAvLyBSZXR1cm4gQXJyYXkgbm9ybWFsaXplZCB0byBpbnRlZ2VycyBpbiBsby1oaVxyXG4gIG5vcm1hbGl6ZUludCAoYXJyYXksIGxvLCBoaSkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKGFycmF5LCBsbywgaGkpLm1hcCgobikgPT4gTWF0aC5yb3VuZChuKSlcclxuICB9LFxyXG5cclxuLy8gIyMjIEFzeW5jXHJcblxyXG4gIC8vIFJldHVybiBQcm9taXNlIGZvciBnZXR0aW5nIGFuIGltYWdlLlxyXG4gIC8vIC0gdXNlOiBpbWFnZVByb21pc2UoJy4vcGF0aC90by9pbWcnKS50aGVuKGltZyA9PiBpbWFnZUZjbihpbWcpKVxyXG4gIGltYWdlUHJvbWlzZSAodXJsKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XHJcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltZyk7XHJcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KEVycm9yKGBDb3VsZCBub3QgbG9hZCBpbWFnZSAke3VybH1gKSk7XHJcbiAgICAgIGltZy5zcmMgPSB1cmw7XHJcbiAgICB9KVxyXG4gIH0sXHJcbiAgLy8gUmV0dXJuIFByb21pc2UgZm9yIGFqYXgveGhyIGRhdGEuXHJcbiAgLy8gLSB0eXBlOiAnYXJyYXlidWZmZXInLCAnYmxvYicsICdkb2N1bWVudCcsICdqc29uJywgJ3RleHQnLlxyXG4gIC8vIC0gbWV0aG9kOiAnR0VUJywgJ1BPU1QnXHJcbiAgLy8gLSB1c2U6IHhoclByb21pc2UoJy4vcGF0aC90by9kYXRhJykudGhlbihkYXRhID0+IGRhdGFGY24oZGF0YSkpXHJcbiAgeGhyUHJvbWlzZSAodXJsLCB0eXBlID0gJ3RleHQnLCBtZXRob2QgPSAnR0VUJykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTsgLy8gUE9TVCBtYWlubHkgZm9yIHNlY3VyaXR5IGFuZCBsYXJnZSBmaWxlc1xyXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gdHlwZTtcclxuICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoeGhyLnJlc3BvbnNlKTtcclxuICAgICAgeGhyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QoRXJyb3IoYENvdWxkIG5vdCBsb2FkICR7dXJsfTogJHt4aHIuc3RhdHVzfWApKTtcclxuICAgICAgeGhyLnNlbmQoKTtcclxuICAgIH0pXHJcbiAgfSxcclxuICAvLyBSZXR1cm4gcHJvbWlzZSBmb3IgcGF1c2Ugb2YgbXMuIFVzZTpcclxuICAvLyB0aW1lb3V0UHJvbWlzZSgyMDAwKS50aGVuKCgpPT5jb25zb2xlLmxvZygnZm9vJykpXHJcbiAgdGltZW91dFByb21pc2UgKG1zID0gMTAwMCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIG1zKTtcclxuICAgIH0pXHJcbiAgfSxcclxuICAvLyBJbXBvcnRzIGEgc2NyaXB0LCB3YWl0cyAndGlsbCBsb2FkZWQsIHRoZW4gcmVzb2x2ZXMuIFVzZTpcclxuICAvLyBzY3JpcHRQcm9taXNlKCcuLi9saWIvcGFrby5qcycsICdwYWtvJylcclxuICAvLyAgIC50aGVuKChzY3JpcHQpID0+IGNvbnNvbGUubG9nKHNjcmlwdCkpXHJcbiAgc2NyaXB0UHJvbWlzZSAocGF0aCwgbmFtZSwgZiA9ICgpID0+IHdpbmRvd1tuYW1lXSwgcHJvcHMgPSB7fSkge1xyXG4gICAgaWYgKHdpbmRvd1tuYW1lXSA9PSBudWxsKSB0aGlzLnNldFNjcmlwdChwYXRoLCBwcm9wcyk7XHJcbiAgICByZXR1cm4gdGhpcy53YWl0UHJvbWlzZSgoKSA9PiB3aW5kb3dbbmFtZV0gIT0gbnVsbCwgZilcclxuICB9LFxyXG4gIC8vIFByb21pc2U6IFdhaXQgdW50aWwgZG9uZSgpLCB0aGVuIHJlc29sdmUgd2l0aCBmKCkncyB2YWx1ZSwgZGVmYXVsdCB0byBub29wXHJcbiAgLy8gRXg6IFRoaXMgd2FpdHMgdW50aWwgd2luZG93LmZvbyBpcyBkZWZpbmVkLCB0aGVuIHJlcG9ydHM6XHJcbiAgLy8gd2FpdFByb21pc2UoKCk9PndpbmRvdy5mb28pLnRoZW4oKCk9PmNvbnNvbGUubG9nKCdmb28gZGVmaW5lZCcpKVxyXG4gIHdhaXRQcm9taXNlIChkb25lLCBmID0gdGhpcy5ub29wLCBtcyA9IDEwKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLndhaXRPbihkb25lLCAoKSA9PiByZXNvbHZlKGYoKSksIG1zKTtcclxuICAgIH0pXHJcbiAgfSxcclxuICAvLyBDYWxsYmFjazogV2FpdCAoc2V0VGltZW91dCkgdW50aWwgZG9uZSgpIHRydWUsIHRoZW4gY2FsbCBmKClcclxuICB3YWl0T24gKGRvbmUsIGYsIG1zID0gMTApIHtcclxuICAgIGlmIChkb25lKCkpXHJcbiAgICAgIGYoKTtcclxuICAgIGVsc2VcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMud2FpdE9uKGRvbmUsIGYsIG1zKTsgfSwgbXMpO1xyXG4gIH0sXHJcblxyXG4gIC8vIEFuIFthc3luYy9hd2FpdF0oaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvYXN5bmMtZ2VuZXJhdG9ycylcclxuICAvLyBpbXBsZW1lbnRhdGlvbiB1c2luZyBnZW5lcmF0b3JzIHJldHVybmluZyBwcm9taXNlcy5cclxuICAvL1xyXG4gIC8vIHJ1bkdlbmVyYXRvciBydW5zIGEgZ2VuZXJhdG9yIHdoaWNoIHlpZWxkcyBwcm9taXNlcyxcclxuICAvLyByZXR1cm5pbmcgdGhlIHByb21pc2UgcmVzdWx0cyB3aGVuIHRoZXkgY29tcGxldGUuXHJcbiAgLy8gQW1hemluZ2x5IGVub3VnaCwgdGhlIHJldHVybmVkIHByb21pc2UgcmVzdWx0IHJlcGxhY2VzIHRoZVxyXG4gIC8vIHByb21pc2UgaW5pdGlhbGx5IHlpZWxkZWQgYnkgdGhlIGdlbmVyYXRvciBmdW5jdGlvbi5cclxuICAvLyBUaGUgYGl0YCBhcmd1bWVudCBjYW4gYmUgZWl0aGVyIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIG9yIGl0J3MgaXRlcmF0b3IuXHJcbiAgcnVuR2VuZXJhdG9yIChpdCwgY2FsbGJhY2sgPSAobGFzdFZhbCkgPT4ge30pIHtcclxuICAgIGl0ID0gdGhpcy50eXBlT2YoaXQpID09PSAnZ2VuZXJhdG9yJyA/IGl0IDogaXQoKVxyXG4gICAgOyhmdW5jdGlvbiBpdGVyYXRlICh2YWwpIHsgLy8gYXN5bmNocm9ub3VzbHkgaXRlcmF0ZSBvdmVyIGdlbmVyYXRvclxyXG4gICAgICBjb25zdCByZXQgPSBpdC5uZXh0KHZhbCk7XHJcbiAgICAgIGlmICghcmV0LmRvbmUpIC8vIHdhaXQgb24gcHJvbWlzZSwgYHRoZW5gIGNhbGxzIGl0ZXJhdGUgdy8gYSB2YWx1ZVxyXG4gICAgICAgIGlmIChyZXQudmFsdWUudGhlbilcclxuICAgICAgICAgIHJldC52YWx1ZS50aGVuKGl0ZXJhdGUpOyAvLyBpdGVyYXRlIHRha2VzIHRoZSBwcm9taXNlJ3MgdmFsdWVcclxuICAgICAgICBlbHNlIC8vIGF2b2lkIHN5bmNocm9ub3VzIHJlY3Vyc2lvblxyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBpdGVyYXRlKHJldC52YWx1ZSksIDApO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgY2FsbGJhY2socmV0LnZhbHVlKTtcclxuICAgIH0oKSk7XHJcbiAgfSxcclxuICAvLyBQcm9taXNlIHZlcnNpb24gb2YgcnVuR2VuZXJhdG9yLlxyXG4gIC8vIFRoZSBgaXRgIGFyZ3VtZW50IGNhbiBiZSBlaXRoZXIgYSBnZW5lcmF0b3IgZnVuY3Rpb24gb3IgaXQncyBpdGVyYXRvci5cclxuICBydW5HZW5lcmF0b3JQcm9taXNlIChpdCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdGhpcy5ydW5HZW5lcmF0b3IoaXQsIHJlc29sdmUpO1xyXG4gICAgfSlcclxuICB9LFxyXG4gIC8vIFVzZWQgbGlrZSB0aGlzLCBtYWluKCkgaXMgZW50aXJlbHkgc3luYzpcclxuICAvLyBgYGBcclxuICAvLyBmdW5jdGlvbiogbWFpbigpIHtcclxuICAvLyAgIHZhciBwYXRoID0gJ2h0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2JhY2tzcGFjZXMvJ1xyXG4gIC8vICAgdmFyIHZhbDEgPSB5aWVsZCB1dGlsLnhoclByb21pc2UocGF0aCArICdsb3JlbTEudHh0JylcclxuICAvLyAgIGNvbnNvbGUubG9nKCAndmFsMScsIHZhbDEgKVxyXG4gIC8vICAgdmFyIHZhbDIgPSB5aWVsZCB1dGlsLnhoclByb21pc2UocGF0aCArICdsb3JlbTIudHh0JylcclxuICAvLyAgIGNvbnNvbGUubG9nKCAndmFsMicsIHZhbDIgKVxyXG4gIC8vIH1cclxuICAvLyB1dGlsLnJ1bkdlbmVyYXRvciggbWFpbiApXHJcbiAgLy8gYGBgXHJcblxyXG4gIC8vIFJ1biBhIHBvc3NpYmx5IGFzeW5jIGZjbiwgY2FsbGluZyB0aGVuRmNuIHdoZW4gYXN5bmMgZmNuIGlzIGRvbmUuXHJcbiAgLy8gVGhlIGZjbiBjYW4gcmV0dXJuIGEgZ2VuZXJhdG9yIG9yIGEgcHJvbWlzZS5cclxuICAvLyBJZiBuZWl0aGVyLCBydW4gZmNuICYgdGhlbkZjbiBzeW5jaHJvbm91c2x5XHJcbiAgcnVuQXN5bmNGY24gKGZjbiwgdGhlbkZjbikge1xyXG4gICAgY29uc3Qgc3RhcnR1cCA9IGZjbigpO1xyXG4gICAgaWYgKHRoaXMudHlwZU9mKHN0YXJ0dXApID09PSAnZ2VuZXJhdG9yJylcclxuICAgICAgdGhpcy5ydW5HZW5lcmF0b3Ioc3RhcnR1cCwgdGhlbkZjbik7XHJcbiAgICBlbHNlIGlmICh0aGlzLnR5cGVPZihzdGFydHVwKSA9PT0gJ3Byb21pc2UnKVxyXG4gICAgICBzdGFydHVwLnRoZW4odGhlbkZjbik7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoZW5GY24oKTtcclxuICB9LFxyXG5cclxuLy8gIyMjIENhbnZhcy9JbWFnZVxyXG5cclxuICAvLyBHZXQgYW4gaW1hZ2UgaW4gdGhpcyBwYWdlIGJ5IGl0cyBJRFxyXG4gIGdldENhbnZhc0J5SUQ6IChpZCkgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxyXG4gIC8vIENyZWF0ZSBhIGJsYW5rIGNhbnZhcyBvZiBhIGdpdmVuIHdpZHRoL2hlaWdodFxyXG4gIGNyZWF0ZUNhbnZhcyAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgY29uc3QgY2FuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBPYmplY3QuYXNzaWduKGNhbiwge3dpZHRoLCBoZWlnaHR9KTtcclxuICAgIHJldHVybiBjYW5cclxuICB9LFxyXG4gIC8vIEFzIGFib3ZlLCBidXQgcmV0dXJpbmcgdGhlIGNvbnRleHQgb2JqZWN0LlxyXG4gIC8vIE5PVEU6IGN0eC5jYW52YXMgaXMgdGhlIGNhbnZhcyBmb3IgdGhlIGN0eCwgYW5kIGNhbiBiZSB1c2UgYXMgYW4gaW1hZ2UuXHJcbiAgY3JlYXRlQ3R4ICh3aWR0aCwgaGVpZ2h0LCB0eXBlID0gJzJkJywgZ2xBdHRyaWJ1dGVzID0ge30pIHtcclxuICAgIGNvbnN0IGNhbiA9IHRoaXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29udGV4dChjYW4sIHR5cGUsIGdsQXR0cmlidXRlcylcclxuICB9LFxyXG4gIGdldENvbnRleHQgKGNhbnZhcywgdHlwZSA9ICcyZCcsIGdsQXR0cmlidXRlcyA9IHt9KSB7XHJcbiAgICBpZiAodHlwZW9mIGNhbnZhcyA9PT0gJ3N0cmluZycpIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzQnlJRChjYW52YXMpO1xyXG4gICAgaWYgKHR5cGVbMF0gIT09ICcyJykgdHlwZSA9ICd3ZWJnbCc7XHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCh0eXBlLCBnbEF0dHJpYnV0ZXMpO1xyXG4gICAgaWYgKCFjdHgpIHRoaXMuZXJyb3IoJ2dldENvbnRleHQgZXJyb3InKTtcclxuICAgIHJldHVybiBjdHhcclxuICB9LFxyXG4gIC8vIER1cGxpY2F0ZSBhIGN0eCdzIGltYWdlLiBSZXR1cm5zIHRoZSBuZXcgY3R4ICh3aG8ncyBjYW52YXMgaXMgY3R4LmNhYW52YXMpXHJcbiAgY2xvbmVDdHggKGN0eDApIHtcclxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3JlYXRlQ3R4KGN0eDAuY2FudmFzLndpZHRoLCBjdHgwLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgY3R4LmRyYXdJbWFnZShjdHgwLmNhbnZhcywgMCwgMCk7XHJcbiAgICByZXR1cm4gY3R4XHJcbiAgfSxcclxuICAvLyBSZXNpemUgYSBjdHgvY2FudmFzIGFuZCBwcmVzZXJ2ZSBkYXRhLlxyXG4gIHJlc2l6ZUN0eCAoY3R4LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBjb25zdCBjb3B5ID0gdGhpcy5jbG9uZUN0eChjdHgpO1xyXG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgY3R4LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICBjdHguZHJhd0ltYWdlKGNvcHkuY2FudmFzLCAwLCAwKTtcclxuICB9LFxyXG4gIC8vIFJldHVybiB0aGUgKGNvbXBsZXRlKSBJbWFnZURhdGEgb2JqZWN0IGZvciB0aGlzIGNvbnRleHQgb2JqZWN0XHJcbiAgY3R4SW1hZ2VEYXRhIChjdHgpIHtcclxuICAgIHJldHVybiBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KVxyXG4gIH0sXHJcbiAgLy8gRmlsbCB0aGlzIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gaW1hZ2UuIFdpbGwgc2NhbGUgaW1hZ2UgdG8gZml0IGN0eCBzaXplLlxyXG4gIGZpbGxDdHhXaXRoSW1hZ2UgKGN0eCwgaW1nKSB7XHJcbiAgICB0aGlzLnNldElkZW50aXR5KGN0eCk7IC8vIHNldC9yZXN0b3JlIGlkZW50aXR5XHJcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICB9LFxyXG4gIC8vIFJldHVybiBhbiBpbWFnZS9wbmcgYmFzZTY0IFtkYXRhVXJsXShodHRwczovL2dvby5nbC9meUJQbkwpXHJcbiAgLy8gc3RyaW5nIGZvciB0aGlzIGN0eCBvYmplY3QuXHJcbiAgY3R4VG9EYXRhVXJsOiAoY3R4KSA9PiBjdHguY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyksXHJcblxyXG4gIC8vIENvbnZlcnQgYSBkYXRhVXJsIGJhY2sgaW50byBhbSBpbWFnZS5cclxuICBkYXRhVXJsVG9JbWFnZSAoZGF0YVVybCkgeyAvLyBhc3luYyBpbiBzb21lIGJyb3dzZXJzPz8gaHR0cDovL2dvby5nbC9rSWsyVVxyXG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICBpbWcuc3JjID0gZGF0YVVybDtcclxuICAgIHJldHVybiBpbWdcclxuICB9LFxyXG4gIC8vIFJldHVybiBhIGN0eCBvYmplY3QgZm9yIHRoaXMgYmFzZTY0IGRhdGEgdXJsXHJcbiAgZGF0YVVybFRvQ3R4IChkYXRhVXJsKSB7IC8vIGFzeW5jIGluIHNvbWUgYnJvd3NlcnM/PyBodHRwOi8vZ29vLmdsL2tJazJVXHJcbiAgICBjb25zdCBpbWcgPSB0aGlzLmRhdGFVcmxUb0ltYWdlKGRhdGFVcmwpO1xyXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jcmVhdGVDdHgoaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcclxuICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcclxuICAgIHJldHVybiBjdHhcclxuICB9LFxyXG5cclxuICBzZXRDdHhTbW9vdGhpbmcgKGN0eCwgc21vb3RoaW5nKSB7XHJcbiAgICAvLyBEb24nY2hhIGxvdmUgIHN0YW5kYXJkcyFcclxuICAgIGNvbnN0IGFsaWFzZXMgPSBbJ2ltYWdlU21vb3RoaW5nRW5hYmxlZCcsICdtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQnLCAnb0ltYWdlU21vb3RoaW5nRW5hYmxlZCcsICd3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQnLCAnbXNJbWFnZVNtb290aGluZ0VuYWJsZWQnXTtcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBhbGlhc2VzKVxyXG4gICAgICBpZiAoY3R4W25hbWVdKVxyXG4gICAgICAgIHJldHVybiAoY3R4W25hbWVdID0gc21vb3RoaW5nKSAvLyBsZXRzIGhvcGUgdGhlIGZpcnN0IG9uZSB3b3Jrcy4gU2hlZXNoIVxyXG4gIH0sXHJcblxyXG4gIC8vIEluc3RhbGwgaWRlbnRpdHkgdHJhbnNmb3JtIGZvciB0aGlzIGNvbnRleHQuXHJcbiAgLy8gQ2FsbCBjdHgucmVzdG9yZSgpIHRvIHJldmVydCB0byBwcmV2aW91cyB0cmFuc2Zvcm0uXHJcbiAgc2V0SWRlbnRpdHkgKGN0eCkge1xyXG4gICAgY3R4LnNhdmUoKTsgLy8gTk9URTogRG9lcyBub3QgY2hhbmdlIHN0YXRlLCBvbmx5IHNhdmVzIGN1cnJlbnQgc3RhdGUuXHJcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApOyAvLyBvciBjdHgucmVzZXRUcmFuc2Zvcm0oKVxyXG4gIH0sXHJcbiAgLy8gU2V0IGN0eC5jYW52YXMgc2l6ZSwgY3R4IHNjYWxlLCBvcmlnaW4gdG8gdGhlIG1vZGVsJ3Mgd29ybGQuXHJcbiAgc2V0V29ybGRUcmFuc2Zvcm0gKGN0eCwgd29ybGQpIHtcclxuICAgIGN0eC5jYW52YXMud2lkdGggPSB3b3JsZC53aWR0aDtcclxuICAgIGN0eC5jYW52YXMuaGVpZ2h0ID0gd29ybGQuaGVpZ2h0O1xyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC5zY2FsZSh3b3JsZC5wYXRjaFNpemUsIC13b3JsZC5wYXRjaFNpemUpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZSgtd29ybGQubWluWGNvciwgLXdvcmxkLm1heFljb3IpO1xyXG4gIH0sXHJcblxyXG4vLyAjIyMgQ2FudmFzIDJEIENvbnRleHQgVGV4dCBEcmF3aW5nXHJcblxyXG4gIC8vIERyYXcgc3RyaW5nIG9mIHRoZSBnaXZlbiBjb2xvciBhdCB0aGUgeHkgbG9jYXRpb24sIGluIGN0eCBwaXhlbCBjb29yZHMuXHJcbiAgLy8gUHVzaC9wb3AgaWRlbnRpdHkgdHJhbnNmb3JtLlxyXG4gIGN0eERyYXdUZXh0IChjdHgsIHN0cmluZywgeCwgeSwgY3NzQ29sb3IpIHtcclxuICAgIHRoaXMuc2V0SWRlbnRpdHkoY3R4KTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBjc3NDb2xvcjtcclxuICAgIGN0eC5maWxsVGV4dChzdHJpbmcsIHgsIHkpO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICB9LFxyXG5cclxuICAvLyBDb252ZXJ0IGFuIGltYWdlLCBvciBwYXJ0IG9mIGFuIGltYWdlLCB0byBhIGNvbnRleHQuXHJcbiAgLy8gaW1nIG1heSBiZSBhbm90aGVyIGNhbnZhcy5cclxuICAvLyAqIHgsIHkgYXJlIHRvcC9sZWZ0IGluIGltYWdlLCBkZWZhdWx0IHRvIDAsIDAuXHJcbiAgLy8gKiB3aWR0aCwgaGVpZ2h0IGFyZSBzaXplIG9mIGNvbnRleHQsIGRlZmF1bHQgdG8gaW1hZ2UncyB3aWR0aCwgaGVpZ2h0XHJcbiAgLy8gKiB0aHVzIGRlZmF1bHQgaXMgZW50aXJlIGltYWdlXHJcbiAgLy9cclxuICAvLyBOT1RFOiB0byBjb252ZXJ0IGEgY3R4IHRvIGFuIFwiaW1hZ2VcIiAoZHJhd0ltYWdlKSB1c2UgY3R4LmNhbnZhcy5cclxuICAvLyBbU2VlIE1ETiBkcmF3SW1hZ2UsIHRoaXJkIGZvcm1dKGh0dHBzOi8vZ29vLmdsL2E1Yjg3TilcclxuICAvLyBOT1RFOiB0aGlzIHdpbGwgZGlzdG9ydCB0aGUgb3JpZ2lvbmFsIGltYWdlLCBkdWUgdG8gYnJvd3NlciBhc3N1bXB0aW9ucy5cclxuICAvLyBVc2UgaW1hZ2VUb0J5dGVzIGZvciB1bmRpc3RvcnRlZCBpbWFnZSBjb250ZW50LlxyXG4gIC8vXHJcbiAgLy8gUkVNSU5EOiBSZW1vdmU/XHJcbiAgaW1hZ2VUb0N0eCAoaW1nLCB4ID0gMCwgeSA9IDAsIHdpZHRoID0gaW1nLndpZHRoLCBoZWlnaHQgPSBpbWcuaGVpZ2h0KSB7XHJcbiAgICBpZiAoKHggKyB3aWR0aCA+IGltZy53aWR0aCkgfHwgKHkgKyBoZWlnaHQgPiBpbWcuaGVpZ2h0KSlcclxuICAgICAgdGhpcy5lcnJvcignaW1hZ2VUb0N0eDogcGFyYW1ldGVycyBvdXRzaWRlIG9mIGltYWdlJyk7XHJcbiAgICBjb25zdCBjdHggPSB0aGlzLmNyZWF0ZUN0eCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHJldHVybiBjdHhcclxuICB9LFxyXG5cclxuLy8gIyMjIFdlYkdML1RocmVlLmpzXHJcblxyXG4gIC8vIFVzZSB3ZWJnbCB0ZXh0dXJlIHRvIGNvbnZlcnQgaW1nIHRvIFVpbnQ4QXJyYXkgdy9vIGFscGhhIHByZW11bHRpcGx5XHJcbiAgLy8gb3IgY29sb3IgcHJvZmlsZSBtb2RpZmljYXRpb24uXHJcbiAgLy8gSW1nIGNhbiBiZSBJbWFnZSwgSW1hZ2VEYXRhLCBDYW52YXM6IFtTZWUgTUROXShodHRwczovL2dvby5nbC9hM295UkEpLlxyXG4gIC8vIGBmbGlwWWAgaXMgdXNlZCB0byBpbnZlcnQgaW1hZ2UgdG8gdXByaWdodC5cclxuICBpbWFnZVRvQnl0ZXNDdHg6IG51bGwsXHJcbiAgaW1hZ2VUb0J5dGVzIChpbWcsIGZsaXBZID0gZmFsc2UsIGltZ0Zvcm1hdCA9ICdSR0JBJykge1xyXG4gICAgLy8gQ3JlYXRlIHRoZSBnbCBjb250ZXh0IHVzaW5nIHRoZSBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgICBpZiAoIXRoaXMuaW1hZ2VUb0J5dGVzQ3R4KSB7XHJcbiAgICAgIHRoaXMuaW1hZ2VUb0J5dGVzQ3R4ID0gdGhpcy5jcmVhdGVDdHgoMCwgMCwgJ3dlYmdsJywge1xyXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gaW1nO1xyXG4gICAgY29uc3QgZ2wgPSB0aGlzLmltYWdlVG9CeXRlc0N0eDtcclxuICAgIE9iamVjdC5hc3NpZ24oZ2wuY2FudmFzLCB7d2lkdGgsIGhlaWdodH0pO1xyXG4gICAgLy8gY29uc3QgZ2wgPSB0aGlzLmNyZWF0ZUN0eCh3aWR0aCwgaGVpZ2h0LCAnd2ViZ2wnLCB7XHJcbiAgICAvLyAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2VcclxuICAgIC8vIH0pXHJcbiAgICBjb25zdCBmbXQgPSBnbFtpbWdGb3JtYXRdO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbmQgaW5pdGlhbGl6ZSB0aGUgdGV4dHVyZS5cclxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuICAgIGlmIChmbGlwWSkgLy8gTWFpbmx5IHVzZWQgZm9yIHBpY3R1cmVzIHJhdGhlciB0aGFuIGRhdGFcclxuICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XHJcbiAgICAvLyBJbnN1cmUgW25vIGNvbG9yIHByb2ZpbGUgYXBwbGllZF0oaHR0cHM6Ly9nb28uZ2wvQnpCVko5KTpcclxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIGdsLk5PTkUpO1xyXG4gICAgLy8gSW5zdXJlIG5vIFthbHBoYSBwcmVtdWx0aXBseV0oaHR0cDovL2dvby5nbC9tZWpOQ0spLlxyXG4gICAgLy8gRmFsc2UgaXMgdGhlIGRlZmF1bHQsIGJ1dCBsZXRzIG1ha2Ugc3VyZSFcclxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmFsc2UpO1xyXG5cclxuICAgIC8vIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nKVxyXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmbXQsIGZtdCwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIGZyYW1lYnVmZmVyIHVzZWQgZm9yIHRoZSB0ZXh0dXJlXHJcbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcclxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxyXG4gICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xyXG5cclxuICAgIC8vIFNlZSBpZiBpdCBhbGwgd29ya2VkLiBBcHBhcmVudGx5IG5vdCBhc3luYy5cclxuICAgIGNvbnN0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xyXG4gICAgaWYgKHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpXHJcbiAgICAgIHRoaXMuZXJyb3IoYGltYWdlVG9CeXRlczogc3RhdHVzIG5vdCBGUkFNRUJVRkZFUl9DT01QTEVURTogJHtzdGF0dXN9YCk7XHJcblxyXG4gICAgLy8gSWYgYWxsIE9LLCBjcmVhdGUgdGhlIHBpeGVscyBidWZmZXIgYW5kIHJlYWQgZGF0YS5cclxuICAgIGNvbnN0IHBpeFNpemUgPSBpbWdGb3JtYXQgPT09ICdSR0InID8gMyA6IDQ7XHJcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheShwaXhTaXplICogd2lkdGggKiBoZWlnaHQpO1xyXG4gICAgLy8gZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpXHJcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGZtdCwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcclxuXHJcbiAgICAvLyBVbmJpbmQgdGhlIGZyYW1lYnVmZmVyIGFuZCByZXR1cm4gcGl4ZWxzXHJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgcmV0dXJuIHBpeGVsc1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEFuIEFycmF5IHN1cGVyY2xhc3Mgd2l0aCBjb252ZW5pZW5jZSBtZXRob2RzIHVzZWQgYnkgTmV0TG9nby5cclxuLy8gVGlwaWNhbGx5IHRoZSBpdGVtcyBpbiB0aGUgYXJyYXkgYXJlIE9iamVjdHMsIE5ldExvZ28gQWdlbnRzLFxyXG4vLyBidXQgZ2VuZXJhbGx5IHVzZWZ1bCBhcyBhbiBBcnJheVBsdXNcclxuXHJcbmNsYXNzIEFnZW50QXJyYXkgZXh0ZW5kcyBBcnJheSB7XHJcbiAgLy8gQ29udmVydCBhbiBBcnJheSB0byBhbiBBZ2VudEFycmF5IFwiaW4gcGxhY2VcIi5cclxuICAvLyBVc2UgYXJyYXkuc2xpY2UoKSBpZiBhIG5ldyBhcnJheSBpcyB3YW50ZWRcclxuICBzdGF0aWMgZnJvbUFycmF5IChhcnJheSkge1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFycmF5LCBBZ2VudEFycmF5LnByb3RvdHlwZSk7XHJcbiAgICByZXR1cm4gYXJyYXlcclxuICB9XHJcblxyXG4gIC8vIGNvbnN0cnVjdG9yIG5vdCBuZWVkZWQsIEpTIHBhc3NlcyBvbiBpZiBjdG9yIHNhbWUgYXMgc3VwZXInc1xyXG4gIC8vIGNvbnN0cnVjdG9yICgpIHsgc3VwZXIoKSB9XHJcblxyXG4gIC8vIENvbnZlcnQgYmV0d2VlbiBBZ2VudEFycmF5cyBhbmQgQXJyYXlzXHJcbiAgdG9BcnJheSAoKSB7IE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBcnJheS5wcm90b3R5cGUpOyByZXR1cm4gdGhpcyB9XHJcblxyXG4gIC8vIFJlbW92ZS9JbnNlcnQgb2JqZWN0IFwib1wiIGZyb20gdGhpcyBhcnJheS4gSWYgcHJvcCBnaXZlbiwgYXNzdW1lXHJcbiAgLy8gYXJyYXkgc29ydGVkIGJ5IHByb3AgYW5kIHVzZSBiaW5hcnkgc2VhcmNoLiBSZXR1cm4gdGhpcyBmb3IgY2hhaW5pbmcuXHJcbiAgLy8gUkVNSU5EOiBNb3ZlIHV0aWwgZnVuY3Rpb25zIGhlcmUsIGhvcGVmdWxseSBzaW1wbGlmeWluZy5cclxuICByZW1vdmUgKG8sIHByb3ApIHtcclxuICAgIHV0aWwucmVtb3ZlSXRlbSh0aGlzLCBvLCBwcm9wKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIGluc2VydCAobywgcHJvcCkge1xyXG4gICAgdXRpbC5pbnNlcnRJdGVtKHRoaXMsIG8sIHByb3ApO1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGFyZSBubyBpdGVtcyBpbiB0aGlzIHNldCwgZmFsc2UgaWYgbm90IGVtcHR5LlxyXG4gIGVtcHR5ICgpIHsgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwIH1cclxuICAvLyBSZXR1cm4gIWVtcHR5KClcclxuICBhbnkgKCkgeyByZXR1cm4gdGhpcy5sZW5ndGggIT09IDAgfVxyXG4gIC8vIFJldHVybiBmaXJzdCBpdGVtIGluIHRoaXMgYXJyYXkuIFJldHVybnMgdW5kZWZpbmVkIGlmIGVtcHR5LlxyXG4gIGZpcnN0ICgpIHsgcmV0dXJuIHRoaXNbIDAgXSB9XHJcbiAgLy8gUmV0dXJuIGxhc3QgaXRlbSBpbiB0aGlzIGFycmF5LiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBlbXB0eS5cclxuICBsYXN0ICgpIHsgcmV0dXJuIHRoaXNbIHRoaXMubGVuZ3RoIC0gMSBdIH1cclxuICAvLyBSZXR1cm4gdHJ1ZSBpZiByZXBvcnRlciB0cnVlIGZvciBhbGwgb2YgdGhpcyBzZXQncyBvYmplY3RzXHJcbiAgYWxsIChyZXBvcnRlcikgeyByZXR1cm4gdGhpcy5ldmVyeShyZXBvcnRlcikgfVxyXG4gIC8vIFJldHVybiBBZ2VudEFycmF5IG9mIHByb3BlcnR5IHZhbHVlcyBmb3Iga2V5IGZyb20gdGhpcyBhcnJheSdzIG9iamVjdHNcclxuICAvLyBwcm9wcyAoa2V5KSB7IHJldHVybiB0aGlzLm1hcCgoYSkgPT4gYVtrZXldKS50b0FycmF5KCkgfVxyXG4gIHByb3BzIChrZXkpIHsgcmV0dXJuIHRoaXMubWFwKChhKSA9PiBhW2tleV0pIH1cclxuICAvLyBSZXR1cm4gQWdlbnRBcnJheSB3aXRoIHJlcG9ydGVyKGFnZW50KSB0cnVlXHJcbiAgd2l0aCAocmVwb3J0ZXIpIHsgcmV0dXJuIHRoaXMuZmlsdGVyKHJlcG9ydGVyKSB9XHJcbiAgLy8gQ2FsbCBmY24oYWdlbnQpIGZvciBlYWNoIGFnZW50IGluIEFnZW50QXJyYXkuXHJcbiAgLy8gUmV0dXJuIHRoZSBBZ2VudEFycmF5IGZvciBjaGFpbmluZy5cclxuICAvLyBOb3RlOiA1eCsgZmFzdGVyIHRoYW4gdGhpcy5mb3JFYWNoKGZjbikgISFcclxuICBhc2sgKGZjbikgeyBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIGZjbih0aGlzW2ldLCBpKTsgcmV0dXJuIHRoaXMgfVxyXG4gIC8vIFJldHVybiBjb3VudCBvZiBhZ2VudHMgd2l0aCByZXBvcnRlcihhZ2VudCkgdHJ1ZVxyXG4gIGNvdW50IChyZXBvcnRlcikge1xyXG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKChwcmV2LCBvKSA9PiBwcmV2ICsgKHJlcG9ydGVyKG8pID8gMSA6IDApLCAwKVxyXG4gIH1cclxuXHJcbiAgLy8gUmVwbGFjZW1lbnRzIGZvciBhcnJheSBtZXRob2RzIHRvIGF2b2lkIGNhbGxpbmcgQWdlbnRBcnJheSBjdG9yXHJcblxyXG4gIC8vIFJldHVybiBzaGFsbG93IGNvcHkgb2YgYSBwb3J0aW9uIG9mIHRoaXMgQWdlbnRBcnJheVxyXG4gIC8vIFtTZWUgQXJyYXkuc2xpY2VdKGh0dHBzOi8vZ29vLmdsL0lsZ3NvaylcclxuICAvLyBEZWZhdWx0IGlzIHRvIGNsb25lIGVudGlyZSBBZ2VudEFycmF5XHJcbiAgY2xvbmUgKGJlZ2luID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcclxuICAgIHJldHVybiB0aGlzLnNsaWNlKGJlZ2luLCBlbmQpIC8vIFJldHVybnMgYW4gQWdlbnRBcnJheSByYXRoZXIgdGhhbiBBcnJheSFcclxuICB9XHJcbiAgLy8gUmFuZG9taXplIHRoZSBBZ2VudEFycmF5IGluIHBsYWNlLiBVc2UgY2xvbmUgZmlyc3QgaWYgbmV3IEFnZW50QXJyYXkgbmVlZGVkLlxyXG4gIC8vIFJldHVybiBcInRoaXNcIiBmb3IgY2hhaW5pbmcuXHJcbiAgc2h1ZmZsZSAoKSB7IHJldHVybiB1dGlsLnNodWZmbGUodGhpcykgfVxyXG4gIC8vIFJldHVybiB0aGlzIEFnZW50QXJyYXkgc29ydGVkIGJ5IHRoZSByZXBvcnRlciBpbiBhc2NlbmRpbmcvZGVzY2VuZGluZyBvcmRlci5cclxuICAvLyBJZiByZXBvcnRlciBpcyBhIHN0cmluZywgY29udmVydCB0byBhIGZjbiByZXR1cm5pbmcgdGhhdCBwcm9wZXJ0eS5cclxuICAvLyBVc2UgY2xvbmUgaWYgeW91IGRvbid0IHdhbnQgdG8gbXV0YXRlIHRoaXMgYXJyYXkuXHJcbiAgc29ydEJ5IChyZXBvcnRlciwgYXNjZW5kaW5nID0gdHJ1ZSkge1xyXG4gICAgdXRpbC5zb3J0T2Jqcyh0aGlzLCByZXBvcnRlciwgYXNjZW5kaW5nKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gYSByYW5kb20gYWdlbnQuIFJldHVybiB1bmRlZmluZWQgaWYgZW1wdHkuXHJcbiAgb25lT2YgKCkgeyByZXR1cm4gdXRpbC5vbmVPZih0aGlzKSB9XHJcbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGFnZW50LCBub3QgZXF1YWwgdG8gYWdlbnRcclxuICBvdGhlck9uZU9mIChhZ2VudCkgeyByZXR1cm4gdXRpbC5vdGhlck9uZU9mKHRoaXMsIGFnZW50KSB9XHJcbiAgLy8gb3RoZXJPbmVPZjogbk9mIGdvb2QgZW5vdWdoP1xyXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgYWdlbnQgaGF2aW5nIHRoZSBtaW4vbWF4IG9mIGdpdmVuIHZhbHVlIG9mIGYoYWdlbnQpLlxyXG4gIC8vIElmIHJlcG9ydGVyIGlzIGEgc3RyaW5nLCBjb252ZXJ0IHRvIGEgZmNuIHJldHVybmluZyB0aGF0IHByb3BlcnR5XHJcbiAgbWluT3JNYXhPZiAobWluLCByZXBvcnRlcikge1xyXG4gICAgaWYgKHRoaXMuZW1wdHkoKSkgdGhyb3cgRXJyb3IoJ21pbi9tYXggT25lT2Y6IGVtcHR5IGFycmF5JylcclxuICAgIGlmICh0eXBlb2YgcmVwb3J0ZXIgPT09ICdzdHJpbmcnKSByZXBvcnRlciA9IHV0aWwucHJvcEZjbihyZXBvcnRlcik7XHJcbiAgICBsZXQgbyA9IG51bGw7XHJcbiAgICBsZXQgdmFsID0gbWluID8gSW5maW5pdHkgOiAtSW5maW5pdHk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgYSA9IHRoaXNbaV07XHJcbiAgICAgIGNvbnN0IGF2YWwgPSByZXBvcnRlcihhKTtcclxuICAgICAgaWYgKChtaW4gJiYgKGF2YWwgPCB2YWwpKSB8fCAoIW1pbiAmJiAoYXZhbCA+IHZhbCkpKVxyXG4gICAgICAgIFtvLCB2YWxdID0gW2EsIGF2YWxdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9cclxuICB9XHJcbiAgLy8gVGhlIG1pbiB2ZXJzaW9uIG9mIHRoZSBhYm92ZVxyXG4gIG1pbk9uZU9mIChyZXBvcnRlcikgeyByZXR1cm4gdGhpcy5taW5Pck1heE9mKHRydWUsIHJlcG9ydGVyKSB9XHJcbiAgLy8gVGhlIG1heCB2ZXJzaW9uIG9mIHRoZSBhYm92ZVxyXG4gIG1heE9uZU9mIChyZXBvcnRlcikgeyByZXR1cm4gdGhpcy5taW5Pck1heE9mKGZhbHNlLCByZXBvcnRlcikgfVxyXG5cclxuICAvLyBSZXR1cm4gbiByYW5kb20gYWdlbnRzIGFzIEFnZW50QXJyYXkuXHJcbiAgLy8gU2VlIFtGaXNoZXItWWF0ZXMtS251dGggc2h1ZmZsZV0oaHR0cHM6Ly9nb28uZ2wvZldORmYpXHJcbiAgLy8gZm9yIGJldHRlciBhcHByb2FjaCBmb3IgbGFyZ2Ugbi5cclxuICBuT2YgKG4pIHtcclxuICAgIGlmIChuID4gdGhpcy5sZW5ndGgpXHJcbiAgICAgIHRocm93IEVycm9yKCduT2Y6IG4gbGFyZ2VyIHRoYW4gQWdlbnRBcnJheScpXHJcbiAgICBpZiAobiA9PT0gdGhpcy5sZW5ndGgpIHJldHVybiB0aGlzXHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQWdlbnRBcnJheSgpO1xyXG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBuKSB7XHJcbiAgICAgIGNvbnN0IG8gPSB0aGlzLm9uZU9mKCk7XHJcbiAgICAgIGlmICghKG8gaW4gcmVzdWx0KSkgcmVzdWx0LnB1c2gobyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG4gIC8vIFJldHVybiBhIG5ldyBBZ2VudEFycmF5IG9mIHRoZSBuIG1pbi9tYXggYWdlbnRzIG9mIHRoZSB2YWx1ZSBvZiByZXBvcnRlcixcclxuICAvLyBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgLy8gSWYgcmVwb3J0ZXIgaXMgYSBzdHJpbmcsIGNvbnZlcnQgdG8gYSBmY24gcmV0dXJuaW5nIHRoYXQgcHJvcGVydHlcclxuICAvLyBOT1RFOiB3ZSBkbyBub3QgbWFuYWdlIHRpZXMsIHNlZSBOZXRMb2dvIGRvY3MuXHJcbiAgbWluT3JNYXhOT2YgKG1pbiwgbiwgcmVwb3J0ZXIpIHtcclxuICAgIGlmIChuID4gdGhpcy5sZW5ndGgpIHRocm93IEVycm9yKCdtaW4vbWF4IG5PZjogbiBsYXJnZXIgdGhhbiBBZ2VudEFycmF5JylcclxuICAgIGNvbnN0IGFzID0gdGhpcy5jbG9uZSgpLnNvcnRCeShyZXBvcnRlcik7XHJcbiAgICByZXR1cm4gbWluID8gYXMuY2xvbmUoMCwgbikgOiBhcy5jbG9uZShhcy5sZW5ndGggLSBuKVxyXG4gIH1cclxuICBtaW5OT2YgKG4sIHJlcG9ydGVyKSB7IHJldHVybiB0aGlzLm1pbk9yTWF4Tk9mKHRydWUsIG4sIHJlcG9ydGVyKSB9XHJcbiAgbWF4Tk9mIChuLCByZXBvcnRlcikgeyByZXR1cm4gdGhpcy5taW5Pck1heE5PZihmYWxzZSwgbiwgcmVwb3J0ZXIpIH1cclxuXHJcbiAgLy8gR2VvbWV0cnkgbWV0aG9kcyBmb3IgcGF0Y2hlcywgdHVydGxlcywgYW5kIG90aGVyIEFnZW50QXJyYXlzIHdoaWNoIGhhdmUgeCx5LlxyXG4gIC8vIFJldHVybiBhbGwgYWdlbnRzIHdpdGhpbiByZWN0LCByYWRpdXMsIGNvbmUgZnJvbSBnaXZlbiBhZ2VudCBvLlxyXG4gIC8vIElmIG1lVG9vLCBpbmNsdWRlIGdpdmVuIG9iamVjdCwgZGVmYXVsdCBleGNsdWRlcyBpdFxyXG4gIC8vIFR5cGljYWxseSB0aGUgQWdlbnRBcnJheSBpcyBhIHN1YnNldCBvZiBsYXJnZXIgc2V0cywgcmVkdWNpbmdcclxuICAvLyB0aGUgc2l6ZSwgdGhlbiB1c2VzIHRoZXNlIGluUmVjdCwgaW5SYWRpdXMgb3IgaW5Db25lIG1ldGhvZHNcclxuXHJcbiAgLy8gUmV0dXJuIGFsbCBhZ2VudHMgd2l0aGluIHJlY3RhbmdsZSBmcm9tIGdpdmVuIGFnZW50IG8uXHJcbiAgLy8gZHggJiBkeSBhcmUgKGZsb2F0KSBoYWxmIHdpZHRoL2hlaWdodCBvZiByZWN0XHJcbiAgaW5SZWN0IChvLCBkeCwgZHkgPSBkeCwgbWVUb28gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgYWdlbnRzID0gbmV3IEFnZW50QXJyYXkoKTtcclxuICAgIGNvbnN0IG1pblggPSBvLnggLSBkeDsgLy8gb2sgaWYgbWF4L21pbiBvZmYtd29ybGQsIG8sIGEgYXJlIGluLXdvcmxkXHJcbiAgICBjb25zdCBtYXhYID0gby54ICsgZHg7XHJcbiAgICBjb25zdCBtaW5ZID0gby55IC0gZHk7XHJcbiAgICBjb25zdCBtYXhZID0gby55ICsgZHk7XHJcbiAgICB0aGlzLmFzayhhID0+IHtcclxuICAgICAgaWYgKG1pblggPD0gYS54ICYmIGEueCA8PSBtYXhYICYmIG1pblkgPD0gYS55ICYmIGEueSA8PSBtYXhZKSB7XHJcbiAgICAgICAgaWYgKG1lVG9vIHx8IG8gIT09IGEpIGFnZW50cy5wdXNoKGEpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhZ2VudHNcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiBhbGwgYWdlbnRzIGluIEFnZW50QXJyYXkgd2l0aGluIGQgZGlzdGFuY2UgZnJvbSBnaXZlbiBvYmplY3QuXHJcbiAgaW5SYWRpdXMgKG8sIHJhZGl1cywgbWVUb28gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgYWdlbnRzID0gbmV3IEFnZW50QXJyYXkoKTtcclxuICAgIC8vIGNvbnN0IHt4LCB5fSA9IG8gLy8gcGVyZj9cclxuICAgIGNvbnN0IGQyID0gcmFkaXVzICogcmFkaXVzO1xyXG4gICAgY29uc3Qgc3FEaXN0YW5jZSA9IHV0aWwuc3FEaXN0YW5jZTsgLy8gTG9jYWwgZnVuY3Rpb24gMi0zeCBmYXN0ZXIsIGlubGluZWQ/XHJcbiAgICB0aGlzLmFzayhhID0+IHtcclxuICAgICAgaWYgKHNxRGlzdGFuY2Uoby54LCBvLnksIGEueCwgYS55KSA8PSBkMilcclxuICAgICAgICBpZiAobWVUb28gfHwgbyAhPT0gYSkgYWdlbnRzLnB1c2goYSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhZ2VudHNcclxuICB9XHJcblxyXG4gIC8vIEFzIGFib3ZlLCBidXQgYWxzbyBsaW1pdGVkIHRvIHRoZSBhbmdsZSBgY29uZUFuZ2xlYCBhcm91bmRcclxuICAvLyBhIGBkaXJlY3Rpb25gIGZyb20gb2JqZWN0IGBvYC5cclxuICBpbkNvbmUgKG8sIHJhZGl1cywgY29uZUFuZ2xlLCBkaXJlY3Rpb24sIG1lVG9vID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGFnZW50cyA9IG5ldyBBZ2VudEFycmF5KCk7XHJcbiAgICB0aGlzLmFzayhhID0+IHtcclxuICAgICAgaWYgKHV0aWwuaW5Db25lKGEueCwgYS55LCByYWRpdXMsIGNvbmVBbmdsZSwgZGlyZWN0aW9uLCBvLngsIG8ueSkpXHJcbiAgICAgICAgaWYgKG1lVG9vIHx8IG8gIT09IGEpIGFnZW50cy5wdXNoKGEpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWdlbnRzXHJcbiAgfVxyXG59XHJcblxyXG4vLyBBIGdlbmVyYWwgY29sb3IgbW9kdWxlLCBzdXBwb3J0aW5nIGNzcyBzdHJpbmcgY29sb3JzLCBjYW52YXMyZCBwaXhlbFxyXG4vLyBjb2xvcnMsIHdlYmdsIGFuZCBjYW52YXMyZCBVaW50OENsYW1wZWRBcnJheSByLGcsYixhIGFycmF5cy5cclxuLy8gTm90aWNlIGEgSmF2YVNjcmlwdCBBcnJheSBpcyAqKm5vdCoqIGEgY29sb3IhXHJcblxyXG5jb25zdCBDb2xvciA9IHtcclxuXHJcbi8vICMjIyBDU1MgQ29sb3IgU3RyaW5ncy5cclxuXHJcbiAgLy8gQ1NTIGNvbG9ycyBpbiBIVE1MIGFyZSBzdHJpbmdzLCBzZWUgW01vemlsbGFzIENvbG9yIFJlZmVyZW5jZV0oXHJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlKSxcclxuICAvLyB0YWtpbmcgb25lIG9mIDcgZm9ybXM6XHJcbiAgLy9cclxuICAvLyAqIE5hbWVzOiBvdmVyIDE0MCBjb2xvciBjYXNlLWluc2Vuc2l0aXZlIG5hbWVzIGxpa2VcclxuICAvLyAgIFJlZCwgR3JlZW4sIENhZGV0Qmx1ZSwgZXRjLlxyXG4gIC8vICogSGV4LCBzaG9ydCBhbmQgbG9uZyBmb3JtOiAjMGYwLCAjZmYxMGEwXHJcbiAgLy8gKiBSR0I6IHJnYigyNTUsIDAsIDApLCByZ2JhKDI1NSwgMCwgMCwgMC41KVxyXG4gIC8vICogSFNMOiBoc2woMTIwLCAxMDAlLCA1MCUpLCBoc2xhKDEyMCwgMTAwJSwgNTAlLCAwLjgpXHJcbiAgLy9cclxuICAvLyBTZWUgW3RoaXMgd2lraXBlZGlhIGFydGljbGVdKGh0dHBzOi8vZ29vLmdsL2V2OEt3MClcclxuICAvLyBvbiBkaWZmZXJlbmNlcyBiZXR3ZWVuIEhTTCBhbmQgSFNCL0hTVi5cclxuXHJcbiAgLy8gQ29udmVydCA0IHIsZyxiLGEgaW50cyBpbiBbMC0yNTVdIChcImFcIiBkZWZhdWx0ZWQgdG8gMjU1KSB0byBhXHJcbiAgLy8gY3NzIGNvbG9yIHN0cmluZy4gQWxwaGEgXCJhXCIgaXMgY29udmVydGVkIHRvIGZsb2F0IGluIDAtMSBmb3IgY3NzIHN0cmluZy5cclxuICAvLyBXZSB1c2UgYWxwaGEgaW4gWzAtMjU1XSB0byBiZSBjb21wYXRpYmxlIHdpdGggVHlwZWRBcnJheSBjb252ZW50aW9ucy5cclxuICByZ2JhU3RyaW5nIChyLCBnLCBiLCBhID0gMjU1KSB7XHJcbiAgICBhID0gYSAvIDI1NTsgY29uc3QgYTIgPSBhLnRvUHJlY2lzaW9uKDIpO1xyXG4gICAgcmV0dXJuIChhID09PSAxKSA/IGByZ2IoJHtyfSwke2d9LCR7Yn0pYCA6IGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7YTJ9KWBcclxuICB9LFxyXG5cclxuICAvLyBDb252ZXJ0IDQgaW50cywgaCxzLGwsYSwgaCBpbiBbMC0zNjBdLCBzLGwgaW4gWzAtMTAwXSUgYSBpbiBbMC0yNTVdIHRvIGFcclxuICAvLyBjc3MgY29sb3Igc3RyaW5nLiBBbHBoYSBcImFcIiBpcyBjb252ZXJ0ZWQgdG8gZmxvYXQgaW4gMC0xIGZvciBjc3Mgc3RyaW5nLlxyXG4gIC8vXHJcbiAgLy8gTk9URTogaD0wIGFuZCBoPTM2MCBhcmUgdGhlIHNhbWUsIHVzZSBoIGluIDAtMzU5IGZvciB1bmlxdWUgY29sb3JzLlxyXG4gIGhzbFN0cmluZyAoaCwgcywgbCwgYSA9IDI1NSkge1xyXG4gICAgYSA9IGEgLyAyNTU7IGNvbnN0IGE0ID0gYS50b1ByZWNpc2lvbig0KTtcclxuICAgIHJldHVybiAoYSA9PT0gMSkgPyBgaHNsKCR7aH0sJHtzfSUsJHtsfSUpYCA6IGBoc2xhKCR7aH0sJHtzfSUsJHtsfSUsJHthNH0pYFxyXG4gIH0sXHJcblxyXG4gIC8vIFJldHVybiBhIGh0bWwvY3NzIGhleCBjb2xvciBzdHJpbmcgZm9yIGFuIHIsZyxiIG9wYXF1ZSBjb2xvciAoYT0yNTUpLlxyXG4gIC8vIEhleCBzdHJpbmdzIGRvIG5vdCBzdXBwb3J0IGFscGhhLlxyXG4gIC8vXHJcbiAgLy8gQm90aCAjbm5uIGFuZCAjbm5ubm5uIGZvcm1zIHN1cHBvcnRlZC5cclxuICAvLyBEZWZhdWx0IGlzIHRvIGNoZWNrIGZvciB0aGUgc2hvcnQgaGV4IGZvcm0uXHJcbiAgaGV4U3RyaW5nIChyLCBnLCBiLCBzaG9ydE9LID0gdHJ1ZSkge1xyXG4gICAgaWYgKHNob3J0T0spIHtcclxuICAgICAgY29uc3QgW3IwLCBnMCwgYjBdID0gW3IgLyAxNywgZyAvIDE3LCBiIC8gMTddO1xyXG4gICAgICBpZiAodXRpbC5pc0ludGVnZXIocjApICYmIHV0aWwuaXNJbnRlZ2VyKGcwKSAmJiB1dGlsLmlzSW50ZWdlcihiMCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV4U2hvcnRTdHJpbmcocjAsIGcwLCBiMClcclxuICAgIH1cclxuICAgIHJldHVybiBgIyR7KDB4MTAwMDAwMCB8IChiIHwgZyA8PCA4IHwgciA8PCAxNikpLnRvU3RyaW5nKDE2KS5zbGljZSgtNil9YFxyXG4gIH0sXHJcbiAgLy8gUmV0dXJuIHRoZSA0IGNoYXIgc2hvcnQgdmVyc2lvbiBvZiBhIGhleCBjb2xvci4gIEVhY2ggb2YgdGhlIHIsZyxiIHZhbHVlc1xyXG4gIC8vIG11c3QgYmUgaW4gWzAtMTVdLiAgVGhlIHJlc3VsdGluZyBjb2xvciB3aWxsIGJlIGVxdWl2YWxlbnRcclxuICAvLyB0byBgcioxN2AsIGBnKjE3YCwgYGIqMTdgLCByZXN1bHRpbmcgaW4gdGhlIDE2IHZhbHVlczpcclxuICAvL1xyXG4gIC8vICAgICAwLCAxNywgMzQsIDUxLCA2OCwgODUsIDEwMiwgMTE5LCAxMzYsIDE1MywgMTcwLCAxODcsIDIwNCwgMjIxLCAyMzgsIDI1NVxyXG4gIC8vXHJcbiAgLy8gVGhpcyBpcyBlcXVpdmFsZW50IHV0aWwuYUludFJhbXAoMCwyNTUsMTYpLCBpLmUuIDE2IHZhbHVlcyBwZXIgcmdiIGNoYW5uZWwuXHJcbiAgaGV4U2hvcnRTdHJpbmcgKHIsIGcsIGIpIHtcclxuICAgIGlmICgociA+IDE1KSB8fCAoZyA+IDE1KSB8fCAoYiA+IDE1KSkge1xyXG4gICAgICB0aHJvdyBFcnJvcihgaGV4U2hvcnRTdHJpbmc6IG9uZSBvZiAke1tyLCBnLCBiXX0gPiAxNWApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gYCMke3IudG9TdHJpbmcoMTYpfSR7Zy50b1N0cmluZygxNil9JHtiLnRvU3RyaW5nKDE2KX1gXHJcbiAgfSxcclxuXHJcbiAgLy8gVHJpc3RyaW5nIGlzIGEgaHlicmlkIHN0cmluZyBhbmQgaXMgb3VyIHN0YW5kYXJkLiAgSXQgcmV0dXJuczpcclxuICAvL1xyXG4gIC8vICogcmdiYVN0cmluZyBpZiBhIG5vdCAyNTUgKGkuZS4gbm90IG9wYXF1ZSlcclxuICAvLyAqIGhleFN0cmluZyBvdGhlcndpc2VcclxuICAvLyAqIHdpdGggdGhlIGhleFNob3J0U3RyaW5nIGlmIGFwcHJvcHJpYXRlXHJcbiAgdHJpU3RyaW5nIChyLCBnLCBiLCBhID0gMjU1KSB7XHJcbiAgICByZXR1cm4gKGEgPT09IDI1NSkgPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgIHRoaXMuaGV4U3RyaW5nKHIsIGcsIGIsIHRydWUpIDogdGhpcy5yZ2JhU3RyaW5nKHIsIGcsIGIsIGEpXHJcbiAgfSxcclxuXHJcbi8vICMjIyBDU1MgU3RyaW5nIENvbnZlcnNpb25zXHJcblxyXG4gIC8vIFJldHVybiA0IGVsZW1lbnQgYXJyYXkgZ2l2ZW4gYW55IGxlZ2FsIENTUyBzdHJpbmcgY29sb3IuXHJcbiAgLy9cclxuICAvLyBCZWNhdXNlIHN0cmluZ3MgdmFyeSB3aWRlbHk6IENhZGV0Qmx1ZSwgIzBmMCwgcmdiKDI1NSwwLDApLFxyXG4gIC8vIGhzbCgxMjAsMTAwJSw1MCUpLCB3ZSBkbyBub3QgcGFyc2Ugc3RyaW5ncywgaW5zdGVhZCB3ZSBsZXRcclxuICAvLyB0aGUgYnJvd3NlciBkbyBvdXIgd29yazogd2UgZmlsbCBhIDF4MSBjYW52YXMgd2l0aCB0aGUgY3NzIHN0cmluZyBjb2xvcixcclxuICAvLyByZXR1cm5pbmcgdGhlIHIsZyxiLGEgY2FudmFzIEltYWdlRGF0YSBUeXBlZEFycmF5LlxyXG5cclxuICAvLyBUaGUgc2hhcmVkIDF4MSBjYW52YXMgMkQgY29udGV4dC5cclxuICBzaGFyZWRDdHgxeDE6IHV0aWwuY3JlYXRlQ3R4KDEsIDEpLCAvLyBzaGFyZSBhY3Jvc3MgY2FsbHMuXHJcbiAgLy8gQ29udmVydCBhbnkgY3NzIHN0cmluZyB0byA0IGVsZW1lbnQgVWludDhDbGFtcGVkQXJyYXkgVHlwZWRBcnJheS5cclxuICAvLyBJZiB5b3UgbmVlZCBhIEphdmFTY3JpcHQgQXJyYXksIHVzZSBgbmV3IEFycmF5KC4uLlR5cGVkQXJyYXkpYFxyXG4gIHN0cmluZ1RvVWludDhzIChzdHJpbmcpIHtcclxuICAgIHRoaXMuc2hhcmVkQ3R4MXgxLmNsZWFyUmVjdCgwLCAwLCAxLCAxKTtcclxuICAgIHRoaXMuc2hhcmVkQ3R4MXgxLmZpbGxTdHlsZSA9IHN0cmluZztcclxuICAgIHRoaXMuc2hhcmVkQ3R4MXgxLmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xyXG4gICAgcmV0dXJuIHRoaXMuc2hhcmVkQ3R4MXgxLmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhXHJcbiAgfSxcclxuXHJcbiAgLy8gIyMjIFR5cGVkIENvbG9yXHJcbiAgLy8gQSBDb2xvciBpcyBhIDQgZWxlbWVudCBVaW50OENsYW1wZWRBcnJheSwgd2l0aCB0d28gcHJvcGVydGllczpcclxuICAvL1xyXG4gIC8vICogcGl4ZWxBcnJheTogQSBzaW5nbGUgZWxlbWVudCBVaW50MzJBcnJheSB2aWV3IG9uIHRoZSBVaW50OENsYW1wZWRBcnJheVxyXG4gIC8vICogc3RyaW5nOiBhbiBvcHRpb25hbCwgbGF6eSBldmFsdWF0ZWQsIGNzcyBjb2xvciBzdHJpbmcuXHJcbiAgLy9cclxuICAvLyBUaGlzIHByb3ZpZGVzIGEgdW5pdmVyc2FsIGNvbG9yLCBnb29kIGZvciBjYW52YXMyZCBwaXhlbHMsIHdlYmdsICYgaW1hZ2VcclxuICAvLyBUeXBlZEFycmF5cywgYW5kIGNzcy9jYW52YXMyZCBzdHJpbmdzLlxyXG5cclxuICAvLyBDcmVhdGUgQ29sb3IgZnJvbSByLGcsYixhLiBVc2UgYHRvQ29sb3IoKWAgYmVsb3cgZm9yIHN0cmluZ3MgZXRjLlxyXG4gIGNvbG9yIChyLCBnLCBiLCBhID0gMjU1KSB7XHJcbiAgICBjb25zdCB1OGFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFtyLCBnLCBiLCBhXSk7XHJcbiAgICB1OGFycmF5LnBpeGVsQXJyYXkgPSBuZXcgVWludDMyQXJyYXkodThhcnJheS5idWZmZXIpOyAvLyBvbmUgZWxlbWVudCBhcnJheVxyXG4gICAgLy8gTWFrZSB0aGlzIGFuIGluc3RhbmNlIG9mIENvbG9yUHJvdG9cclxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih1OGFycmF5LCBDb2xvclByb3RvKTtcclxuICAgIHJldHVybiB1OGFycmF5XHJcbiAgfSxcclxuICBpc0NvbG9yIChjb2xvcikge1xyXG4gICAgcmV0dXJuIGNvbG9yICYmIGNvbG9yLmNvbnN0cnVjdG9yID09PSBVaW50OENsYW1wZWRBcnJheSAmJiBjb2xvci5waXhlbEFycmF5XHJcbiAgfSxcclxuICAvLyBDcmVhdGUgYSBDb2xvciBmcm9tIGEgY3NzIHN0cmluZywgcGl4ZWwsIEphdmFTY3JpcHQgb3IgVHlwZWQgQXJyYXkuXHJcbiAgLy8gUmV0dXJucyBgYW55YCBpZiBpcyBDb2xvciBhbHJlYWR5LiBVc2VmdWwgZm9yXHJcbiAgLy8gYGBgXHJcbiAgLy8gY3NzOiBgdG9Db2xvcignI2ZmMGEwMCcpYFxyXG4gIC8vIGhzbDogYHRvQ29sb3IoJ2hzbCgyMDAsMTAwJSw1MCUpJylgXHJcbiAgLy8gbmFtZWQgY29sb3JzOiBgdG9Db2xvcignQ2FkZXRCbHVlJylgXHJcbiAgLy8gcGl4ZWxzOiBgdG9Db2xvcig0Mjk0OTQ1MjgwKWBcclxuICAvLyBKYXZhU2NyaXB0IEFycmF5czogYHRvQ29sb3IoWzI1NSwwLDBdKWBcclxuICAvLyBgYGBcclxuICB0b0NvbG9yIChhbnkpIHtcclxuICAgIGlmICh0aGlzLmlzQ29sb3IoYW55KSkgcmV0dXJuIGFueVxyXG4gICAgY29uc3QgdGMgPSB0aGlzLmNvbG9yKDAsIDAsIDAsIDApO1xyXG4gICAgaWYgKHV0aWwuaXNJbnRlZ2VyKGFueSkpIHRjLnNldFBpeGVsKGFueSk7XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgYW55ID09PSAnc3RyaW5nJykgdGMuc2V0Q3NzKGFueSk7XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFueSkgfHwgdXRpbC5pc1VpbnRBcnJheShhbnkpKSB0Yy5zZXRDb2xvciguLi5hbnkpO1xyXG4gICAgZWxzZSBpZiAodXRpbC5pc0Zsb2F0QXJyYXkoYW55KSkgdGMuc2V0V2ViZ2woYW55KTtcclxuICAgIGVsc2UgdGhyb3cgRXJyb3IoJ3RvQ29sb3I6IGludmFsaWQgYXJndW1lbnQnLCBhbnkpXHJcbiAgICByZXR1cm4gdGNcclxuICB9LFxyXG4gIC8vIFJldHVybiBhIHJhbmRvbSByZ2IgQ29sb3IsIGE9MjU1XHJcbiAgcmFuZG9tQ29sb3IgKCkge1xyXG4gICAgY29uc3QgcjI1NSA9ICgpID0+IHV0aWwucmFuZG9tSW50KDI1Nik7IC8vIHJhbmRvbSBpbnQgaW4gWzAsMjU1XVxyXG4gICAgcmV0dXJuIHRoaXMuY29sb3IocjI1NSgpLCByMjU1KCksIHIyNTUoKSlcclxuICB9XHJcbiAgLy8gQSBzdGF0aWMgdHJhbnNwYXJlbnQgY29sb3IsIHNldCBhdCBlbmQgb2YgZmlsZVxyXG4gIC8vIHRyYW5zcGFyZW50OiBudWxsXHJcbn07XHJcblxyXG4vLyBQcm90b3R5cGUgZm9yIENvbG9yLiBHZXR0ZXJzL3NldHRlcnMgZm9yIHVzYWJpbGl0eSwgbWF5IGJlIHNsb3dlci5cclxuY29uc3QgQ29sb3JQcm90byA9IHtcclxuICAvLyBJbmhlcml0IGZyb20gVWludDhDbGFtcGVkQXJyYXlcclxuICBfX3Byb3RvX186IFVpbnQ4Q2xhbXBlZEFycmF5LnByb3RvdHlwZSxcclxuXHJcbiAgLy8gU2V0IHRoZSBDb2xvciB0byBuZXcgcmdiYSB2YWx1ZXMuXHJcbiAgc2V0Q29sb3IgKHIsIGcsIGIsIGEgPSAyNTUpIHtcclxuICAgIHRoaXMuY2hlY2tDb2xvckNoYW5nZSgpO1xyXG4gICAgdGhpc1swXSA9IHI7IHRoaXNbMV0gPSBnOyB0aGlzWzJdID0gYjsgdGhpc1szXSA9IGE7XHJcbiAgfSxcclxuICAvLyBObyByZWFsIG5lZWQgZm9yIGdldENvbG9yLCBpdCAqaXMqIHRoZSB0eXBlZCBVaW50OCBhcnJheVxyXG4gIHNldCByZ2IgKHJnYmFBcnJheSkgeyB0aGlzLnNldENvbG9yKC4uLnJnYmFBcnJheSk7IH0sXHJcbiAgZ2V0IHJnYiAoKSB7IHJldHVybiB0aGlzIH0sXHJcblxyXG4gIC8vIFNldCB0aGUgQ29sb3IgdG8gYSBuZXcgcGl4ZWwgdmFsdWVcclxuICBzZXRQaXhlbCAocGl4ZWwpIHtcclxuICAgIHRoaXMuY2hlY2tDb2xvckNoYW5nZSgpO1xyXG4gICAgdGhpcy5waXhlbEFycmF5WzBdID0gcGl4ZWw7XHJcbiAgfSxcclxuICAvLyBHZXQgdGhlIHBpeGVsIHZhbHVlXHJcbiAgZ2V0UGl4ZWwgKCkgeyByZXR1cm4gdGhpcy5waXhlbEFycmF5WzBdIH0sXHJcbiAgZ2V0IHBpeGVsICgpIHsgcmV0dXJuIHRoaXMuZ2V0UGl4ZWwoKSB9LFxyXG4gIHNldCBwaXhlbCAocGl4ZWwpIHsgdGhpcy5zZXRQaXhlbChwaXhlbCk7IH0sXHJcblxyXG4gIC8vIFNldCBwaXhlbC9yZ2JhIHZhbHVlcyB0byBlcXVpdmFsZW50IG9mIHRoZSBjc3Mgc3RyaW5nLlxyXG4gIC8vICdyZWQnLCAnI2YwMCcsICdmZjAwMDAnLCAncmdiKDI1NSwwLDApJywgZXRjLlxyXG4gIC8vXHJcbiAgLy8gRG9lcyAqbm90KiBzZXQgdGhlIGNoYWNoZWQgdGhpcy5zdHJpbmcsIHdoaWNoIHdpbGwgYmUgbGF6aWx5IGV2YWx1YXRlZFxyXG4gIC8vIHRvIGl0cyBjb21tb24gdHJpU3RyaW5nIGJ5IGdldENzcygpLiBUaGUgYWJvdmUgd291bGQgYWxsIHJldHVybiAnI2YwMCcuXHJcbiAgc2V0Q3NzIChzdHJpbmcpIHtcclxuICAgIHJldHVybiB0aGlzLnNldENvbG9yKC4uLkNvbG9yLnN0cmluZ1RvVWludDhzKHN0cmluZykpXHJcbiAgfSxcclxuICAvLyBSZXR1cm4gdGhlIHRyaVN0cmluZyBmb3IgdGhpcyBDb2xvciwgY2FjaGVkIGluIHRoZSBAc3RyaW5nIHZhbHVlXHJcbiAgZ2V0Q3NzICgpIHtcclxuICAgIGlmICh0aGlzLnN0cmluZyA9PSBudWxsKSB0aGlzLnN0cmluZyA9IENvbG9yLnRyaVN0cmluZyguLi50aGlzKTtcclxuICAgIHJldHVybiB0aGlzLnN0cmluZ1xyXG4gIH0sXHJcbiAgZ2V0IGNzcyAoKSB7IHJldHVybiB0aGlzLmdldENzcygpIH0sXHJcbiAgc2V0IGNzcyAoc3RyaW5nKSB7IHRoaXMuc2V0Q3NzKHN0cmluZyk7IH0sXHJcblxyXG4gIC8vIE5vdGU6IHdlYmdsIGNvbG9ycyBhcmUgMyBSR0IgZmxvYXRzIChubyBBKSBpZiBBIGlzIDI1NS5cclxuICBzZXRXZWJnbCAoZmxvYXRBcnJheSkge1xyXG4gICAgdGhpcy5zZXRDb2xvciggLy8gT0sgaWYgZmxvYXQgKiAyNTUgbm9uLWludCwgc2V0Q29sb3Igc3RvcmVzIGludG8gdWludDggYXJyYXlcclxuICAgICAgZmxvYXRBcnJheVswXSAqIDI1NSwgZmxvYXRBcnJheVsxXSAqIDI1NSwgZmxvYXRBcnJheVsyXSAqIDI1NSxcclxuICAgICAgZmxvYXRBcnJheS5sZW5ndGggPT09IDQgPyBmbG9hdEFycmF5WzNdICogMjU1IDogdW5kZWZpbmVkKTtcclxuICB9LFxyXG4gIGdldFdlYmdsICgpIHtcclxuICAgIGlmICh0aGlzLmZsb2F0QXJyYXkgPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBmbG9hdHMgPSBbdGhpc1swXSAvIDI1NSwgdGhpc1sxXSAvIDI1NSwgdGhpc1syXSAvIDI1NV07XHJcbiAgICAgIGlmICh0aGlzWzNdICE9PSAyNTUpIGZsb2F0cy5wdXNoKHRoaXNbM10gLyAyNTUpO1xyXG4gICAgICB0aGlzLmZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGZsb2F0cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5mbG9hdEFycmF5XHJcbiAgfSxcclxuICBnZXQgd2ViZ2wgKCkgeyByZXR1cm4gdGhpcy5nZXRXZWJnbCgpIH0sXHJcbiAgc2V0IHdlYmdsIChmbG9hdEFycmF5KSB7IHRoaXMuc2V0V2ViZ2woZmxvYXRBcnJheSk7IH0sXHJcblxyXG4gIC8vIEhvdXNla2VlcGluZyB3aGVuIHRoZSBjb2xvciBpcyBtb2RpZmllZC5cclxuICBjaGVja0NvbG9yQ2hhbmdlICgpIHtcclxuICAgIC8vIFJlc2V0IHN0cmluZyAmIHdlYmdsIG9uIGNvbG9yIGNoYW5nZS5cclxuICAgIHRoaXMuc3RyaW5nID0gbnVsbDsgLy8gd2lsbCBiZSBsYXp5IGV2YWx1YXRlZCB2aWEgZ2V0Q3NzLlxyXG4gICAgdGhpcy5mbG9hdEFycmF5ID0gbnVsbDtcclxuICB9LFxyXG4gIC8vIFJldHVybiB0cnVlIGlmIGNvbG9yIGlzIHNhbWUgdmFsdWUgYXMgbXlzZWxmLCBjb21wYXJpbmcgcGl4ZWxzXHJcbiAgZXF1YWxzIChjb2xvcikgeyByZXR1cm4gdGhpcy5nZXRQaXhlbCgpID09PSBjb2xvci5nZXRQaXhlbCgpIH0sXHJcbiAgdG9TdHJpbmcgKCkgeyByZXR1cm4gYFske0FycmF5LmZyb20odGhpcykudG9TdHJpbmcoKX1dYCB9LFxyXG4gIC8vIFJldHVybiBhIFtkaXN0YW5jZSBtZXRyaWNdKFxyXG4gIC8vIGh0dHA6Ly93d3cuY29tcHVwaGFzZS5jb20vY21ldHJpYy5odG0pIGJldHdlZW4gdHdvIGNvbG9ycy5cclxuICAvLyBNYXggZGlzdGFuY2UgaXMgcm91Z2hseSA3NjUgKDMqMjU1KSwgZm9yIGJsYWNrICYgd2hpdGUuXHJcbiAgLy8gRm9yIG91ciBwdXJwb3Nlcywgb21pdHRpbmcgdGhlIHNxcnQgd2lsbCBub3QgZWZmZWN0IG91ciByZXN1bHRzXHJcbiAgcmdiRGlzdGFuY2UgKHIsIGcsIGIpIHtcclxuICAgIGNvbnN0IFtyMSwgZzEsIGIxXSA9IHRoaXM7XHJcbiAgICBjb25zdCByTWVhbiA9IE1hdGgucm91bmQoKHIxICsgcikgLyAyKTtcclxuICAgIGNvbnN0IFtkciwgZGcsIGRiXSA9IFtyMSAtIHIsIGcxIC0gZywgYjEgLSBiXTtcclxuICAgIGNvbnN0IFtkcjIsIGRnMiwgZGIyXSA9IFtkciAqIGRyLCBkZyAqIGRnLCBkYiAqIGRiXTtcclxuICAgIGNvbnN0IGRpc3RhbmNlU3EgPVxyXG4gICAgICAoKCg1MTIgKyByTWVhbikgKiBkcjIpID4+IDgpICsgKDQgKiBkZzIpICsgKCgoNzY3IC0gck1lYW4pICogZGIyKSA+PiA4KTtcclxuICAgIHJldHVybiBkaXN0YW5jZVNxIC8vIE1hdGguc3FydChkaXN0YW5jZVNxKVxyXG4gIH1cclxufTtcclxuXHJcbi8vIEEgY29sb3JtYXAgaXMgc2ltcGx5IGFuIGFycmF5IG9mIHR5cGVkQ29sb3JzIHdpdGggc2V2ZXJhbCB1dGlsaXRpZXMgc3VjaFxyXG4vLyBhcyByYW5kb21Db2xvciwgY2xvc2VzdENvbG9yIGV0Yy5cclxuLy8gVGhpcyBhbGxvd3MgdGhlIGNvbG9ycyB0byBiZSBzaW1wbGUgaW50ZWdlciBpbmRpY2VzXHJcbi8vIGludG8gdGhlIEFycmF5LiBUaGV5IGFyZSBhbHNvIGRlc2lnbmVkIHRvIGJlIHdlYmdsLXJlYWR5LCBiZWluZyBhXHJcbi8vIEdMU0wgXCJVbmlmb3JtXCIgdmFyaWFibGUgVHlwZWRBcnJheSBmb3IgY29sb3JzLlxyXG5cclxuY29uc3QgQ29sb3JNYXAgPSB7XHJcbi8vICMjIyBDb2xvciBBcnJheSBVdGlsaXRpZXNcclxuICAvLyBTZXZlcmFsIHV0aWxpdGllcyBmb3IgY3JlYXRpbmcgY29sb3IgYXJyYXlzXHJcblxyXG4vLyAjIyMgR3JhZGllbnRzXHJcblxyXG4gIC8vIEFzayB0aGUgYnJvd3NlciB0byB1c2UgdGhlIGNhbnZhcyBncmFkaWVudCBmZWF0dXJlXHJcbiAgLy8gdG8gY3JlYXRlIG5Db2xvcnMgZ2l2ZW4gdGhlIGdyYWRpZW50IGNvbG9yIHN0b3BzIGFuZCBsb2NzLlxyXG4gIC8vIFNlZSBNb3ppbGxhIFtHcmFkaWVudCBEb2NdKFxyXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9saW5lYXItZ3JhZGllbnQpLFxyXG4gIC8vXHJcbiAgLy8gVGhpcyBpcyBhIHBvd2VyZnVsIGJyb3dzZXIgZmVhdHVyZSwgY2FuIGJlXHJcbiAgLy8gdXNlZCB0byBjcmVhdGUgYWxsIHRoZSBNYXRMYWIgY29sb3JtYXBzLlxyXG4gIC8vXHJcbiAgLy8gU3RvcHMgYXJlIGNzcyBzdHJpbmdzIG9yIHJnYmEgYXJyYXlzLlxyXG4gIC8vIExvY3MgYXJlIGZsb2F0cyBmcm9tIDAtMSwgZGVmYXVsdCBpcyBlcXVhbGx5IHNwYWNlZC5cclxuICBncmFkaWVudEltYWdlRGF0YSAobkNvbG9ycywgc3RvcHMsIGxvY3MpIHtcclxuICAgIC8vIENvbnZlcnQgdGhlIGNvbG9yIHN0b3BzIHRvIGNzcyBzdHJpbmdzXHJcbiAgICBzdG9wcyA9IHN0b3BzLm1hcCgoYykgPT4gQXJyYXkuaXNBcnJheShjKSA/IENvbG9yLnJnYmFTdHJpbmcoLi4uYykgOiBjKTtcclxuICAgIGNvbnN0IGN0eCA9IHV0aWwuY3JlYXRlQ3R4KG5Db2xvcnMsIDEpO1xyXG4gICAgLy8gSW5zdGFsbCBkZWZhdWx0IGxvY3MgaWYgbm9uZSBwcm92aWRlXHJcbiAgICBpZiAoIWxvY3MpIGxvY3MgPSB1dGlsLmFSYW1wKDAsIDEsIHN0b3BzLmxlbmd0aCk7XHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgZ3JhZGllbnQgYW5kIGZpbGwgaXQgd2l0aCB0aGUgY29sb3Igc3RvcHNcclxuICAgIGNvbnN0IGdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgbkNvbG9ycywgMCk7XHJcbiAgICB1dGlsLnJlcGVhdChzdG9wcy5sZW5ndGgsIChpKSA9PiBncmFkLmFkZENvbG9yU3RvcChsb2NzW2ldLCBzdG9wc1tpXSkpO1xyXG4gICAgLy8gRHJhdyB0aGUgZ3JhZGllbnQsIHJldHVybmluZyB0aGUgaW1hZ2UgZGF0YSBUeXBlZEFycmF5XHJcbiAgICBjdHguZmlsbFN0eWxlID0gZ3JhZDtcclxuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBuQ29sb3JzLCAxKTtcclxuICAgIHJldHVybiB1dGlsLmN0eEltYWdlRGF0YShjdHgpLmRhdGFcclxuICB9LFxyXG5cclxuLy8gIyMjIEFycmF5IENvbnZlcnNpb24gVXRpbGl0aWVzXHJcblxyXG4gIC8vIENvbnZlcnQgYSBVaW50OEFycmF5IGludG8gQXJyYXkgb2YgNCBlbGVtZW50IHR5cGVkQ29sb3JzLlxyXG4gIC8vIFVzZWZ1bCBmb3IgY29udmVydGluZyBJbWFnZURhdGEgb2JqZWN0cyBsaWtlIGdyYWRpZW50cyB0byBjb2xvcm1hcHMuXHJcbiAgLy8gV2ViR0wgcmVhZHk6IHRoZSBhcnJheS50eXBlZEFycmF5IGlzIHN1aXRhYmxlIGZvciBVbmlmb3Jtcy5cclxuICB0eXBlZEFycmF5dG9Db2xvcnMgKHR5cGVkQXJyYXkpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICB1dGlsLnN0ZXAodHlwZWRBcnJheS5sZW5ndGgsIDQsXHJcbiAgICAgIC8vIE5vdGU6IGNhbid0IHNoYXJlIHN1YmFycmF5IGFzIGNvbG9yJ3MgdHlwZWQgYXJyYXk6XHJcbiAgICAgIC8vIGl0J3MgYnVmZmVyIGlzIGZvciBlbnRpcmUgYXJyYXksIG5vdCBqdXN0IHN1YmFycmF5LlxyXG4gICAgICAoaSkgPT4gYXJyYXkucHVzaChDb2xvci5jb2xvciguLi50eXBlZEFycmF5LnN1YmFycmF5KGksIGkgKyA0KSkpKTtcclxuICAgIGFycmF5LnR5cGVkQXJyYXkgPSB0eXBlZEFycmF5O1xyXG4gICAgcmV0dXJuIGFycmF5XHJcbiAgfSxcclxuICAvLyBDb252ZXJ0IGFuIEFycmF5IG9mIEFycmF5cyB0byBhbiBBcnJheSBvZiB0eXBlZENvbG9ycy5cclxuICAvLyBXZWJnbCByZWFkeSBhcyBhYm92ZS5cclxuICBhcnJheXNUb0NvbG9ycyAoYXJyYXkpIHtcclxuICAgIGNvbnN0IHR5cGVkQXJyYXkgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYXJyYXkubGVuZ3RoICogNCk7XHJcbiAgICB1dGlsLnJlcGVhdChhcnJheS5sZW5ndGgsIChpKSA9PiB7XHJcbiAgICAgIGNvbnN0IGEgPSBhcnJheVtpXTtcclxuICAgICAgaWYgKGEubGVuZ3RoID09PSAzKSBhLnB1c2goMjU1KTtcclxuICAgICAgdHlwZWRBcnJheS5zZXQoYSwgaSAqIDQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlZEFycmF5dG9Db2xvcnModHlwZWRBcnJheSlcclxuICB9LFxyXG5cclxuICAvLyBQZXJtdXRlIHRoZSB2YWx1ZXMgb2YgMyBhcnJheXMuIEV4OlxyXG4gIC8vXHJcbiAgLy8gWzEsMl0sWzNdLFs0LDVdIC0+IFsgWzEsMyw0XSxbMSwzLDVdLFsyLDMsNF0sWzIsMyw1XSBdXHJcbiAgcGVybXV0ZUFycmF5cyAoQTEsIEEyID0gQTEsIEEzID0gQTEpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGEzIG9mIEEzKSAvLyBzb3J0YSBvZGQgY29uc3Qgd29ya3Mgd2l0aCB0aHMsIGJ1dC4uLlxyXG4gICAgICBmb3IgKGNvbnN0IGEyIG9mIEEyKVxyXG4gICAgICAgIGZvciAoY29uc3QgYTEgb2YgQTEpXHJcbiAgICAgICAgICBhcnJheS5wdXNoKFthMSwgYTIsIGEzXSk7XHJcbiAgICByZXR1cm4gYXJyYXlcclxuICB9LFxyXG4gIC8vIFVzZSBwZXJtdXRlQXJyYXlzIHRvIGNyZWF0ZSB1bmlmb3JtbHkgc3BhY2VkIGNvbG9yIHJhbXAgcGVybXV0YXRpb24uXHJcbiAgLy8gRXg6IGlmIG51bVJzIGlzIDMsIHBlcm11dGVBcnJheXMncyBBMSB3b3VsZCBiZSBbMCwgMTI3LCAyNTVdXHJcbiAgcGVybXV0ZVJHQkNvbG9ycyAobnVtUnMsIG51bUdzID0gbnVtUnMsIG51bUJzID0gbnVtUnMpIHtcclxuICAgIGNvbnN0IHRvUmFtcCA9IChudW0pID0+IHV0aWwuYUludFJhbXAoMCwgMjU1LCBudW0pO1xyXG4gICAgY29uc3QgcmFtcHMgPSBbbnVtUnMsIG51bUdzLCBudW1Cc10ubWFwKHRvUmFtcCk7XHJcbiAgICByZXR1cm4gdGhpcy5wZXJtdXRlQXJyYXlzKC4uLnJhbXBzKVxyXG4gIH0sXHJcblxyXG4vLyAjIyMgQ29sb3JNYXBzXHJcblxyXG4gIC8vIENvbG9yTWFwcyBhcmUgQXJyYXlzIG9mIFR5cGVkQ29sb3JzIHdpdGggdGhlc2UgYWRkaXRpb25hbCBtZXRob2RzLiBXZWJnbFxyXG4gIC8vIHJlYWR5IGlmIG1hZGUgdy8gYHR5cGVkQXJyYXl0b0NvbG9yc2Agb3IgYGFycmF5c1RvQ29sb3JzYCBhYm92ZS5cclxuICAvLyBVc2VkIHRvIGJlIG1lbW9yeSBlZmZlY2VudCAoc2hhcmVkIGNvbG9ycyksIHdlYmdsIGNvbXBhdGlibGUsICBhbmQgZm9yXHJcbiAgLy8gTWF0TGFiLWxpa2UgY29sb3ItYXMtZGF0YS5cclxuICBDb2xvck1hcFByb3RvOiB7XHJcbiAgICAvLyBJbmhlcml0IGZyb20gQXJyYXlcclxuICAgIF9fcHJvdG9fXzogQXJyYXkucHJvdG90eXBlLFxyXG4gICAgLy8gQ3JlYXRlIGEgW3NwYXJzZSBhcnJheV0oaHR0cHM6Ly9nb28uZ2wvbFFscTVrKSBvZiBpbmRleFtwaXhlbF0gPSBwaXhlbC5cclxuICAgIC8vIFVzZWQgYnkgaW5kZXhPZiBiZWxvdyBmb3IgZXhhY3QgbWF0Y2ggb2YgYSBjb2xvciB3aXRoaW4gdGhlIGNvbG9ybWFwLlxyXG4gICAgY3JlYXRlSW5kZXggKCkge1xyXG4gICAgICB0aGlzLmluZGV4ID0gW107XHJcbiAgICAgIHV0aWwucmVwZWF0KHRoaXMubGVuZ3RoLCAoaSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHB4ID0gdGhpc1tpXS5nZXRQaXhlbCgpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhbcHhdID0gaTtcclxuICAgICAgICBpZiAodGhpcy5jc3NOYW1lcykgdGhpcy5pbmRleFt0aGlzLmNzc05hbWVzW2ldXSA9IGk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8vIFJldHVybiBhIHJhbmRvbSBpbmRleCBpbnRvIHRoZSBjb2xvcm1hcCBhcnJheVxyXG4gICAgcmFuZG9tSW5kZXggKCkgeyByZXR1cm4gdXRpbC5yYW5kb21JbnQodGhpcy5sZW5ndGgpIH0sXHJcbiAgICAvLyBSZXR1cm4gYSByYW5kb20gY29sb3Igd2l0aGluIHRoZSBjb2xvcm1hcFxyXG4gICAgcmFuZG9tQ29sb3IgKCkgeyByZXR1cm4gdGhpc1t0aGlzLnJhbmRvbUluZGV4KCldIH0sXHJcbiAgICAvLyBSZXR1cm4gdGhlIGluZGV4IG9mIGEgdHlwZWRDb2xvciB3aXRoaW4gdGhlIGNvbG9ybWFwLFxyXG4gICAgLy8gdW5kZWZpbmVkIGlmIG5vIGV4YWN0IG1hdGNoLlxyXG4gICAgLy8gVXNlIHRoZSBgY2xvc2VzdGAgbWV0aG9kcyBiZWxvdyBmb3IgbmVhcmVzdCwgbm90IGV4YWN0LCBtYXRjaC5cclxuICAgIGluZGV4T2YgKGNvbG9yKSB7XHJcbiAgICAgIGlmICh0aGlzLmluZGV4KSByZXR1cm4gdGhpcy5pbmRleFtjb2xvci5nZXRQaXhlbCgpXVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgaWYgKGNvbG9yLmVxdWFscyh0aGlzW2ldKSkgcmV0dXJuIGlcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgfSxcclxuICAgIC8vIFJldHVybiBjb2xvciBzY2FsZWQgYnkgbnVtYmVyIHdpdGhpbiBbbWluLCBtYXhdLlxyXG4gICAgLy8gQSBsaW5lYXIgaW50ZXJwb2xhdGlvbiAodXRpbC5sZXJwKSBpbiBbMCwgbGVuZ3RoLTFdLlxyXG4gICAgLy8gVXNlZCB0byBtYXRjaCBkYXRhIGRpcmVjdGx5IHRvIGEgY29sb3IgYXMgaW4gTWF0TGFiLlxyXG4gICAgLy9cclxuICAgIC8vIEV4OiBzY2FsZUNvbG9yKDI1LCAwLCA1MCkgcmV0dXJucyB0aGUgY29sb3IgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY29sb3JtYXBcclxuICAgIHNjYWxlQ29sb3IgKG51bWJlciwgbWluLCBtYXgpIHtcclxuICAgICAgbnVtYmVyID0gdXRpbC5jbGFtcChudW1iZXIsIG1pbiwgbWF4KTtcclxuICAgICAgY29uc3Qgc2NhbGUgPSB1dGlsLmxlcnBTY2FsZShudW1iZXIsIG1pbiwgbWF4KTtcclxuICAgICAgY29uc3QgaW5kZXggPSBNYXRoLnJvdW5kKHV0aWwubGVycCgwLCB0aGlzLmxlbmd0aCAtIDEsIHNjYWxlKSk7XHJcbiAgICAgIHJldHVybiB0aGlzW2luZGV4XVxyXG4gICAgfSxcclxuICAgIC8vIFJldHVybiB0aGUgVWludDggYXJyYXkgdXNlZCB0byBjcmVhdGUgdGhlIHR5cGVkQ29sb3JzLFxyXG4gICAgLy8gdW5kZWZpbmVkIGlmIG5vdCB3ZWJnbCByZWFkeS5cclxuICAgIHdlYmdsQXJyYXkgKCkgeyByZXR1cm4gdGhpcy50eXBlZEFycmF5IH0sXHJcblxyXG4gICAgLy8gRGVidWdnaW5nOiBSZXR1cm4gYSBzdHJpbmcgd2l0aCBsZW5ndGggYW5kIGFycmF5IG9mIGNvbG9yc1xyXG4gICAgdG9TdHJpbmcgKCkgeyByZXR1cm4gYCR7dGhpcy5sZW5ndGh9ICR7dXRpbC5hcnJheXNUb1N0cmluZyh0aGlzKX1gIH0sXHJcblxyXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBjb2xvcm1hcCBjb2xvcnMsIHJldHVybmluZyB0aGUgaW5kZXggb2YgdGhlXHJcbiAgICAvLyBtaW4gdHlwZWRDb2xvci5yZ2JEaXN0YW5jZSB2YWx1ZSBmcm9tIHIsIGcsIGJcclxuICAgIHJnYkNsb3Nlc3RJbmRleCAociwgZywgYikge1xyXG4gICAgICBsZXQgbWluRGlzdCA9IEluZmluaXR5O1xyXG4gICAgICBsZXQgaXhNaW4gPSAwO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkID0gdGhpc1tpXS5yZ2JEaXN0YW5jZShyLCBnLCBiKTtcclxuICAgICAgICBpZiAoZCA8IG1pbkRpc3QpIHtcclxuICAgICAgICAgIG1pbkRpc3QgPSBkO1xyXG4gICAgICAgICAgaXhNaW4gPSBpO1xyXG4gICAgICAgICAgaWYgKGQgPT09IDApIHJldHVybiBpeE1pblxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaXhNaW5cclxuICAgIH0sXHJcbiAgICAvLyBSZXR1cm4gdGhlIGNvbG9yIHdpdGggdGhlIHJnYkNsb3Nlc3RJbmRleCB2YWx1ZVxyXG4gICAgcmdiQ2xvc2VzdENvbG9yIChyLCBnLCBiKSB7IHJldHVybiB0aGlzW3RoaXMucmdiQ2xvc2VzdEluZGV4KHIsIGcsIGIpXSB9LFxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2xvc2VzdCBjdWJlIGluZGV4IGZvciB0aGUgZ2l2ZW4gciwgZywgYiB2YWx1ZXMuXHJcbiAgICAvLyBGYXN0ZXIgdGhhbiByZ2JDbG9zZXN0SW5kZXgsIGRvZXMgZGlyZWN0IGNhbGN1bGF0aW9uLCBub3QgaXRlcmF0aW9uLlxyXG4gICAgY3ViZUNsb3Nlc3RJbmRleCAociwgZywgYikge1xyXG4gICAgICBjb25zdCBjdWJlID0gdGhpcy5jdWJlO1xyXG4gICAgICBjb25zdCByZ2JTdGVwcyA9IGN1YmUubWFwKGMgPT4gMjU1IC8gKGMgLSAxKSk7XHJcbiAgICAgIGNvbnN0IHJnYkxvY3MgPSBbciwgZywgYl0ubWFwKChjLCBpKSA9PiBNYXRoLnJvdW5kKGMgLyByZ2JTdGVwc1tpXSkpO1xyXG4gICAgICBjb25zdCBbckxvYywgZ0xvYywgYkxvY10gPSByZ2JMb2NzO1xyXG4gICAgICByZXR1cm4gKHJMb2MpICsgKGdMb2MgKiBjdWJlWzBdKSArIChiTG9jICogY3ViZVswXSAqIGN1YmVbMV0pXHJcbiAgICB9LFxyXG4gICAgY3ViZUNsb3Nlc3RDb2xvciAociwgZywgYikgeyByZXR1cm4gdGhpc1t0aGlzLmN1YmVDbG9zZXN0SW5kZXgociwgZywgYildIH0sXHJcblxyXG4gICAgLy8gQ2hvb3NlIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgZm9yIGZpbmRpbmcgY2xvc2VzdCBpbmRleC5cclxuICAgIC8vIExldHMgdGhlIHVzZXIgc3BlY2lmeSBhbnkgY29sb3IsIGFuZCBsZXQgdGhlIGNvbG9ybWFwXHJcbiAgICAvLyB1c2UgdGhlIGJlc3QgbWF0Y2guXHJcbiAgICBjbG9zZXN0SW5kZXggKHIsIGcsIGIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3ViZSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICB0aGlzLmN1YmVDbG9zZXN0SW5kZXgociwgZywgYikgOiB0aGlzLnJnYkNsb3Nlc3RJbmRleChyLCBnLCBiKVxyXG4gICAgfSxcclxuICAgIC8vIENob29zZSB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGZvciBmaW5kaW5nIGNsb3Nlc3QgY29sb3JcclxuICAgIGNsb3Nlc3RDb2xvciAociwgZywgYikgeyByZXR1cm4gdGhpc1t0aGlzLmNsb3Nlc3RJbmRleChyLCBnLCBiKV0gfVxyXG4gIH0sXHJcblxyXG4vLyAjIyMgVXRpbGl0aWVzIGZvciBjb25zdHJ1Y3RpbmcgQ29sb3JNYXBzXHJcblxyXG4gIC8vIENvbnZlcnQgYW4gYXJyYXkgb2YgcmdiKGEpIEFycmF5cyBvciBUeXBlZENvbG9ycyB0byBhIHdlYmdsLXJlYWR5IGNvbG9ybWFwLlxyXG4gIGJhc2ljQ29sb3JNYXAgKGNvbG9ycykge1xyXG4gICAgY29sb3JzID0gdGhpcy5hcnJheXNUb0NvbG9ycyhjb2xvcnMpO1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbG9ycywgdGhpcy5Db2xvck1hcFByb3RvKTtcclxuICAgIHJldHVybiBjb2xvcnNcclxuICB9LFxyXG4gIC8vIENyZWF0ZSBhIGdyYXkgbWFwIChncmF5OiByPWc9YilcclxuICAvLyBUaGVzZSBhcmUgdHlwaWNhbGx5IDI1NiBlbnRyaWVzIGJ1dCBjYW4gYmUgc21hbGxlclxyXG4gIC8vIGJ5IHBhc3NpbmcgYSBzaXplIHBhcmFtZXRlciBhbmQgdGhlIG1pbi9tYXggcmFuZ2UuXHJcbiAgZ3JheUNvbG9yTWFwIChtaW4gPSAwLCBtYXggPSAyNTUsIHNpemUgPSBtYXggLSBtaW4gKyAxKSB7XHJcbiAgICBjb25zdCByYW1wID0gdXRpbC5hSW50UmFtcChtaW4sIG1heCwgc2l6ZSk7XHJcbiAgICByZXR1cm4gdGhpcy5iYXNpY0NvbG9yTWFwKHJhbXAubWFwKChpKSA9PiBbaSwgaSwgaV0pKVxyXG4gIH0sXHJcblxyXG4gIC8vIENyZWF0ZSBhIGNvbG9ybWFwIGJ5IHBlcm11dGVkIHJnYiB2YWx1ZXMuXHJcbiAgLy9cclxuICAvLyBudW1ScywgbnVtR3MsIG51bUJzIGFyZSBudW1iZXJzLCB0aGUgbnVtYmVyIG9mIHN0ZXBzIGJldGVlbiAwLTI1NS5cclxuICAvLyBFeDogbnVtUnMgPSAzLCBjb3JyZXNwb25kcyB0byAwLCAxMjgsIDI1NS5cclxuICAvLyBOT1RFOiB0aGUgZGVmYXVsdHM6IHJnYkNvbG9yQ3ViZSg2KSBjcmVhdGVzIGEgYDYgKiA2ICogNmAgY3ViZS5cclxuICByZ2JDb2xvckN1YmUgKG51bVJzLCBudW1HcyA9IG51bVJzLCBudW1CcyA9IG51bVJzKSB7XHJcbiAgICBjb25zdCBhcnJheSA9IHRoaXMucGVybXV0ZVJHQkNvbG9ycyhudW1ScywgbnVtR3MsIG51bUJzKTtcclxuICAgIGNvbnN0IG1hcCA9IHRoaXMuYmFzaWNDb2xvck1hcChhcnJheSk7XHJcbiAgICAvLyBTYXZlIHRoZSBwYXJhbWV0ZXJzIGZvciBmYXN0IGNvbG9yIGNhbGN1bGF0aW9ucy5cclxuICAgIG1hcC5jdWJlID0gW251bVJzLCBudW1HcywgbnVtQnNdO1xyXG4gICAgcmV0dXJuIG1hcFxyXG4gIH0sXHJcbiAgLy8gQ3JlYXRlIGEgY29sb3JtYXAgYnkgcGVybXV0aW5nIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIGFycmF5cy5cclxuICAvLyBTaW1pbGFyIHRvIGFib3ZlIGJ1dCB3aXRoIGFycmF5cyB0aGF0IG1heSBoYXZlIGFyYml0cmFyeSB2YWx1ZXMuXHJcbiAgcmdiQ29sb3JNYXAgKFIsIEcsIEIpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gdGhpcy5wZXJtdXRlQXJyYXlzKFIsIEcsIEIpO1xyXG4gICAgcmV0dXJuIHRoaXMuYmFzaWNDb2xvck1hcChhcnJheSlcclxuICB9LFxyXG5cclxuICAvLyBDcmVhdGUgYW4gaHNsIG1hcCwgaW5wdXRzIGFyZSBhcnJheXMgdG8gYmUgcGVybXV0dGVkIGxpa2UgcmdiQ29sb3JNYXAuXHJcbiAgLy8gQ29udmVydCB0aGUgSFNMIHZhbHVlcyB0byBDb2xvci5jb2xvcnMsIGRlZmF1bHQgdG8gYnJpZ2h0IGh1ZSByYW1wIChMPTUwKS5cclxuICBoc2xDb2xvck1hcCAoSCwgUyA9IFsxMDBdLCBMID0gWzUwXSkge1xyXG4gICAgY29uc3QgaHNsQXJyYXkgPSB0aGlzLnBlcm11dGVBcnJheXMoSCwgUywgTCk7XHJcbiAgICBjb25zdCBhcnJheSA9IGhzbEFycmF5Lm1hcChhID0+IENvbG9yLnRvQ29sb3IoQ29sb3IuaHNsU3RyaW5nKC4uLmEpKSk7XHJcbiAgICByZXR1cm4gdGhpcy5iYXNpY0NvbG9yTWFwKGFycmF5KVxyXG4gIH0sXHJcblxyXG4gIC8vIFVzZSBncmFkaWVudCB0byBidWlsZCBhbiByZ2JhIGFycmF5LCB0aGVuIGNvbnZlcnQgdG8gY29sb3JtYXAuXHJcbiAgLy8gU3RvcHMgYXJlIGNzcyBzdHJpbmdzIG9yIHJnYmEgYXJyYXlzLlxyXG4gIC8vIGxvY3MgZGVmYXVsdHMgdG8gZXZlbmx5IHNwYWNlZCwgcHJvYmFibHkgd2hhdCB5b3Ugd2FudC5cclxuICAvL1xyXG4gIC8vIFRoaXMgZWFzaWx5IGNyZWF0ZXMgYWxsIHRoZSBNYXRMYWIgY29sb3JtYXBzIGxpa2UgXCJqZXRcIiBiZWxvdy5cclxuICBncmFkaWVudENvbG9yTWFwIChuQ29sb3JzLCBzdG9wcywgbG9jcykge1xyXG4gICAgY29uc3QgdWludDhhcnJheXMgPSB0aGlzLmdyYWRpZW50SW1hZ2VEYXRhKG5Db2xvcnMsIHN0b3BzLCBsb2NzKTtcclxuICAgIGNvbnN0IHR5cGVkQ29sb3JzID0gdGhpcy50eXBlZEFycmF5dG9Db2xvcnModWludDhhcnJheXMpO1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHR5cGVkQ29sb3JzLCB0aGlzLkNvbG9yTWFwUHJvdG8pO1xyXG4gICAgcmV0dXJuIHR5cGVkQ29sb3JzXHJcbiAgfSxcclxuICAvLyBUaGUgbW9zdCBwb3B1bGFyIE1hdExhYiBncmFkaWVudCwgXCJqZXRcIjpcclxuICBqZXRDb2xvcnM6IFsgWzAsIDAsIDEyN10sIFswLCAwLCAyNTVdLCBbMCwgMTI3LCAyNTVdLCBbMCwgMjU1LCAyNTVdLFxyXG4gICAgWzEyNywgMjU1LCAxMjddLCBbMjU1LCAyNTUsIDBdLCBbMjU1LCAxMjcsIDBdLCBbMjU1LCAwLCAwXSwgWzEyNywgMCwgMF0gXSxcclxuICAvLyBUd28gb3RoZXIgcG9wdWxhciBNYXRMYWIgJ3JhbXAnIGdyYWRpZW50cyBhcmU6XHJcbiAgLy8gKiBPbmUgY29sb3I6IGZyb20gYmxhY2svd2hpdGUgdG8gY29sb3IsIG9wdGlvbmFsbHkgYmFjayB0byB3aGl0ZS9ibGFjay5cclxuICAvLyBzdG9wcyA9IFsnYmxhY2snLCAncmVkJ10gb3IgWyd3aGl0ZScsICdvcmFuZ2UnLCAnYmxhY2snXVxyXG4gIC8vIFRoZSBOZXRMb2dvIG1hcCBpcyBhIGNvbmNhdGVuYXRpb24gb2YgMTQgb2YgdGhlc2UuXHJcbiAgLy8gKiBUd28gY29sb3JzOiBzdG9wcyA9IFsncmVkJywgJ29yYW5nZSddIChibGVuZHMgdGhlIHRvdywgY2VudGVyIGlzIHdoaXRlKVxyXG5cclxuICAvLyBUaGUgMTYgdW5pcXVlIFtDU1MgQ29sb3IgTmFtZXNdKGh0dHBzOi8vZ29vLmdsL3N4bzM2WCksIGNhc2UgaW5zZW5zaXRpdmUuXHJcbiAgLy8gQXF1YSA9PSBDeWFuIGFuZCBGdWNoc2lhID09IE1hZ2VudGEsIDE4IHRvdGFsIGNvbG9yIG5hbWVzLlxyXG4gIC8vIFRoZXNlIHNvcnRlZCBieSBodWUvc2F0dXJhdGlvbi9saWdodCwgaHVlIGluIDAtMzAwIGRlZ3JlZXMuXHJcbiAgLy8gSW4gQ1NTIDIuMSwgdGhlIGNvbG9yICdvcmFuZ2UnIHdhcyBhZGRlZCB0byB0aGUgMTYgY29sb3JzIGFzIGEgMTd0aCBjb2xvclxyXG4gIC8vIFNlZSBbTW96aWxsYSBDb2xvciBEb2NzXShodHRwczovL2dvby5nbC90b2xTblMpIGZvciAqbG90cyogbW9yZSFcclxuICBiYXNpY0NvbG9yTmFtZXM6ICd3aGl0ZSBzaWx2ZXIgZ3JheSBibGFjayByZWQgbWFyb29uIHllbGxvdyBvcmFuZ2Ugb2xpdmUgbGltZSBncmVlbiBjeWFuIHRlYWwgYmx1ZSBuYXZ5IG1hZ2VudGEgcHVycGxlJy5zcGxpdCgnICcpLFxyXG4gIC8vIENyZWF0ZSBhIG5hbWVkIGNvbG9ycyBjb2xvcm1hcFxyXG4gIGNzc0NvbG9yTWFwIChjc3NBcnJheSwgY3JlYXRlTmFtZUluZGV4ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGFycmF5ID0gY3NzQXJyYXkubWFwKHN0ciA9PiBDb2xvci5zdHJpbmdUb1VpbnQ4cyhzdHIpKTtcclxuICAgIGNvbnN0IG1hcCA9IHRoaXMuYmFzaWNDb2xvck1hcChhcnJheSk7XHJcbiAgICBtYXAuY3NzTmFtZXMgPSBjc3NBcnJheTtcclxuICAgIC8vIFJFTUlORDoga2luZGEgdGFja3k/IE1heWJlIG1hcC5uYW1lLnllbGxvdz8gTWF5YmUgZ2VuZXJhbGl6ZSBmb3Igb3RoZXJcclxuICAgIC8vIG1hcCB0eXBlczogbWFwLmNsb3Nlc3QobmFtZSlcclxuICAgIGlmIChjcmVhdGVOYW1lSW5kZXgpIHtcclxuICAgICAgY3NzQXJyYXkuZm9yRWFjaCgobmFtZSwgaXgpID0+IHsgbWFwW25hbWVdID0gbWFwW2l4XTsgfSk7XHJcbiAgICAgIGlmIChtYXAuY3lhbikgbWFwLmFxdWEgPSBtYXAuY3lhbjtcclxuICAgICAgaWYgKG1hcC5tYWdlbnRhKSBtYXAuZnVjaHNpYSA9IG1hcC5tYWdlbnRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcFxyXG4gIH0sXHJcblxyXG4vLyAjIyMgU2hhcmVkIEdsb2JhbCBDb2xvck1hcHNcclxuXHJcbiAgLy8gVGhlIHNoYXJlZCBnbG9iYWwgY29sb3JtYXBzIGFyZSBsYXp5IGV2YWx1YXRlZCB0byBtaW5pbWl6ZSBtZW1vcnkgdXNlLlxyXG4gIExhenlNYXAgKG5hbWUsIG1hcCkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHt2YWx1ZTogbWFwLCBlbnVtZXJhYmxlOiB0cnVlfSk7XHJcbiAgICByZXR1cm4gbWFwXHJcbiAgfSxcclxuICBnZXQgR3JheSAoKSB7IHJldHVybiB0aGlzLkxhenlNYXAoJ0dyYXknLCB0aGlzLmdyYXlDb2xvck1hcCgpKSB9LFxyXG4gIGdldCBMaWdodEdyYXkgKCkgeyByZXR1cm4gdGhpcy5MYXp5TWFwKCdMaWdodEdyYXknLCB0aGlzLmdyYXlDb2xvck1hcCgyMDApKSB9LFxyXG4gIGdldCBEYXJrR3JheSAoKSB7IHJldHVybiB0aGlzLkxhenlNYXAoJ0RhcmtHcmF5JywgdGhpcy5ncmF5Q29sb3JNYXAoMCwgMTAwKSkgfSxcclxuICBnZXQgSmV0ICgpIHtcclxuICAgIHJldHVybiB0aGlzLkxhenlNYXAoJ0pldCcsIHRoaXMuZ3JhZGllbnRDb2xvck1hcCgyNTYsIHRoaXMuamV0Q29sb3JzKSlcclxuICB9LFxyXG4gIGdldCBSZ2IyNTYgKCkgeyByZXR1cm4gdGhpcy5MYXp5TWFwKCdSZ2IyNTYnLCB0aGlzLnJnYkNvbG9yQ3ViZSg4LCA4LCA0KSkgfSxcclxuICBnZXQgUmdiICgpIHsgcmV0dXJuIHRoaXMuTGF6eU1hcCgnUmdiJywgdGhpcy5yZ2JDb2xvckN1YmUoMTYpKSB9LFxyXG4gIGdldCBCYXNpYzE2ICgpIHsgLy8gMTcgdW5pcXVlICsgMiBcImFsaWFzZXNcIiA9IDE5IG5hbWVzLiBcIjE2XCIgaGlzdG9yaWNcclxuICAgIHJldHVybiB0aGlzLkxhenlNYXAoJ0Jhc2ljMTYnLCB0aGlzLmNzc0NvbG9yTWFwKHRoaXMuYmFzaWNDb2xvck5hbWVzLCB0cnVlKSlcclxuICB9XHJcbn07XHJcblxyXG4vLyBBZ2VudFNldHMgYXJlIGFycmF5cyB0aGF0IGFyZSBmYWN0b3JpZXMgZm9yIHRoZWlyIG93biBhZ2VudHMvb2JqZWN0cy5cclxuLy8gVGhleSBhcmUgdGhlIGJhc2UgZm9yIFBhdGNoZXMsIFR1cnRsZXMgYW5kIExpbmtzLlxyXG5cclxuLy8gVm9jYWI6IEFnZW50U2V0cyBhcmUgTmV0TG9nbyBjb2xsZWN0aW9uczogUGF0Y2hlcywgVHVydGxlcywgYW5kIExpbmtzLlxyXG4vLyBBZ2VudCBpcyBhbiBvYmplY3QgaW4gYW4gQWdlbnRTZXQ6IFBhdGNoLCBUdXJ0bGUsIExpbmsuXHJcblxyXG5jbGFzcyBBZ2VudFNldCBleHRlbmRzIEFnZW50QXJyYXkge1xyXG4gIC8vIE1hZ2ljIHRvIHJldHVybiBBZ2VudEFycmF5J3MgcmF0aGVyIHRoYW4gQWdlbnRTZXRzXHJcbiAgLy8gU3ltYm9sLnNwZWNpZXM6IGh0dHBzOi8vZ29vLmdsL1pzeHd4ZFxyXG4gIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSAoKSB7IHJldHVybiBBZ2VudEFycmF5IH1cclxuXHJcbiAgLy8gQ3JlYXRlIGFuIGVtcHR5IGBBZ2VudFNldGAgYW5kIGluaXRpYWxpemUgdGhlIGBJRGAgY291bnRlciBmb3IgYWRkKCkuXHJcbiAgLy8gSWYgYmFzZVNldCBpcyBzdXBwbGllZCwgdGhlIG5ldyBhZ2VudHNldCBpcyBhIHN1YmFycmF5IG9mIGJhc2VTZXQuXHJcbiAgLy8gVGhpcyBzdWItYXJyYXkgZmVhdHVyZSBpcyBob3cgYnJlZWRzIGFyZSBtYW5hZ2VkLCBzZWUgY2xhc3MgYE1vZGVsYFxyXG4gIGNvbnN0cnVjdG9yIChtb2RlbCwgQWdlbnRDbGFzcywgbmFtZSwgYmFzZVNldCA9IG51bGwpIHtcclxuICAgIHN1cGVyKCk7IC8vIGNyZWF0ZSBlbXB0eSBBZ2VudEFycmF5XHJcbiAgICBiYXNlU2V0ID0gYmFzZVNldCB8fCB0aGlzOyAvLyBpZiBub3QgYSBicmVlZCwgc2V0IGJhc2VTZXQgdG8gdGhpc1xyXG4gICAgLy8gQWdlbnRTZXRzIGtub3cgdGhlaXIgbW9kZWwsIG5hbWUsIGJhc2VTZXQsIHdvcmxkLlxyXG4gICAgLy8gT2JqZWN0LmFzc2lnbih0aGlzLCB7bW9kZWwsIG5hbWUsIGJhc2VTZXQsIEFnZW50Q2xhc3MsIHdvcmxkOiBtb2RlbC53b3JsZH0pXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHttb2RlbCwgbmFtZSwgYmFzZVNldCwgQWdlbnRDbGFzc30pO1xyXG4gICAgLy8gQmFzZVNldHMga25vdyB0aGVpciBicmVlZHMgYW5kIGtlZXAgdGhlIElEIGdsb2JhbFxyXG4gICAgaWYgKHRoaXMuaXNCYXNlU2V0KCkpIHtcclxuICAgICAgdGhpcy5icmVlZHMgPSB7fTsgLy8gd2lsbCBjb250YWluIGJyZWVkbmFtZTogYnJlZWQgZW50cmllc1xyXG4gICAgICB0aGlzLklEID0gMDtcclxuICAgIC8vIEJyZWVkcyBhZGQgdGhlbXNlbHZlcyB0byBiYXNlU2V0LlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5iYXNlU2V0LmJyZWVkc1tuYW1lXSA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBLZWVwIGEgbGlzdCBvZiB0aGlzIHNldCdzIHZhcmlhYmxlczsgc2VlIGBvd25gIGJlbG93XHJcbiAgICB0aGlzLm93blZhcmlhYmxlcyA9IFtdO1xyXG4gICAgLy8gQ3JlYXRlIGEgcHJvdG8gZm9yIG91ciBhZ2VudHMgYnkgaGF2aW5nIGEgZGVmYXVsdHMgYW5kIGluc3RhbmNlIGxheWVyXHJcbiAgICAvLyB0aGlzLkFnZW50Q2xhc3MgPSBBZ2VudENsYXNzXHJcbiAgICB0aGlzLmFnZW50UHJvdG8gPSBuZXcgQWdlbnRDbGFzcyh0aGlzKTtcclxuICAgIHRoaXMucHJvdG9NaXhpbih0aGlzLmFnZW50UHJvdG8sIEFnZW50Q2xhc3MpO1xyXG4gICAgLy8gfVxyXG4gIH1cclxuICAvLyBBbGwgYWdlbnRzIGhhdmU6XHJcbiAgLy8gdmFyczogaWQsIGFnZW50U2V0LCBtb2RlbCwgd29ybGQsIGJyZWVkIChnZXR0ZXIpXHJcbiAgLy8gICBiYXNlU2V0IGJ5IG5hbWU6IHR1cnRsZXMvcGF0Y2hlcy9saW5rc1xyXG4gIC8vIG1ldGhvZHM6IHNldEJyZWVkLCBnZXRCcmVlZCwgaXNCcmVlZFxyXG4gIC8vIGdldHRlci9zZXR0ZXI6IGJyZWVkXHJcbiAgcHJvdG9NaXhpbiAoYWdlbnRQcm90bywgQWdlbnRDbGFzcykge1xyXG4gICAgT2JqZWN0LmFzc2lnbihhZ2VudFByb3RvLCB7XHJcbiAgICAgIGFnZW50U2V0OiB0aGlzLFxyXG4gICAgICBtb2RlbDogdGhpcy5tb2RlbFxyXG4gICAgICAvLyB3b3JsZDogdGhpcy53b3JsZFxyXG4gICAgfSk7XHJcbiAgICBhZ2VudFByb3RvW3RoaXMuYmFzZVNldC5uYW1lXSA9IHRoaXMuYmFzZVNldDtcclxuXHJcbiAgICAvLyBpZiAodGhpcy5pc0Jhc2VTZXQoKSkge1xyXG4gICAgLy8gTW9kZWwucmVzZXQgc2hvdWxkIG5vdCByZWRlZmluZSB0aGVzZS5cclxuICAgIGlmICghQWdlbnRDbGFzcy5wcm90b3R5cGUuc2V0QnJlZWQpIHtcclxuICAgICAgT2JqZWN0LmFzc2lnbihBZ2VudENsYXNzLnByb3RvdHlwZSwge1xyXG4gICAgICAgIHNldEJyZWVkIChicmVlZCkgeyBicmVlZC5zZXRCcmVlZCh0aGlzKTsgfSxcclxuICAgICAgICBnZXRCcmVlZCAoKSB7IHJldHVybiB0aGlzLmFnZW50U2V0IH0sXHJcbiAgICAgICAgaXNCcmVlZCAoYnJlZWQpIHsgcmV0dXJuIHRoaXMuYWdlbnRTZXQgPT09IGJyZWVkIH1cclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBZ2VudENsYXNzLnByb3RvdHlwZSwgJ2JyZWVkJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5hZ2VudFNldCB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIGEgc3ViYXJyYXkgb2YgdGhpcyBBZ2VudFNldC4gRXhhbXBsZTogY3JlYXRlIGEgcGVvcGxlIGJyZWVkIG9mIHR1cnRsZXM6XHJcbiAgLy8gYHBlb3BsZSA9IHR1cnRsZXMubmV3QnJlZWQoJ3Blb3BsZScpYFxyXG4gIG5ld0JyZWVkIChuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IEFnZW50U2V0KHRoaXMubW9kZWwsIHRoaXMuQWdlbnRDbGFzcywgbmFtZSwgdGhpcylcclxuICB9XHJcblxyXG4gIC8vIElzIHRoaXMgYSBiYXNlU2V0IG9yIGEgZGVyaXZlZCBcImJyZWVkXCJcclxuICBpc0JyZWVkU2V0ICgpIHsgcmV0dXJuIHRoaXMuYmFzZVNldCAhPT0gdGhpcyB9XHJcbiAgaXNCYXNlU2V0ICgpIHsgcmV0dXJuIHRoaXMuYmFzZVNldCA9PT0gdGhpcyB9XHJcblxyXG4gIC8vIHdpdGggKHJlcG9ydGVyKSB7IHJldHVybiB0aGlzLmZpbHRlcihyZXBvcnRlcikgfVxyXG4gIC8vIGlmICh0aGlzLmlzQnJlZWRTZXQoKSkgYXJyYXkgPSBhcnJheS5maWx0ZXIoKGEpID0+IGEuYWdlbnRTZXQgPT09IHRoaXMpXHJcblxyXG4gIC8vIFJldHVybiBicmVlZHMgaW4gYSBzdWJzZXQgb2YgYW4gQWdlbnRTZXQuXHJcbiAgLy8gRXg6IHBhdGNoZXMuaW5SZWN0KDUpLndpdGhCcmVlZChob3VzZXMpXHJcbiAgd2l0aEJyZWVkIChicmVlZCkge1xyXG4gICAgcmV0dXJuIHRoaXMud2l0aChhID0+IGEuYWdlbnRTZXQgPT09IGJyZWVkKVxyXG4gIH1cclxuXHJcbiAgLy8gQWJzdHJhY3QgbWV0aG9kIHVzZWQgYnkgc3ViY2xhc3NlcyB0byBjcmVhdGUgYW5kIGFkZCB0aGVpciBpbnN0YW5jZXMuXHJcbiAgY3JlYXRlICgpIHsgY29uc29sZS5sb2coYEFnZW50U2V0OiBBYnN0cmFjdCBtZXRob2QgY2FsbGVkOiAke3RoaXN9YCk7IH1cclxuXHJcbiAgLy8gQWRkIGFuIGFnZW50IHRvIHRoZSBsaXN0LiAgT25seSB1c2VkIGJ5IGFnZW50c2V0IGZhY3RvcnkgbWV0aG9kcy4gQWRkc1xyXG4gIC8vIHRoZSBgaWRgIHByb3BlcnR5IHRvIGFsbCBhZ2VudHMuIEluY3JlbWVudCBgSURgLlxyXG4gIC8vIFJldHVybnMgdGhlIG9iamVjdCBmb3IgY2hhaW5pbmcuIFRoZSBzZXQgd2lsbCBiZSBzb3J0ZWQgYnkgYGlkYC5cclxuICBhZGRBZ2VudCAobykgeyAvLyBvIG9ubHkgZm9yIGJyZWVkcyBhZGRpbmcgdGhlbXNlbHZlcyB0byB0aGVpciBiYXNlU2V0XHJcbiAgICBvID0gbyB8fCBPYmplY3QuY3JlYXRlKHRoaXMuYWdlbnRQcm90byk7IC8vIFJFTUlORDogU2ltcGxpZnkhIFRvbyBzbGljay5cclxuICAgIGlmICh0aGlzLmlzQnJlZWRTZXQoKSlcclxuICAgICAgdGhpcy5iYXNlU2V0LmFkZEFnZW50KG8pO1xyXG4gICAgZWxzZVxyXG4gICAgICBvLmlkID0gdGhpcy5JRCsrO1xyXG4gICAgdGhpcy5wdXNoKG8pO1xyXG4gICAgcmV0dXJuIG9cclxuICB9XHJcbiAgY2xlYXIgKCkgeyB3aGlsZSAodGhpcy5hbnkoKSkgdGhpcy5sYXN0KCkuZGllKCk7IH0gLy8gZGllKCkgaXMgYW4gYWdlbnQgbWV0aG9kXHJcbiAgLy8gUmVtb3ZlIGFuIGFnZW50IGZyb20gdGhlIGFnZW50c2V0LCByZXR1cm5pbmcgdGhlIGFnZW50c2V0IGZvciBjaGFpbmluZy5cclxuICAvLyBOb3RlIHJlbW92ZUFnZW50KGFnZW50KSBkaWZmZXJlbnQgdGhhbiByZW1vdmUoYWdlbnQpIHdoaWNoIHNpbXBseSByZW1vdmVzXHJcbiAgLy8gdGhlIGFnZW50IGZyb20gaXQncyBhcnJheVxyXG4gIHJlbW92ZUFnZW50IChvKSB7XHJcbiAgICAvLyBSZW1vdmUgbWUgZnJvbSBteSBiYXNlU2V0XHJcbiAgICBpZiAodGhpcy5pc0JyZWVkU2V0KCkpIHRoaXMuYmFzZVNldC5yZW1vdmUobywgJ2lkJyk7XHJcbiAgICAvLyBSZW1vdmUgbWUgZnJvbSBteSBzZXQuXHJcbiAgICB0aGlzLnJlbW92ZShvLCAnaWQnKTtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBBZ2VudFNldHMgb2Z0ZW4gbmVlZCBhIHJhbmRvbSBjb2xvci4gV2UgdXNlIGEgc3RhbmRhcmQgc2hhcmVkIENvbG9yTWFwIG1hcC5cclxuICByYW5kb21Db2xvciAoKSB7IHJldHVybiBDb2xvck1hcC5CYXNpYzE2LnJhbmRvbUNvbG9yKCkgfVxyXG5cclxuICAvLyBHZXQvU2V0IGRlZmF1bHQgdmFsdWVzIGZvciB0aGlzIGFnZW50c2V0J3MgYWdlbnRzLlxyXG4gIC8vIElmIG5hbWUgZW5kcyB3aXRoIFwiY29sb3JcIiwgdXNlIHZhbHVlID0gdG9Db2xvcih2YWx1ZSlcclxuICBzZXREZWZhdWx0IChuYW1lLCB2YWx1ZSkge1xyXG4gICAgaWYgKG5hbWUubWF0Y2goL2NvbG9yJC9pKSlcclxuICAgICAgdmFsdWUgPSBDb2xvci50b0NvbG9yKHZhbHVlKTtcclxuICAgIHRoaXMuYWdlbnRQcm90b1tuYW1lXSA9IHZhbHVlO1xyXG4gIH1cclxuICBnZXREZWZhdWx0IChuYW1lKSB7IHJldHVybiB0aGlzLmFnZW50UHJvdG9bbmFtZV0gfVxyXG4gIC8vIFVzZWQgd2hlbiBnZXR0ZXIvc2V0dGVyJ3MgbmVlZCB0byBrbm93IGlmIGdldC9zZXQgZGVmYXVsdFxyXG4gIHNldHRpbmdEZWZhdWx0IChhZ2VudCkgeyByZXR1cm4gYWdlbnQuaWQgPT0gbnVsbCB9XHJcblxyXG4gIC8vIERlY2xhcmUgdmFyaWFibGVzIG9mIGFuIGFnZW50IGNsYXNzLlxyXG4gIC8vIGB2YXJuYW1lc2AgaXMgYSBzdHJpbmcgb2Ygc3BhY2Ugc2VwYXJhdGVkIG5hbWVzXHJcbiAgb3duICh2YXJuYW1lcykge1xyXG4gICAgLy8gaWYgKHRoaXMuaXNCcmVlZFNldCgpKVxyXG4gICAgLy8gICB0aGlzLm93blZhcmlhYmxlcyA9IHV0aWwuY2xvbmUodGhpcy5iYXNlU2V0Lm93blZhcmlhYmxlcylcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiB2YXJuYW1lcy5zcGxpdCgnICcpKSB7XHJcbiAgICAgIHRoaXMuc2V0RGVmYXVsdChuYW1lLCBudWxsKTtcclxuICAgICAgdGhpcy5vd25WYXJpYWJsZXMucHVzaChuYW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE1vdmUgYW4gYWdlbnQgZnJvbSBpdHMgQWdlbnRTZXQvYnJlZWQgdG8gYmUgaW4gdGhpcyBBZ2VudFNldC9icmVlZC5cclxuICBzZXRCcmVlZCAoYSkgeyAvLyBjaGFuZ2UgYWdlbnQgYSB0byBiZSBpbiB0aGlzIGJyZWVkXHJcbiAgICAvLyBSZXR1cm4gaWYgYGFgIGlzIGFscmVhZHkgb2YgbXkgYnJlZWRcclxuICAgIGlmIChhLmFnZW50U2V0ID09PSB0aGlzKSByZXR1cm5cclxuICAgIC8vIFJlbW92ZS9pbnNlcnQgYnJlZWRzIChub3QgYmFzZVNldHMpIGZyb20gdGhlaXIgYWdlbnRzZXRzXHJcbiAgICBpZiAoYS5hZ2VudFNldC5pc0JyZWVkU2V0KCkpIGEuYWdlbnRTZXQucmVtb3ZlKGEsICdpZCcpO1xyXG4gICAgaWYgKHRoaXMuaXNCcmVlZFNldCgpKSB0aGlzLmluc2VydChhLCAnaWQnKTtcclxuXHJcbiAgICAvLyBNYWtlIGxpc3Qgb2YgYGFgJ3MgdmFycyBhbmQgbXkgb3dudmFycy5cclxuICAgIGNvbnN0IGF2YXJzID0gYS5hZ2VudFNldC5vd25WYXJpYWJsZXM7XHJcbiAgICAvLyBGaXJzdCByZW1vdmUgYGFgJ3MgdmFycyBub3QgaW4gbXkgb3duVmFyaWFibGVzXHJcbiAgICBmb3IgKGNvbnN0IGF2YXIgb2YgYXZhcnMpXHJcbiAgICAgIGlmICghdGhpcy5vd25WYXJpYWJsZXMuaW5jbHVkZXMoYXZhcikpXHJcbiAgICAgICAgZGVsZXRlIGFbYXZhcl07XHJcbiAgICAvLyBOb3cgYWRkIG93blZhcmlhYmxlcyB0byBgYWAncyB2YXJzLCBkZWZhdWx0IHRvIDAuXHJcbiAgICAvLyBJZiBvd252YXIgYWxyZWFkeSBpbiBhdmFycywgaXQgaXMgbm90IG1vZGlmaWVkLlxyXG4gICAgZm9yIChjb25zdCBvd252YXIgb2YgdGhpcy5vd25WYXJpYWJsZXMpXHJcbiAgICAgIGlmICghYXZhcnMuaW5jbHVkZXMob3dudmFyKSlcclxuICAgICAgICBhW293bnZhcl0gPSAwOyAvLyBOT1RFOiBOTCB1c2VzIDAsIG1heWJlIHdlIHNob3VsZCB1c2UgbnVsbD9cclxuXHJcbiAgICAvLyBHaXZlIGBhYCBteSBkZWZhdWx0cy9zdGF0aWNzXHJcbiAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKGEsIHRoaXMuYWdlbnRQcm90bylcclxuICB9XHJcbn1cclxuXHJcbi8vIFRoZSBBbmltYXRvciBydW5zIHRoZSBNb2RlbCdzIHN0ZXAoKSBhbmQgZHJhdygpIG1ldGhvZHMuXHJcblxyXG4vLyBCZWNhdXNlIG5vdCBhbGwgbW9kZWxzIGhhdmUgdGhlIHNhbWUgYW5pbWF0b3IgcmVxdWlyZW1lbnRzLCB3ZSBidWlsZCBhIGNsYXNzXHJcbi8vIGZvciBjdXN0b21pemF0aW9uIGJ5IHRoZSBwcm9ncmFtbWVyLiAgU2VlIHRoZXNlIFVSTHMgZm9yIG1vcmUgaW5mbzpcclxuLy8gKiBbSmF2YVNjcmlwdCB0aW1lcnMgZG9jc10oXHJcbi8vICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9UaW1lcnMpXHJcbi8vICogW1VzaW5nIHRpbWVycyAmIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0b2dldGhlcl0oaHR0cDovL2dvby5nbC95bUVFWClcclxuXHJcbmNsYXNzIEFuaW1hdG9yIHtcclxuICAvLyBDcmVhdGUgaW5pdGlhbCBhbmltYXRvciBmb3IgdGhlIG1vZGVsLCBzcGVjaWZ5aW5nIHJhdGUgKGZwcykgYW5kXHJcbiAgLy8gbXVsdGlTdGVwLiBDYWxsZWQgYnkgTW9kZWwgZHVyaW5nIGluaXRpYWxpemF0aW9uLCB1c2Ugc2V0UmF0ZSB0byBtb2RpZnkuXHJcbiAgLy8gSWYgbXVsdGlTdGVwLCBydW4gdGhlIGRyYXcoKSBhbmQgc3RlcCgpIG1ldGhvZHMgc2VwYXJhdGVseSBieVxyXG4gIC8vIGRyYXcoKSB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIHN0ZXAoKSB1c2luZyBzZXRUaW1lb3V0LlxyXG4gIGNvbnN0cnVjdG9yIChtb2RlbCwgcmF0ZSA9IDYwLCBtdWx0aVN0ZXAgPSBmYWxzZSkge1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7bW9kZWwsIHJhdGUsIG11bHRpU3RlcH0pO1xyXG4gICAgdGhpcy5yZXNldCgpO1xyXG4gIH1cclxuICAvLyBBZGp1c3QgYW5pbWF0b3IuIENhbGwgYmVmb3JlIG1vZGVsLnN0YXJ0KClcclxuICAvLyBpbiBzZXR1cCgpIHRvIGNoYW5nZSBkZWZhdWx0IHNldHRpbmdzXHJcbiAgc2V0UmF0ZSAocmF0ZSwgbXVsdGlTdGVwID0gZmFsc2UpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywge3JhdGUsIG11bHRpU3RlcH0pO1xyXG4gICAgdGhpcy5yZXNldFRpbWVzKCk7XHJcbiAgfVxyXG4gIC8vIHN0YXJ0L3N0b3AgbW9kZWwsIGNhbGxlZCBieSBNb2RlbC5cclxuICAvLyBPZnRlbiB1c2VkIGZvciBkZWJ1Z2dpbmcgYW5kIHJlc2V0dGluZyBtb2RlbC5cclxuICBzdGFydCAoKSB7XHJcbiAgICBpZiAoIXRoaXMuc3RvcHBlZCkgcmV0dXJuIC8vIGF2b2lkIG11bHRpcGxlIHN0YXJ0c1xyXG4gICAgdGhpcy5yZXNldFRpbWVzKCk7XHJcbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuYW5pbWF0ZSgpO1xyXG4gIH1cclxuICBzdG9wICgpIHtcclxuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XHJcbiAgICBpZiAodGhpcy5hbmltSGFuZGxlKSBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1IYW5kbGUpO1xyXG4gICAgaWYgKHRoaXMudGltZW91dEhhbmRsZSkgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dEhhbmRsZSk7XHJcbiAgICB0aGlzLmFuaW1IYW5kbGUgPSB0aGlzLnRpbWVvdXRIYW5kbGUgPSBudWxsO1xyXG4gIH1cclxuICAvLyBJbnRlcm5hbCB1dGlsaXR5OiByZXNldCB0aW1lIGluc3RhbmNlIHZhcmlhYmxlc1xyXG4gIHJlc2V0VGltZXMgKCkge1xyXG4gICAgdGhpcy5zdGFydE1TID0gdGhpcy5ub3coKTtcclxuICAgIHRoaXMuc3RhcnRUaWNrID0gdGhpcy50aWNrcztcclxuICAgIHRoaXMuc3RhcnREcmF3ID0gdGhpcy5kcmF3cztcclxuICB9XHJcbiAgLy8gUmVzZXQgdXNlZCBieSBtb2RlbC5yZXNldCB3aGVuIHJlc2V0dGluZyBtb2RlbC5cclxuICByZXNldCAoKSB7IHRoaXMuc3RvcCgpOyB0aGlzLnRpY2tzID0gdGhpcy5kcmF3cyA9IDA7IH1cclxuICAvLyBUd28gaGFuZGxlcnMgdXNlZCBieSBhbmltYXRpb24gbG9vcFxyXG4gIHN0ZXAgKCkgeyB0aGlzLnRpY2tzKys7IHRoaXMubW9kZWwuc3RlcCgpOyB9XHJcbiAgZHJhdyAoKSB7IHRoaXMuZHJhd3MrKzsgdGhpcy5tb2RlbC5kcmF3KCk7IH1cclxuICAvLyBzdGVwIGFuZCBkcmF3IHRoZSBtb2RlbCBvbmNlXHJcbiAgb25jZSAoKSB7IHRoaXMuc3RlcCgpOyB0aGlzLmRyYXcoKTsgfVxyXG4gIC8vIEdldCBjdXJyZW50IHRpbWUsIHdpdGggaGlnaCByZXNvbHV0aW9uIHRpbWVyIGlmIGF2YWlsYWJsZVxyXG4gIG5vdyAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKSB9XHJcbiAgLy8gVGltZSBpbiBtcyBzaW5jZSBzdGFydGluZyBhbmltYXRvclxyXG4gIG1zICgpIHsgcmV0dXJuIHRoaXMubm93KCkgLSB0aGlzLnN0YXJ0TVMgfVxyXG4gIC8vIEdldCB0aWNrcy9kcmF3cyBwZXIgc2Vjb25kLiBUaGV5IHdpbGwgZGlmZmVyIGlmIG11bHRpU3RlcC5cclxuICB0aWNrc1BlclNlYyAoKSB7XHJcbiAgICBjb25zdCBkdCA9IHRoaXMudGlja3MgLSB0aGlzLnN0YXJ0VGljaztcclxuICAgIHJldHVybiBkdCA9PT0gMCA/IDAgOiBNYXRoLnJvdW5kKGR0ICogMTAwMCAvIHRoaXMubXMoKSkgLy8gYXZvaWQgZGl2aWRlIGJ5IDBcclxuICB9XHJcbiAgZHJhd3NQZXJTZWMgKCkge1xyXG4gICAgY29uc3QgZHQgPSB0aGlzLmRyYXdzIC0gdGhpcy5zdGFydERyYXc7XHJcbiAgICByZXR1cm4gZHQgPT09IDAgPyAwIDogTWF0aC5yb3VuZChkdCAqIDEwMDAgLyB0aGlzLm1zKCkpXHJcbiAgfVxyXG4gIC8vIFJldHVybiBhIHN0YXR1cyBzdHJpbmcgZm9yIGRlYnVnZ2luZyBhbmQgbG9nZ2luZyBwZXJmb3JtYW5jZVxyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiBgdGlja3M6ICR7dGhpcy50aWNrc30sIGRyYXdzOiAke3RoaXMuZHJhd3N9LCByYXRlOiAke3RoaXMucmF0ZX0gdHBzL2RwczogJHt0aGlzLnRpY2tzUGVyU2VjKCl9LyR7dGhpcy5kcmF3c1BlclNlYygpfWBcclxuICB9XHJcbiAgLy8gQW5pbWF0aW9uIHZpYSBzZXRUaW1lb3V0IGFuZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgLy8gQXJyb3cgZnVuY3Rpb25zIGFyZSByZXF1aXJlZCBmb3IgY2FsbGJhY2tzIGZvciBsZXhpY2FsIHNjb3BlLlxyXG4gIGFuaW1hdGVTdGVwcyAoKSB7XHJcbiAgICB0aGlzLnN0ZXAoKTtcclxuICAgIGlmICghdGhpcy5zdG9wcGVkKVxyXG4gICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYW5pbWF0ZVN0ZXBzKCksIDEwKTtcclxuICB9XHJcbiAgYW5pbWF0ZURyYXdzICgpIHtcclxuICAgIGlmICh0aGlzLmRyYXdzUGVyU2VjKCkgPCB0aGlzLnJhdGUpIHsgLy8gdGhyb3R0bGUgZHJhd2luZyB0byBAcmF0ZVxyXG4gICAgICBpZiAoIXRoaXMubXVsdGlTdGVwKSB0aGlzLnN0ZXAoKTtcclxuICAgICAgdGhpcy5kcmF3KCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuc3RvcHBlZClcclxuICAgICAgdGhpcy5hbmltSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYW5pbWF0ZURyYXdzKCkpO1xyXG4gIH1cclxuICAvLyBDYWxsZWQgb25jZSBieSBzdGFydCgpIHRvIGdldCBhbmltYXRlU3RlcHMgJiBhbmltYXRlRHJhd3MgaXRlcmF0aW5nLlxyXG4gIGFuaW1hdGUgKCkge1xyXG4gICAgaWYgKHRoaXMubXVsdGlTdGVwKSB0aGlzLmFuaW1hdGVTdGVwcygpO1xyXG4gICAgdGhpcy5hbmltYXRlRHJhd3MoKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEEgKipEYXRhU2V0KiogaXMgYW4gb2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IGFuZCBhbiBhcnJheVxyXG4vLyB3aG9zZSBsZW5ndGggPSB3aWR0aCAqIGhlaWdodFxyXG4vL1xyXG4vLyBUaGUgZGF0YSBhcnJheSBjYW4gYmUgYSBUeXBlZEFycmF5IG9yIGEgamF2YXNjcmlwdCBBcnJheVxyXG4vLyBOb3RpY2UgdGhhdCBpdCBpcyB2ZXJ5IG11Y2ggbGlrZSBhbiBJbWFnZURhdGEgb2JqZWN0IVxyXG5cclxuY2xhc3MgRGF0YVNldCB7XHJcbiAgLy8gKipTdGF0aWMgbWV0aG9kczoqKiBjYWxsZWQgdmlhIERhdGFTZXQuZm9vKCksIHNpbWlsYXIgdG8gTWF0aC5mb28oKS5cclxuICAvLyBHZW5lcmFsbHkgdXNlZnVsIHV0aWxpdGllcyBmb3IgdXNlIHdpdGggVHlwZWRBcnJheXMgJiBKUyBBcnJheXNcclxuXHJcbiAgLy8gUmV0dXJuIGFuIGVtcHR5IGRhdGFzZXQgb2YgZ2l2ZW4gd2lkdGgsIGhlaWdodCwgZGF0YVR5cGVcclxuICBzdGF0aWMgZW1wdHlEYXRhU2V0ICh3aWR0aCwgaGVpZ2h0LCBUeXBlKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGFTZXQod2lkdGgsIGhlaWdodCwgbmV3IFR5cGUod2lkdGggKiBoZWlnaHQpKVxyXG4gIH1cclxuXHJcbiAgLy8gVGhlICoqRGF0YVNldCBDbGFzcyoqIGNvbnN0cnVjdG9yIGFuZCBtZXRob2RzXHJcblxyXG4gIC8vIGNvbnN0cnVjdG9yOiBTdG9yZXMgdGhlIHRocmVlIERhdGFTZXQgY29tcG9uZW50cy5cclxuICAvLyBDaGVja3MgZGF0YSBpcyByaWdodCBzaXplLCB0aHJvd3MgYW4gZXJyb3IgaWYgbm90LlxyXG4gIGNvbnN0cnVjdG9yICh3aWR0aCwgaGVpZ2h0LCBkYXRhKSB7XHJcbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IHdpZHRoICogaGVpZ2h0KVxyXG4gICAgICB0aHJvdyBFcnJvcihgbmV3IERhdGFTZXQgbGVuZ3RoOiAke2RhdGEubGVuZ3RofSAhPT0gJHt3aWR0aH0gKiAke2hlaWdodH1gKVxyXG4gICAgZWxzZVxyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHt3aWR0aCwgaGVpZ2h0LCBkYXRhfSk7XHJcbiAgICAgIC8vIFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5kYXRhXSA9IFt3aWR0aCwgaGVpZ2h0LCBkYXRhXVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0L1NldCBuYW1lLCB1c2VmdWwgZm9yIHN0b3JhZ2Uga2V5LlxyXG4gIHNldE5hbWUgKHN0cmluZykgeyB0aGlzLm5hbWUgPSBzdHJpbmc7IHJldHVybiB0aGlzIH1cclxuICBnZXROYW1lICgpIHsgcmV0dXJuIHRoaXMubmFtZSA/IHRoaXMubmFtZSA6IHRoaXMubWFrZU5hbWUoKSB9XHJcbiAgbWFrZU5hbWUgKCkge1xyXG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcztcclxuICAgIGNvbnN0IHN1bSA9IHV0aWwuYXJyYXlTdW0odGhpcy5kYXRhKS50b0ZpeGVkKDIpO1xyXG4gICAgcmV0dXJuIGAke3RoaXMuZGF0YVR5cGUoKS5uYW1lfS0ke3dpZHRofS0ke2hlaWdodH0tJHtzdW19YFxyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2tzIHgseSBhcmUgd2l0aGluIERhdGFTZXQuIFRocm93IGVycm9yIGlmIG5vdC5cclxuICBjaGVja1hZICh4LCB5KSB7XHJcbiAgICBpZiAoIXRoaXMuaW5Cb3VuZHMoeCwgeSkpXHJcbiAgICAgIHRocm93IEVycm9yKGBEYXRhU2V0LmNoZWNrWFk6IHgseSBvdXQgb2YgcmFuZ2U6ICR7eH0sICR7eX1gKVxyXG4gIH1cclxuICAvLyB0cnVlIGlmIHgseSBpbiBkYXRhc2V0IGJvdW5kc1xyXG4gIGluQm91bmRzICh4LCB5KSB7XHJcbiAgICByZXR1cm4gKHV0aWwuYmV0d2Vlbih4LCAwLCB0aGlzLndpZHRoIC0gMSkgJiYgdXRpbC5iZXR3ZWVuKHksIDAsIHRoaXMuaGVpZ2h0IC0gMSkpXHJcbiAgfVxyXG5cclxuICBkYXRhVHlwZSAoKSB7IHJldHVybiB0aGlzLmRhdGEuY29uc3RydWN0b3IgfVxyXG4gIHR5cGUgKCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciB9XHJcblxyXG4gIC8vIEdpdmVuIHgseSBpbiBkYXRhIHNwYWNlLCByZXR1cm4gaW5kZXggaW50byBkYXRhXHJcbiAgdG9JbmRleCAoeCwgeSkgeyByZXR1cm4geCArICh5ICogdGhpcy53aWR0aCkgfVxyXG5cclxuICAvLyBHaXZlbiBpbmRleCBpbnRvIGRhdGEsIHJldHVybiBkYXRhc2V0IFt4LCB5XSBwb3NpdGlvblxyXG4gIHRvWFkgKGkpIHsgcmV0dXJuIFtpICUgdGhpcy53aWR0aCwgTWF0aC5mbG9vcihpIC8gdGhpcy53aWR0aCldIH1cclxuXHJcbiAgLy8gR2V0IGRhdGFzZXQgdmFsdWUgYXQgeCx5LCBhc3N1bWluZyB0aGF0IHgseSB2YWxpZGlkYXRlZCBwcmV2aW91c2x5XHJcbiAgLy8gZ2V0WFkgKHgsIHkpIHsgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnRvSW5kZXgoTWF0aC5mbG9vcih4KSwgTWF0aC5mbG9vcih5KSldIH1cclxuICBnZXRYWSAoeCwgeSkgeyByZXR1cm4gdGhpcy5kYXRhW3RoaXMudG9JbmRleCh4LCB5KV0gfVxyXG5cclxuICAvLyBTZXQgdGhlIGRhdGEgdmFsdWUgYXQgeCx5IHRvIG51bS4gYXNzdW1lIHgseSB2YWxpZFxyXG4gIC8vIHNldHh5ICh4LCB5LCBudW0pIHsgdGhpcy5kYXRhW3RoaXMudG9JbmRleChNYXRoLmZsb29yKHgpLCBNYXRoLmZsb29yKHkpKV0gPSBudW0gfVxyXG4gIHNldHh5ICh4LCB5LCBudW0pIHsgdGhpcy5kYXRhW3RoaXMudG9JbmRleCh4LCB5KV0gPSBudW07IH1cclxuXHJcbiAgLy8gV3JhcHBlciBmb3Igc2FtcGxpbmcsIGRlZmF1bHRzIHRvIFwibmVhcmVzdFwiLiBDaGVja3MgeCx5IHZhbGlkIGFzIHdlbGwuXHJcbiAgLy8gVXNlIHRoaXMgZm9yIGluZGl2aWR1YWwgc2FtcGxpbmcuXHJcbiAgc2FtcGxlICh4LCB5LCB1c2VOZWFyZXN0ID0gdHJ1ZSkge1xyXG4gICAgdGhpcy5jaGVja1hZKHgsIHkpO1xyXG4gICAgcmV0dXJuIHVzZU5lYXJlc3QgPyB0aGlzLm5lYXJlc3QoeCwgeSkgOiB0aGlzLmJpbGluZWFyKHgsIHkpXHJcbiAgfVxyXG5cclxuICAvLyBOZWFyZXN0IG5laWdoYm9yIHNhbXBsaW5nLCB3L28geCx5IHZhbGlkaXR5IGNoZWNrLCBpLmUuIG91ciBpbm5lciBsb29wc1xyXG4gIG5lYXJlc3QgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFhZKE1hdGgucm91bmQoeCksIE1hdGgucm91bmQoeSkpXHJcbiAgfVxyXG5cclxuICAvLyBCaWxsaW5lYXIgc2FtcGxpbmcgdy9vIHgseSB2YWxpZGl0eSBjaGVjaywgaS5lLiBvdXIgaW5uZXIgbG9vcHNcclxuICBiaWxpbmVhciAoeCwgeSkge1xyXG4gICAgLy8gQmlsbGluZWFyIHNhbXBsaW5nIHdvcmtzIGJ5IG1ha2luZyB0d28gbGluZWFyIGludGVycG9sYXRpb25zIChsZXJwcylcclxuICAgIC8vIGluIHRoZSB4IGRpcmVjdGlvbiwgYW5kIGEgdGhpcmQgaW4gdGhlIHkgZGlyZWN0aW9uLCBiZXR3ZWVuIHRoZVxyXG4gICAgLy8gdHdvIHggcmVzdWx0cy4gU2VlIHdpa2lwZWRpYTpcclxuICAgIC8vIFtiaWxpbmVhciBzYW1wbGluZ10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaWxpbmVhcl9pbnRlcnBvbGF0aW9uKVxyXG4gICAgLy8gVGhlIGRpYWdyYW0gc2hvd3MgdGhlIHRocmVlIGxlcnBzXHJcblxyXG4gICAgLy8gY29uc3QgW3gwLCB5MF0gPSBbTWF0aC5mbG9vcih4KSwgTWF0aC5mbG9vcih5KV0gLy8gcmVwbGFjZWQgYnkgbmV4dCBsaW5lIGZvciBzcGVlZFxyXG4gICAgY29uc3QgeDAgPSBNYXRoLmZsb29yKHgpO1xyXG4gICAgY29uc3QgeTAgPSBNYXRoLmZsb29yKHkpO1xyXG4gICAgY29uc3QgaSA9IHRoaXMudG9JbmRleCh4MCwgeTApO1xyXG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGg7XHJcbiAgICAvLyBjb25zdCBbZHgsIGR5XSA9IFsoeCAtIHgwKSwgKHkgLSB5MCldIC8vIGR4LCBkeSA9IDAgaWYgeCwgeSBvbiBib3VuZGFyeS4gY29tbWVudGVkIG91dCBmb3Igc3BlZWRcclxuICAgIC8vIGNvbnN0IFtkeDEsIGR5MV0gPSBbMSAtIGR4LCAxIC0gZHldIC8vIGR4MSwgZHkxID0gMSBpZiB4LCB5IG9uIGJvdW5kYXJ5XHJcbiAgICBjb25zdCBkeCA9IHggLSB4MDtcclxuICAgIGNvbnN0IGR5ID0geSAtIHkwO1xyXG4gICAgY29uc3QgZHgxID0gMSAtIGR4O1xyXG4gICAgY29uc3QgZHkxID0gMSAtIGR5O1xyXG4gICAgY29uc3QgZjAwID0gdGhpcy5kYXRhW2ldO1xyXG4gICAgLy8gRWRnZSBjYXNlOiBmaWogaXMgMCBpZiBiZXlvbmQgZGF0YSBhcnJheTsgdW5kZWZpbmVkIC0+IDAuXHJcbiAgICAvLyBUaGlzIGNhbmNlbHMgdGhlIGdpdmVuIGNvbXBvbmVudCdzIGZhY3RvciBpbiB0aGUgcmVzdWx0LlxyXG4gICAgY29uc3QgZjEwID0gdGhpcy5kYXRhW2kgKyAxXSB8fCAwOyAvLyAwIGF0IGJvdHRvbSByaWdodCBjb3JuZXJcclxuICAgIGNvbnN0IGYwMSA9IHRoaXMuZGF0YVtpICsgd10gfHwgMDsgLy8gMCBhdCBhbGwgYm90dG9tIHJvd1xyXG4gICAgY29uc3QgZjExID0gdGhpcy5kYXRhW2kgKyAxICsgd10gfHwgMDsgLy8gMCBhdCBlbmQgb2YgbmV4dCB0byBib3R0b20gcm93XHJcbiAgICAvLyBUaGlzIGlzIGEgYml0IGludm9sdmVkIGJ1dDpcclxuICAgIC8vIGBgYFxyXG4gICAgLy8gSWYgZHggPSAwOyBkeDEgPSAxLCBkeSAhPSAwXHJcbiAgICAvLyAtPiB2ZXJ0aWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgLy8gZnh5ID0gZjAwKDEtZHkpICsgZjAxKGR5KSBpLmUuIHktbGVycFxyXG4gICAgLy9cclxuICAgIC8vIElmIGR4ICE9IDA7IGR5ID0gMCwgZHggIT0wXHJcbiAgICAvLyAtPiBob3Jpem9udGFsIGxpbmVhciBpbnRlcnBvbGF0aW9uXHJcbiAgICAvLyBmeHkgPSBmMDAoMS1keCkgKyBmMTAoZHgpIGkuZS4geC1sZXJwXHJcbiAgICAvLyBgYGBcclxuICAgIHJldHVybiAoZjAwICogZHgxICogZHkxKSArIChmMTAgKiBkeCAqIGR5MSkgK1xyXG4gICAgICAgICAgIChmMDEgKiBkeDEgKiBkeSkgKyAoZjExICogZHggKiBkeSlcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhpcywgd2l0aCBuZXcgZGF0YSBhcnJheVxyXG4gIGNvcHkgKCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRhU2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB1dGlsLmNvcHlBcnJheSh0aGlzLmRhdGEpKVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIG5ldyAoZW1wdHkpIGRhdGFzZXQsIGRlZmF1bHRpbmcgdG8gdGhpcyB0eXBlXHJcbiAgZW1wdHlEYXRhU2V0ICh3aWR0aCwgaGVpZ2h0LCB0eXBlID0gdGhpcy5kYXRhVHlwZSgpKSB7XHJcbiAgICByZXR1cm4gRGF0YVNldC5lbXB0eURhdGFTZXQod2lkdGgsIGhlaWdodCwgdHlwZSkgLy8gc2VlIHN0YXRpYyBhYm92ZVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIG5ldyAoZW1wdHkpIGFycmF5IG9mIHRoaXMgdHlwZVxyXG4gIGVtcHR5QXJyYXkgKGxlbmd0aCkge1xyXG4gICAgY29uc3QgVHlwZSA9IHRoaXMudHlwZSgpO1xyXG4gICAgcmV0dXJuIG5ldyBUeXBlKGxlbmd0aClcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBuZXcgZGF0YXNldCBvZiBzaXplIHdpZHRoL2hlaWdodC90eXBlIGJ5IHJlc2FtcGxpbmcgZWFjaCBwb2ludC5cclxuICAvLyBUeXBlIGlzIG5vdCB0aGlzLnR5cGUoKSBkdWUgdG8gaW50ZWdlci9mbG9hdCBkaWZmZXJlbmNlcy4gRGVmYXVsdCBBcnJheS5cclxuICAvLyBJZiBzYW1lIHNpemUsIHJldHVybiBhIGNvcHkgb2YgdGhpcy5cclxuICByZXNhbXBsZSAod2lkdGgsIGhlaWdodCwgdXNlTmVhcmVzdCA9IHRydWUsIFR5cGUgPSBBcnJheSkge1xyXG4gICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpIHJldHVybiB0aGlzLmNvcHkoKVxyXG4gICAgY29uc3QgZHMgPSBEYXRhU2V0LmVtcHR5RGF0YVNldCh3aWR0aCwgaGVpZ2h0LCBUeXBlKTtcclxuICAgIGNvbnN0IHhTY2FsZSA9ICh0aGlzLndpZHRoIC0gMSkgLyAod2lkdGggLSAxKTtcclxuICAgIGNvbnN0IHlTY2FsZSA9ICh0aGlzLmhlaWdodCAtIDEpIC8gKGhlaWdodCAtIDEpO1xyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKylcclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKVxyXG4gICAgICAgIGRzLnNldHh5KHgsIHksIHRoaXMuc2FtcGxlKHggKiB4U2NhbGUsIHkgKiB5U2NhbGUsIHVzZU5lYXJlc3QpKTtcclxuICAgIHJldHVybiBkc1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIGEgcmVjdGFuZ3VsYXIgc3Vic2V0IG9mIHRoZSBkYXRhc2V0LlxyXG4gIC8vIFJldHVybmVkIGRhdGFzZXQgaXMgb2Ygc2FtZSBhcnJheSB0eXBlIGFzIHRoaXMuXHJcbiAgc3Vic2V0ICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBpZiAoKHggKyB3aWR0aCkgPiB0aGlzLndpZHRoIHx8ICh5ICsgaGVpZ2h0KSA+IHRoaXMuaGVpZ2h0KVxyXG4gICAgICB0aHJvdyBFcnJvcignRGF0YVNldC5zdWJTZXQ6IHBhcmFtcyBvdXQgb2YgcmFuZ2UnKVxyXG4gICAgY29uc3QgZHMgPSB0aGlzLmVtcHR5RGF0YVNldCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKylcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoZWlnaHQ7IGorKylcclxuICAgICAgICBkcy5zZXR4eShpLCBqLCB0aGlzLmdldFhZKGkgKyB4LCBqICsgeSkpO1xyXG4gICAgcmV0dXJuIGRzXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gbWFwZWQgZGF0YXNldCBieSBhcHBseWluZyBmIHRvIGVhY2ggZGF0YXNldCBlbGVtZW50XHJcbiAgbWFwIChmKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGFTZXQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZGF0YS5tYXAoZikpXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gdGhlIGNvbHVtbiBvZiBkYXRhIGF0IHBvc2l0aW9uIHggYXMgdGhpcyBhcnJheSdzIHR5cGVcclxuICBjb2wgKHgpIHtcclxuICAgIGNvbnN0IFt3LCBoLCBkYXRhXSA9IFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5kYXRhXTtcclxuICAgIGlmICh4ID49IHcpXHJcbiAgICAgIHRocm93IEVycm9yKGBjb2w6IHggb3V0IG9mIHJhbmdlIHdpZHRoOiAke3d9IHg6ICR7eH1gKVxyXG4gICAgY29uc3QgY29sRGF0YSA9IHRoaXMuZW1wdHlBcnJheShoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaDsgaSsrKVxyXG4gICAgICBjb2xEYXRhW2ldID0gZGF0YVt4ICsgaSAqIHddO1xyXG4gICAgcmV0dXJuIGNvbERhdGFcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB0aGUgcm93IG9mIGRhdGEgYXQgcG9zaXRpb24geSBhcyB0aGlzIGFycmF5J3MgdHlwZVxyXG4gIHJvdyAoeSkge1xyXG4gICAgY29uc3QgW3csIGhdID0gW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcclxuICAgIGlmICh5ID49IGgpXHJcbiAgICAgIHRocm93IEVycm9yKGByb3c6IHkgb3V0IG9mIHJhbmdlIGhlaWdodDogJHtofSB4OiAke3l9YClcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2UoeSAqIHcsICh5ICsgMSkgKiB3KVxyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCB0aGlzIGRhdGFzZXQncyBkYXRhIHRvIG5ldyB0eXBlLiBQcmVjaXNpb24gbWF5IGJlIGxvc3QuXHJcbiAgLy8gRG9lcyBub3RoaW5nIGlmIGN1cnJlbnQgZGF0YSBpcyBhbHJlYWR5IG9mIHRoaXMgVHlwZS5cclxuICBjb252ZXJ0VHlwZSAodHlwZSkge1xyXG4gICAgdGhpcy5kYXRhID0gdXRpbC5jb252ZXJ0QXJyYXkodGhpcy5kYXRhLCB0eXBlKTtcclxuICB9XHJcblxyXG4gIC8vIENvbmNhdGluYXRlIGEgZGF0YXNldCBvZiBlcXVhbCBoZWlnaHQgdG8gbXkgcmlnaHQgdG8gbXkgZWFzdC5cclxuICAvLyBOZXcgRGF0YVNldCBpcyBvZiBzYW1lIHR5cGUgYXMgdGhpcy5cclxuICAvL1xyXG4gIC8vIE5PVEU6IGNvbmNhdFdlc3QgaXMgZGF0YXNldC5jb25jYXRFYXN0KHRoaXMpXHJcbiAgY29uY2F0RWFzdCAoZHMpIHtcclxuICAgIGNvbnN0IFt3LCBoXSA9IFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XHJcbiAgICBjb25zdCBbdzEsIGgxXSA9IFtkcy53aWR0aCwgZHMuaGVpZ2h0XTtcclxuICAgIGlmIChoICE9PSBoMSlcclxuICAgICAgdGhyb3cgRXJyb3IoYGNvbmNhdEVhc3Q6IGhlaWdodHMgbm90IGVxdWFsICR7aH0sICR7aDF9YClcclxuICAgIGNvbnN0IGRzMSA9IHRoaXMuZW1wdHlEYXRhU2V0KCh3ICsgdzEpLCBoKTtcclxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgaDsgeCsrKSAvLyBjb3B5IHRoaXMgaW50byBuZXcgZGF0YXNldFxyXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHc7IHkrKylcclxuICAgICAgICBkczEuc2V0eHkoeCwgeSwgdGhpcy5nZXRYWSh4LCB5KSk7XHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGgxOyB4KyspIC8vIGNvcHkgZHMgdG8gdGhlIGxlZnQgc2lkZVxyXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHcxOyB5KyspXHJcbiAgICAgICAgZHMxLnNldHh5KHggKyB3LCB5LCBkcy5nZXRYWSh4LCB5KSk7XHJcbiAgICByZXR1cm4gZHMxXHJcbiAgfVxyXG5cclxuICAvLyBDb25jYXRpbmF0ZSBhIGRhdGFzZXQgb2YgZXF1YWwgd2lkdGggdG8gbXkgc291dGgsIHJldHVybmluZyBuZXcgRGF0YVNldC5cclxuICAvLyBOZXcgRGF0YVNldCBpcyBvZiBzYW1lIHR5cGUgYXMgdGhpcy5cclxuICAvL1xyXG4gIC8vIE5PVEU6IGNvbmNhdE5vcnRoIGlzIGRhdGFzZXQuY29uY2F0U291dGgodGhpcylcclxuICBjb25jYXRTb3V0aCAoZGF0YXNldCkge1xyXG4gICAgY29uc3QgW3csIGgsIGRhdGFdID0gW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmRhdGFdO1xyXG4gICAgaWYgKHcgIT09IGRhdGFzZXQud2lkdGgpXHJcbiAgICAgIHRocm93IEVycm9yKGBjb25jYXRTb3V0aDogd2lkdGhzIG5vdCBlcXVhbCAke3d9LCAke2RhdGFzZXQud2lkdGh9YClcclxuICAgIGNvbnN0IGRhdGExID0gdXRpbC5jb25jYXRBcnJheXMoZGF0YSwgZGF0YXNldC5kYXRhKTtcclxuICAgIHJldHVybiBuZXcgRGF0YVNldCh3LCBoICsgZGF0YXNldC5oZWlnaHQsIGRhdGExKVxyXG4gIH1cclxuXHJcbiAgLy8gcmV0dXJuIGRhdGFzZXQgeCx5IGdpdmVuIHgseSBpbiBhIGV1Y2xpZGVhbiBzcGFjZSBkZWZpbmVkIGJ5IHRseCwgdGx5LCB3LCBoXHJcbiAgLy8geCx5IGlzIGluIHRvcGxlZnQtYm90dG9tcmlnaHQgYm94OiBbdGx4LHRseSx0bHgrdyx0bHktaF0sIHkgcG9zaXRpdmUgdXRpbC5cclxuICAvLyBFeDogTmV0TG9nbydzIGNvb3JkczogeCwgeSwgbWluWGNvciwgbWF4WWNvciwgbnVtWCwgbnVtWVxyXG4gIHRyYW5zZm9ybUNvb3JkcyAoeCwgeSwgdGx4LCB0bHksIHcsIGgpIHtcclxuICAgIGNvbnN0IHhzID0gKHggLSB0bHgpICogKHRoaXMud2lkdGggLSAxKSAvIHc7XHJcbiAgICBjb25zdCB5cyA9ICh0bHkgLSB5KSAqICh0aGlzLmhlaWdodCAtIDEpIC8gaDtcclxuICAgIHJldHVybiBbeHMsIHlzXVxyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGEgc2FtcGxlIHVzaW5nIGEgdHJhbnNmb3JtZWQgZXVjbGlkZWFuIGNvb3JkIHN5c3RlbTsgc2VlIGFib3ZlXHJcbiAgY29vcmRTYW1wbGUgKHgsIHksIHRseCwgdGx5LCB3LCBoLCB1c2VOZWFyZXN0ID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgW3hzLCB5c10gPSB0aGlzLnRyYW5zZm9ybUNvb3Jkcyh4LCB5LCB0bHgsIHRseSwgdywgaCk7XHJcbiAgICByZXR1cm4gdGhpcy5zYW1wbGUoeHMsIHlzLCB1c2VOZWFyZXN0KVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIEFycmF5IDN4MyBuZWlnaGJvciB2YWx1ZXMgb2YgdGhlIGdpdmVuIHgseSBvZiB0aGUgZGF0YXNldC5cclxuICAvLyBPZmYtZWRnZSBuZWlnaGJvcnMgcmV2ZXJ0IHRvIG5lYXJlc3QgZWRnZSB2YWx1ZS5cclxuICBuZWlnaGJvcmhvb2QgKHgsIHksIGFycmF5ID0gW10pIHtcclxuICAgIGFycmF5Lmxlbmd0aCA9IDA7ICAvLyBpbiBjYXNlIHVzZXIgc3VwcGxpZWQgYW4gYXJyYXkgdG8gcmVkdWNlIEdDXHJcbiAgICBjb25zdCBjbGFtcE5lZWRlZCA9ICh4ID09PSAwKSB8fCAoeCA9PT0gdGhpcy53aWR0aCAtIDEpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh5ID09PSAwKSB8fCAoeSA9PT0gdGhpcy5oZWlnaHQgLSAxKTtcclxuICAgIGZvciAobGV0IGR5ID0gLTE7IGR5IDw9ICsxOyBkeSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGR4ID0gLTE7IGR4IDw9ICsxOyBkeCsrKSB7XHJcbiAgICAgICAgbGV0IHgwID0geCArIGR4O1xyXG4gICAgICAgIGxldCB5MCA9IHkgKyBkeTtcclxuICAgICAgICBpZiAoY2xhbXBOZWVkZWQpIHtcclxuICAgICAgICAgIHgwID0gdXRpbC5jbGFtcCh4MCwgMCwgdGhpcy53aWR0aCAtIDEpO1xyXG4gICAgICAgICAgeTAgPSB1dGlsLmNsYW1wKHkwLCAwLCB0aGlzLmhlaWdodCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhcnJheS5wdXNoKHRoaXMuZGF0YVt0aGlzLnRvSW5kZXgoeDAsIHkwKV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXlcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiBhIG5ldyBkYXRhc2V0IG9mIHRoaXMgYXJyYXkgdHlwZSBjb252b2x2ZWQgd2l0aCB0aGVcclxuICAvLyBnaXZlbiBrZXJuZWwgM3gzIG1hdHJpeC4gU2VlIFtDb252b2x1dGlvbiBhcnRpY2xlXShodHRwczovL2dvby5nbC9nQ2ZYbVUpXHJcbiAgLy9cclxuICAvLyBJZiBjcm9wcGVkLCBkbyBub3QgY29udm9sdmUgdGhlIGVkZ2VzLCByZXR1cm5pbmcgYSBzbWFsbGVyIGRhdGFzZXQuXHJcbiAgLy8gSWYgbm90LCBjb252b2x2ZSB0aGUgZWRnZXMgYnkgZXh0ZW5kaW5nIGVkZ2UgdmFsdWVzLCByZXR1cm5pbmdcclxuICAvLyBkYXRhc2V0IG9mIHNhbWUgc2l6ZS5cclxuICBjb252b2x2ZSAoa2VybmVsLCBmYWN0b3IgPSAxLCBjcm9wID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IFt4MCwgeTAsIGgsIHddID0gY3JvcCAvLyBvcHRpbWl6YXRpb24gbm90IG5lZWRlZCwgb25seSBjYWxsZWQgb25jZVxyXG4gICAgID8gWzEsIDEsIHRoaXMuaGVpZ2h0IC0gMSwgdGhpcy53aWR0aCAtIDFdXHJcbiAgICAgOiBbMCwgMCwgdGhpcy5oZWlnaHQsIHRoaXMud2lkdGhdO1xyXG4gICAgY29uc3QgbmV3RFMgPSB0aGlzLmVtcHR5RGF0YVNldCh3LCBoKTtcclxuICAgIGNvbnN0IG5ld0RhdGEgPSBuZXdEUy5kYXRhO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgZm9yIChsZXQgeSA9IHkwOyB5IDwgaDsgeSsrKSB7XHJcbiAgICAgIGZvciAobGV0IHggPSB4MDsgeCA8IHc7IHgrKykge1xyXG4gICAgICAgIGNvbnN0IG5laSA9IHRoaXMubmVpZ2hib3Job29kKHgsIHkpO1xyXG4gICAgICAgIGxldCBzdW0yID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwga2VybmVsLmxlbmd0aDsgaTIrKykge1xyXG4gICAgICAgICAgLy8gc3VtMiArPSBrZXJuZWxbaTJdICogbmVpW2kyXSAvLyBDaHJvbWUgY2FuJ3Qgb3B0aW1pemUgY29tcG91bmQgbGV0XHJcbiAgICAgICAgICBzdW0yID0gc3VtMiArIGtlcm5lbFtpMl0gKiBuZWlbaTJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdEYXRhW2krK10gPSBzdW0yICogZmFjdG9yOyAvLyBuZXdEUy5kYXRhW25ld0RTLnRvSW5kZXgoeCwgeSldID0gc3VtMiAqIGZhY3RvclxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3RFNcclxuICB9XHJcblxyXG4gIC8vIEEgZmV3IGNvbW1vbiBjb252b2x1dGlvbnMuICBkemR4L3kgYXJlIGFsc28gY2FsbGVkIGhvcml6L3ZlcnQgU29iZWxcclxuICBkemR4IChuID0gMiwgZmFjdG9yID0gMSAvIDgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnZvbHZlKFstMSwgMCwgMSwgLW4sIDAsIG4sIC0xLCAwLCAxXSwgZmFjdG9yKVxyXG4gIH1cclxuICBkemR5IChuID0gMiwgZmFjdG9yID0gMSAvIDgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnZvbHZlKFsxLCBuLCAxLCAwLCAwLCAwLCAtMSwgLW4sIC0xXSwgZmFjdG9yKVxyXG4gIH1cclxuICBsYXBsYWNlOCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb252b2x2ZShbLTEsIC0xLCAtMSwgLTEsIDgsIC0xLCAtMSwgLTEsIC0xXSlcclxuICB9XHJcbiAgbGFwbGFjZTQgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udm9sdmUoWzAsIC0xLCAwLCAtMSwgNCwgLTEsIDAsIC0xLCAwXSlcclxuICB9XHJcbiAgYmx1ciAoZmFjdG9yID0gMC4wNjI1KSB7IC8vIDEvMTYgPSAwLjA2MjVcclxuICAgIHJldHVybiB0aGlzLmNvbnZvbHZlKFsxLCAyLCAxLCAyLCA0LCAyLCAxLCAyLCAxXSwgZmFjdG9yKVxyXG4gIH1cclxuICBlZGdlICgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnZvbHZlKFsxLCAxLCAxLCAxLCAtNywgMSwgMSwgMSwgMV0pXHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgdHdvIG5ldyBBcnJheSBjb252b2x2ZWQgZGF0YXNldHMsIHNsb3BlIGFuZCBhc3BlY3QsIGNvbW1vbiBpblxyXG4gIC8vIHRoZSB1c2Ugb2YgYW4gZWxldmF0aW9uIGRhdGEgc2V0LiBTZWUgRXNyaSB0dXRvcmlhbHMgZm9yXHJcbiAgLy8gW3Nsb3BlXShodHRwOi8vZ29vLmdsL1pjT2wwOCkgYW5kIFthc3BlY3RdKGh0dHA6Ly9nb28uZ2wvS29JNHk1KVxyXG4gIC8vXHJcbiAgLy8gSXQgYWxzbyByZXR1cm5zIHRoZSB0d28gZGVyaXZpdGl2ZSBEYXRhU2V0cywgZHpkeCwgZHpkeSBmb3JcclxuICAvLyB0aG9zZSB3YW50aW5nIHRvIHVzZSB0aGUgcmVzdWx0cyBvZiB0aGUgdHdvIGNvbnZvbHV0aW9ucy5cclxuICAvL1xyXG4gIC8vIFVzZSB0aGlzLmNvbnZlcnRUeXBlIHRvIGNvbnZlcnQgdG8gdHlwZWQgYXJyYXlcclxuICBzbG9wZUFuZEFzcGVjdCAoY2VsbFNpemUgPSAxLCBub05hTnMgPSB0cnVlLCBwb3NBbmdsZSA9IHRydWUpIHtcclxuICAgIGNvbnN0IGR6ZHggPSB0aGlzLmR6ZHgoKTsgLy8gc3ViIGxlZnQgeiBmcm9tIHJpZ2h0XHJcbiAgICBjb25zdCBkemR5ID0gdGhpcy5kemR5KCk7IC8vIHN1YiBib3R0b20geiBmcm9tIHRvcFxyXG4gICAgbGV0IFthc3BlY3QsIHNsb3BlXSA9IFtbXSwgW11dO1xyXG4gICAgY29uc3QgW2gsIHddID0gW2R6ZHguaGVpZ2h0LCBkemR4LndpZHRoXTtcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaDsgeSsrKSB7XHJcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdzsgeCsrKSB7XHJcbiAgICAgICAgbGV0IFtneCwgZ3ldID0gW2R6ZHguZ2V0WFkoeCwgeSksIGR6ZHkuZ2V0WFkoeCwgeSldO1xyXG4gICAgICAgIHNsb3BlLnB1c2goTWF0aC5hdGFuKHV0aWwuZGlzdGFuY2UoZ3gsIGd5KSkgLyBjZWxsU2l6ZSk7IC8vIHJhZGlhbnNcclxuICAgICAgICBpZiAobm9OYU5zKVxyXG4gICAgICAgICAgd2hpbGUgKGd4ID09PSBneSkge1xyXG4gICAgICAgICAgICBneCArPSB1dGlsLnJhbmRvbU5vcm1hbCgwLCAwLjAwMDEpO1xyXG4gICAgICAgICAgICBneSArPSB1dGlsLnJhbmRvbU5vcm1hbCgwLCAwLjAwMDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIC8vIHJhZGlhbnMgaW4gWy1QSSxQSV0sIGRvd25oaWxsXHJcbiAgICAgICAgbGV0IHJhZCA9IChneCA9PT0gZ3kgJiYgZ3kgPT09IDApID8gTmFOIDogTWF0aC5hdGFuMigtZ3ksIC1neCk7XHJcbiAgICAgICAgLy8gcG9zaXRpdmUgcmFkaWFucyBpbiBbMCwyUEldIGlmIGRlc2lyZWRcclxuICAgICAgICBpZiAocG9zQW5nbGUgJiYgcmFkIDwgMCkgcmFkICs9IDIgKiBNYXRoLlBJO1xyXG4gICAgICAgIGFzcGVjdC5wdXNoKHJhZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHNsb3BlID0gbmV3IERhdGFTZXQodywgaCwgc2xvcGUpO1xyXG4gICAgYXNwZWN0ID0gbmV3IERhdGFTZXQodywgaCwgYXNwZWN0KTtcclxuICAgIHJldHVybiB7IHNsb3BlLCBhc3BlY3QsIGR6ZHgsIGR6ZHkgfVxyXG4gIH1cclxuXHJcbiAgLy8gUkVNSU5EOiBsaW1pdCB0byBkYXRhIHRoYXQgY2FuIGJlIDI0IGJpdC4gRXJyb3Igb3RoZXJ3aXNlLlxyXG4gIC8vIERhdGFUeXBlIG9mIEludDgsIDE2LCBJbnQyNCBPSywgb3RoZXJzIG5lZWQgdGVzdGluZy5cclxuICAvLyBQb3NzaWJseSB1c2UgcHJlY2lzaW9uIHRvIG1pbmltaXplIGJ5dGUgc2l6ZSB0byAzLCByZ2I/XHJcbiAgLy9cclxuICAvLyBDb252ZXJ0IGRhdGFzZXQgdG8gYW4gaW1hZ2UgY29udGV4dCBvYmplY3QuXHJcbiAgLy9cclxuICAvLyBUaGlzIGNhbiBiZSB1c2VkIHRvIFwidmlzdWFsaXplXCIgdGhlIGRhdGEgYnkgbm9ybWFsaXppbmdcclxuICAvLyB3aGljaCB3aWxsIHNjYWxlIHRoZSBkYXRhIHRvIHVzZSB0aGUgZW50aXJlIFJHQiBzcGFjZS5cclxuICAvLyBJdCBjYW4gYWxzbyBiZSB1c2VkIHRvIGNyZWF0ZSB0aWxlcyBvciBpbWFnZS1hcy1kYXRhIGlmXHJcbiAgLy8gdGhlIGRlZmF1bHRzIGFyZSB1c2VkLlxyXG4gIC8vXHJcbiAgLy8gRHVlIHRvXHJcbiAgLy8gW2FscGhhLXByZW11bHRpcGx5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbHBoYV9jb21wb3NpdGluZyksXHJcbiAgLy8gdGhlIGJlc3Qgd2UgY2FuIGRvIGFzIGRhdGEgaXMgMjQgYml0IGludHMuXHJcbiAgLy8gWW91IGNhbiBzaW11bGF0ZSBmbG9hdHMvZml4ZWQgYnkgbXVsdGlwbHlpbmcgdGhlIGRhdGFzZXRcclxuICAvLyB0aGUgZGl2aWRpbmcgb24gY29udmVyc2lvbiBiYWNrLlxyXG4gIC8vXHJcbiAgLy8gT3VyIHByZWZlcnJlZCB0cmFuc3BvcnQgaXMgaW4gdGhlIHdvcmtzLCBsaWtlbHkgaW4gdGhlXHJcbiAgLy8gdGlsZSBkYXRhc2V0cyB2aWEgYmxvYnMgb3IgYXJyYXlidWZmZXJzLiBTaWdoLlxyXG4gIHRvQ29udGV4dCAobm9ybWFsaXplID0gZmFsc2UsIGdyYXkgPSBmYWxzZSwgYWxwaGEgPSAyNTUpIHtcclxuICAgIGNvbnN0IFt3LCBoLCBkYXRhXSA9IFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5kYXRhXTtcclxuICAgIGxldCBpZGF0YTtcclxuICAgIGlmIChub3JtYWxpemUpIHtcclxuICAgICAgaWRhdGEgPSBncmF5XHJcbiAgICAgICAgPyB1dGlsLm5vcm1hbGl6ZTgoZGF0YSkgOiB1dGlsLm5vcm1hbGl6ZUludChkYXRhLCAwLCBNYXRoLnBvdygyLCAyNCkgLSAxKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlkYXRhID0gZGF0YS5tYXAoKGEpID0+IE1hdGgucm91bmQoYSkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY3R4ID0gdXRpbC5jcmVhdGVDdHgodywgaCk7XHJcbiAgICBjb25zdCBpZCA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XHJcbiAgICBjb25zdCB0YSA9IGlkLmRhdGE7IC8vIHRhIHNob3J0IGZvciB0eXBlZCBhcnJheVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBbbnVtLCBqXSA9IFtpZGF0YVtpXSwgNCAqIGldOyAvLyBqID0gYnl0ZSBpbmRleCBpbnRvIHRhXHJcbiAgICAgIGlmIChncmF5KSB7XHJcbiAgICAgICAgdGFbal0gPSB0YVtqICsgMV0gPSB0YVtqICsgMl0gPSBNYXRoLmZsb29yKG51bSk7IHRhW2ogKyAzXSA9IGFscGhhO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRhW2pdID0gKG51bSA+PiAxNikgJiAweGZmO1xyXG4gICAgICAgIHRhW2ogKyAxXSA9IChudW0gPj4gOCkgJiAweGZmO1xyXG4gICAgICAgIHRhW2ogKyAyXSA9IG51bSAmIDB4ZmY7XHJcbiAgICAgICAgdGFbaiArIDNdID0gYWxwaGE7IC8vIGlmIG5vdCAyNTUsIGltYWdlIHdpbGwgYmUgcHJlbXVsdGlwbGllZC5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3R4LnB1dEltYWdlRGF0YShpZCwgMCwgMCk7XHJcbiAgICByZXR1cm4gY3R4XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IGRhdGFzZXQgdG8gYSBjYW52YXMsIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGFuIGltYWdlXHJcbiAgdG9DYW52YXMgKG5vcm1hbGl6ZSA9IGZhbHNlLCBncmF5ID0gZmFsc2UsIGFscGhhID0gMjU1KSB7XHJcbiAgICByZXR1cm4gdGhpcy50b0NvbnRleHQoZ3JheSwgbm9ybWFsaXplLCBhbHBoYSkuY2FudmFzXHJcbiAgfVxyXG4gIC8vIENvbnZlcnQgZGF0YXNldCB0byBhIGJhc2U2NCBzdHJpbmdcclxuICB0b0RhdGFVcmwgKG5vcm1hbGl6ZSA9IGZhbHNlLCBncmF5ID0gZmFsc2UsIGFscGhhID0gMjU1KSB7XHJcbiAgICByZXR1cm4gdXRpbC5jdHhUb0RhdGFVcmwodGhpcy50b0NvbnRleHQoZ3JheSwgbm9ybWFsaXplLCBhbHBoYSkpXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gbWF4L21pbiBvZiBkYXRhXHJcbiAgbWF4ICgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLm1heChhLCBiKVxyXG4gICAgfSlcclxuICB9XHJcbiAgbWluICgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLm1pbihhLCBiKVxyXG4gICAgfSlcclxuICB9XHJcbiAgLy8gVGVzdCB0aGF0IHRoaXMgaGFzIHNhbWUgd2lkdGgsIGhlaWdodCwgZGF0YSBhcyBkYXRhc2V0LlxyXG4gIC8vIE5vdGU6IGRvZXMgbm90IHJlcXVpcmUgZXF1YWwgYXJyYXkgdHlwZSAoQXJyYXkgb3IgVHlwZWRBcnJheSlcclxuICBlcXVhbHMgKGRhdGFzZXQpIHtcclxuICAgIHJldHVybiB0aGlzLndpZHRoID09PSBkYXRhc2V0LndpZHRoICYmXHJcbiAgICAgIHRoaXMuaGVpZ2h0ID09PSBkYXRhc2V0LmhlaWdodCAmJlxyXG4gICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMuZGF0YSwgZGF0YXNldC5kYXRhKVxyXG4gIH1cclxufVxyXG5cclxuLy8gQW4gLmFzYyBHSVMgZmlsZTogYSB0ZXh0IGZpbGUgd2l0aCBhIGhlYWRlcjpcclxuLy9cclxuLy8gICAgIG5jb2xzIDE5NVxyXG4vLyAgICAgbnJvd3MgMTk1XHJcbi8vICAgICB4bGxjb3JuZXIgLTg0LjM1NTY1MlxyXG4vLyAgICAgeWxsY29ybmVyIDM5LjE3Nzk2M1xyXG4vLyAgICAgY2VsbHNpemUgMC4wMDAwOTNcclxuLy8gICAgIE5PREFUQV92YWx1ZSAtOTk5OVxyXG4vL1xyXG4vLyAuLmZvbGxvd2VkIGJ5IGEgbmNvbHMgWCBucm93cyBtYXRyaXggb2YgbnVtYmVyc1xyXG5cclxuY2xhc3MgQXNjRGF0YVNldCBleHRlbmRzIERhdGFTZXQge1xyXG4gIGNvbnN0cnVjdG9yIChhc2NTdHJpbmcsIFR5cGUgPSBBcnJheSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCB0ZXh0RGF0YSA9IGFzY1N0cmluZy5zcGxpdCgnXFxuJyk7XHJcbiAgICBjb25zdCBoZWFkZXIgPSB7fTtcclxuICAgIHV0aWwucmVwZWF0KDYsIChpKSA9PiB7XHJcbiAgICAgIGNvbnN0IGtleVZhbCA9IHRleHREYXRhW2ldLnNwbGl0KC9cXHMrLyk7XHJcbiAgICAgIGhlYWRlcltrZXlWYWxbMF0udG9Mb3dlckNhc2UoKV0gPSBwYXJzZUZsb2F0KGtleVZhbFsxXSk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGRhdGEgPSBbXTtcclxuICAgIHV0aWwucmVwZWF0KGhlYWRlci5ucm93cywgKGkpID0+IHtcclxuICAgICAgY29uc3QgbnVtcyA9IHRleHREYXRhWzYgKyBpXS50cmltKCkuc3BsaXQoJyAnKTtcclxuICAgICAgZm9yIChjb25zdCBudW0gb2YgbnVtcylcclxuICAgICAgICBkYXRhLnB1c2gocGFyc2VGbG9hdChudW0pKTtcclxuICAgIH0pO1xyXG4gICAgc3VwZXIoaGVhZGVyLm5jb2xzLCBoZWFkZXIubnJvd3MsIHV0aWwuY29udmVydEFycmF5KGRhdGEsIFR5cGUpKTtcclxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydC9JbXBvcnQgRGF0YVNldHNcclxuLy8gaW1wb3J0IERhdGFTZXQgZnJvbSAnLi9EYXRhU2V0LmpzJ1xyXG4vLyBQcml2YXRlIHV0aWxpdHkgZnVuY3Rpb25zOlxyXG5cclxuLy8gQ3JlYXRlIGEgbGVnYWwgZGF0YXNldCBKU09OIG9iamVjdCwgZGVmYXVsdGluZyB0byBiYXNlNjQgZGF0YSBzdHJpbmcuXHJcbi8vIFRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IEpTT04uc3RyaW5naWZ5IHdpbGwgdXNlIGZvciBJT1xyXG5mdW5jdGlvbiBqc29uT2JqZWN0IChkYXRhc2V0LCB1c2VCYXNlNjQsIG1ldGEpIHtcclxuICByZXR1cm4ge1xyXG4gICAgd2lkdGg6IGRhdGFzZXQud2lkdGgsXHJcbiAgICBoZWlnaHQ6IGRhdGFzZXQuaGVpZ2h0LFxyXG4gICAgZGF0YTogYXJyYXlUb1N0cmluZyhkYXRhc2V0LmRhdGEsIHVzZUJhc2U2NCksXHJcbiAgICBkYXRhVHlwZTogZGF0YXNldC5kYXRhVHlwZSgpLm5hbWUsXHJcbiAgICBtZXRhOiBtZXRhXHJcbiAgfVxyXG59XHJcbi8vIENvbnZlcnQgYW4gYXJyYXksIFR5cGVkIG9yIEpTLCB0byBhIHN0cmluZyBmb3IgZGF0YXNldCdzIGRhdGEgYXJyYXlcclxuZnVuY3Rpb24gYXJyYXlUb1N0cmluZyAoYXJyYXksIHVzZUJhc2U2NCkge1xyXG4gIGlmICh1c2VCYXNlNjQpIHtcclxuICAgIGNvbnN0IGRhdGEgPSB1dGlsLmFycmF5VG9CdWZmZXIoYXJyYXkpO1xyXG4gICAgcmV0dXJuIHV0aWwuYnVmZmVyVG9CYXNlNjQoZGF0YSlcclxuICB9XHJcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHV0aWwuY29udmVydEFycmF5KGFycmF5LCBBcnJheSkpXHJcbn1cclxuLy8gQ29udmVydCBhIHN0cmluZywgYmFzZTY0IG9yIEpTT04sIHRvIGFuIGFycmF5IG9mIHRoZSBnaXZlbiBUeXBlXHJcbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkgKHN0cmluZywgZGF0YVR5cGVOYW1lKSB7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB3aW5kb3dbZGF0YVR5cGVOYW1lXTtcclxuICBpZiAoaXNCYXNlNjQoc3RyaW5nKSkge1xyXG4gICAgY29uc3QgdWludDhhcnJheSA9IHV0aWwuYmFzZTY0VG9CdWZmZXIoc3RyaW5nKTtcclxuICAgIHJldHVybiB1dGlsLmJ1ZmZlclRvQXJyYXkodWludDhhcnJheSwgZGF0YVR5cGUpXHJcbiAgfVxyXG4gIHJldHVybiB1dGlsLmNvbnZlcnRBcnJheShKU09OLnBhcnNlKHN0cmluZyksIGRhdGFUeXBlKVxyXG59XHJcbmZ1bmN0aW9uIGlzQmFzZTY0IChhcnJheVN0cmluZykge1xyXG4gIC8vIEJhc2U2NCBkb2VzIG5vdCBhbGxvdyAnWycsIG9ubHkgQS1aLCBhLXosIDAtOSwgKywgL1xyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NFxyXG4gIHJldHVybiBhcnJheVN0cmluZ1swXSAhPT0gJ1snXHJcbn1cclxuXHJcbmNvbnN0IERhdGFTZXRJTyA9IHtcclxuICAvLyBKU09OIGltcG9ydC9leHBvcnQuIFRoZSBKU09OIHJldHVybmVkIGxvb2tzIGxpa2U6XHJcbiAgLy8gYGBgXHJcbiAgLy8ge1xyXG4gIC8vICAgd2lkdGg6IGRhdGFzZXQud2lkdGgsXHJcbiAgLy8gICBoZWlnaHQ6IGRhdGFzZXQuaGVpZ2h0LFxyXG4gIC8vICAgZGF0YTogc3RyaW5nLCAvLyBqc29uIG9yIGJhc2U2NCBzdHJpbmcgb2YgRGF0YVNldCBhcnJheVxyXG4gIC8vICAgZGF0YVR5cGU6IHN0cmluZywgLy8gbmFtZSBvZiBkYXRhIGFycmF5IHR5cGU6IFR5cGVkQXJyYXkgb3IgQXJyYXlcclxuICAvLyAgIHR5cGU6IHN0cmluZywgLy8gZGF0YXNldCBjbGFzcyBuYW1lXHJcbiAgLy8gfVxyXG4gIC8vIGBgYFxyXG5cclxuICAvLyBDcmVhdGUgSlNPTiBzdHJpbmcgZnJvbSBEYXRhU2V0LCBzZWUganNvbk9iamVjdCBhYm92ZVxyXG4gIGRhdGFTZXRUb0pzb24gKGRhdGFzZXQsIHVzZUJhc2U2NCA9IHRydWUsIG1ldGEgPSB7fSkge1xyXG4gICAgY29uc3Qgb2JqID0ganNvbk9iamVjdChkYXRhc2V0LCB1c2VCYXNlNjQsIG1ldGEpO1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iailcclxuICB9LFxyXG5cclxuICAvLyBDb252ZXJ0IHRoZSBqc29uT2JqZWN0IHN0cmluZyB0byBhIGJhc2ljIGRhdGFzZXQ6IHdpZHRoLCBoZWlnaHQsIGRhdGEuXHJcbiAgLy8gVGhlIGRhdGEgYXJyYXkgd2lsbCBiZSB0aGUgc2FtZSB0eXBlIGFzIHRoZSBvcmlnaW5hbCBkYXRhc2V0LlxyXG4gIGpzb25Ub0RhdGFTZXQgKGpzb25TdHJpbmcpIHtcclxuICAgIGNvbnN0IGpzb25PYmogPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xyXG4gICAgY29uc3QgZGF0YSA9IHN0cmluZ1RvQXJyYXkoanNvbk9iai5kYXRhLCBqc29uT2JqLmRhdGFUeXBlKTtcclxuICAgIHJldHVybiBuZXcgRGF0YVNldChqc29uT2JqLndpZHRoLCBqc29uT2JqLmhlaWdodCwgZGF0YSlcclxuICB9LFxyXG5cclxuICAvLyBJbmRleGVkREIgdXNlcyB0aGUgW1N0cnVjdHVyZWQgQ2xvbmUgQWxnb3JpdGhtXShodHRwczovL2dvby5nbC94OEg5SEspLlxyXG4gIC8vIERhdGFTZXRzIGNhbiBiZSBkaXJlY3RseSBzdG9yZWQgYW5kIHJldHJpZXZlZCwgdGhleSBzYXRpc2Z5XHJcbiAgLy8gdGhlIFNDQSByZXF1aXJlbWVudHMuXHJcbiAgdG9JbmRleGVkREIgKGRhdGFzZXQpIHtcclxuICAgIHJldHVybiBkYXRhc2V0IC8vIHBsYWNlIGhvbGRlciBmb3IgSURCIHN1Z2FyIGlmIG5lZWRlZFxyXG4gIH1cclxufTtcclxuXHJcbi8vIEEgc21hbGwgSW50MjQvVWludDI0IG1vZHVsZSwgbWFpbmx5IGZvciByZ2IgaW1hZ2UgZGF0YVxyXG5cclxuLy8gQSBzaGFyZWQgNCBlbGVtZW50IFVpbnQ4QXJyYXkgYXJyYXkgYW5kIHR3byAxIGVsZW1lbnQgMzJiaXQgdmlld3NcclxuY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcbmNvbnN0IHVpbnQyNGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ5dGVBcnJheS5idWZmZXIpO1xyXG5jb25zdCBpbnQyNGFycmF5ID0gbmV3IEludDMyQXJyYXkoYnl0ZUFycmF5LmJ1ZmZlcik7XHJcblxyXG5jb25zdCBJbnQyNCA9IHtcclxuXHJcbiAgbWF4VWludDI0OiAoMiAqKiAyNCkgLSAxLFxyXG4gIG1pblVpbnQyNDogMCxcclxuICBtYXhJbnQyNDogKDIgKiogMjMpIC0gMSxcclxuICBtaW5JbnQyNDogMCAtICgyICoqIDIzKSwgLy8gUkVNSU5EOiByb2xsdXAgYnVnXHJcblxyXG4gIGNoZWNrSW50MjQgKGludCkge1xyXG4gICAgaWYgKGludCA8IHRoaXMubWluSW50MjQgfHwgaW50ID4gdGhpcy5tYXhJbnQyNClcclxuICAgICAgdGhyb3cgRXJyb3IoYEludDI0OiBSYW5nZSBlcnJvciAke2ludH1gKVxyXG4gIH0sXHJcbiAgY2hlY2tVaW50MjQgKGludCkge1xyXG4gICAgaWYgKGludCA8IHRoaXMubWluVWludDI0IHx8IGludCA+IHRoaXMubWF4VWludDI0KVxyXG4gICAgICB0aHJvdyBFcnJvcihgVWludDI0OiBSYW5nZSBlcnJvciAke2ludH1gKVxyXG4gIH0sXHJcblxyXG4gIC8vIFJHQiBtb3N0IGNvbW1vbiBjYXNlIGJ1dCBhbnkgMyBzZXF1ZW50aWFsIGJ5dGVzIE9LXHJcbiAgcmdiVG9JbnQyNCAociwgZywgYikge1xyXG4gICAgLy8gYnl0ZUFycmF5LnNldChbciwgZywgYiwgYiA+IDEyNyA/IDI1NSA6IDBdKSAvLyBzbG93IVxyXG4gICAgYnl0ZUFycmF5WzBdID0gcjtcclxuICAgIGJ5dGVBcnJheVsxXSA9IGc7XHJcbiAgICBieXRlQXJyYXlbMl0gPSBiO1xyXG4gICAgYnl0ZUFycmF5WzNdID0gYiA+IDEyNyA/IDI1NSA6IDA7XHJcbiAgICByZXR1cm4gaW50MjRhcnJheVswXVxyXG4gIH0sXHJcbiAgcmdiVG9VaW50MjQgKHIsIGcsIGIpIHtcclxuICAgIGJ5dGVBcnJheVswXSA9IHI7XHJcbiAgICBieXRlQXJyYXlbMV0gPSBnO1xyXG4gICAgYnl0ZUFycmF5WzJdID0gYjtcclxuICAgIGJ5dGVBcnJheVszXSA9IDA7XHJcbiAgICByZXR1cm4gdWludDI0YXJyYXlbMF1cclxuICB9LFxyXG4gIGludDI0VG9SR0IgKGludDI0KSB7XHJcbiAgICB0aGlzLmNoZWNrSW50MjQoaW50MjQpO1xyXG4gICAgaW50MjRhcnJheVswXSA9IGludDI0O1xyXG4gICAgLy8gcmV0dXJuIGJ5dGVBcnJheS5zbGljZSgwLCAzKSAvLyBzbG93IVxyXG4gICAgcmV0dXJuIFtieXRlQXJyYXlbMF0sIGJ5dGVBcnJheVsxXSwgYnl0ZUFycmF5WzJdXVxyXG4gIH0sXHJcbiAgdWludDI0VG9SR0IgKHVpbnQyNCkge1xyXG4gICAgdGhpcy5jaGVja1VpbnQyNCh1aW50MjQpO1xyXG4gICAgdWludDI0YXJyYXlbMF0gPSB1aW50MjQ7XHJcbiAgICByZXR1cm4gW2J5dGVBcnJheVswXSwgYnl0ZUFycmF5WzFdLCBieXRlQXJyYXlbMl1dXHJcbiAgfVxyXG5cclxufTtcclxuXHJcbi8vIEZseXdlaWdodCBvYmplY3QgY3JlYXRpb24sIHNlZSBQYXRjaC9QYXRjaGVzLlxyXG5cclxuLy8gQ2xhc3MgTGluayBpbnN0YW5jZXMgZm9ybSBhIGxpbmsgYmV0d2VlbiB0d28gdHVydGxlcywgZm9ybWluZyBhIGdyYXBoLlxyXG5cclxuLy8gVGhlIGNvcmUgZGVmYXVsdCB2YXJpYWJsZXMgbmVlZGVkIGJ5IGEgTGluay5cclxuLy8gVXNlIGxpbmtzLnNldERlZmF1bHQobmFtZSwgdmFsKSB0byBjaGFuZ2VcclxuLy8gTW9kZWxlcnMgYWRkIGFkZGl0aW9uYWwgXCJvd24gdmFyaWFibGVzXCIgYXMgbmVlZGVkLlxyXG4vLyBjb25zdCBsaW5rVmFyaWFibGVzID0geyAvLyBDb3JlIHZhcmlhYmxlcyBmb3IgcGF0Y2hlcy4gTm90ICdvd24nIHZhcmlhYmxlcy5cclxuLy8gICAvLyBpZDogbnVsbCwgICAgICAgICAgICAgLy8gdW5pcXVlIGlkLCBwcm9tb3RlZCBieSBhZ2VudHNldCdzIGFkZCgpIG1ldGhvZFxyXG4vLyAgIC8vIGRlZmF1bHRzOiBudWxsLCAgICAgICAvLyBwb2ludGVyIHRvIGRlZmF1bHRzL3Byb3RvIG9iamVjdFxyXG4vLyAgIC8vIGFnZW50U2V0OiBudWxsLCAgICAgICAvLyBteSBhZ2VudHNldC9icmVlZFxyXG4vLyAgIC8vIG1vZGVsOiBudWxsLCAgICAgIC8vIG15IG1vZGVsXHJcbi8vICAgLy8gd29ybGQ6IG51bGwsICAgICAgICAgIC8vIG15IGFnZW50L2FnZW50c2V0J3Mgd29ybGRcclxuLy8gICAvLyBsaW5rczogbnVsbCwgICAgICAgICAgLy8gbXkgYmFzZVNldFxyXG4vL1xyXG4vLyAgIGVuZDA6IDAsICAgICAgICAgICAgICAvLyBUdXJ0bGVzOiBlbmQwICYgMSBhcmUgdHVydGxlIGVuZHMgb2YgdGhlIGxpbmtcclxuLy8gICBlbmQxOiAwLFxyXG4vLyAgIGNvbG9yOiBDb2xvci50b0NvbG9yKCd5ZWxsb3cnKSwgLy8gTm90ZTogbGlua3MgbXVzdCBoYXZlIEEgPSAyNTUsIG9wYXF1ZS5cclxuLy8gICAvLyB6OiAxLCAvLyBwb3NzaWJseSBhIHogb2Zmc2V0IGZyb20gdGhlIHR1cnRsZXM/XHJcbi8vXHJcbi8vICAgLy8gTGluZSB3aWR0aC4gSW4gVGhyZWUuanMvd2ViZ2wgdGhpcyBpcyBhbHdheXMgMS4gU2VlXHJcbi8vICAgLy8gW0RyYXdpbmcgTGluZXMgaXMgSGFyZCFdKGh0dHBzOi8vbWF0dGRlc2wuc3ZidGxlLmNvbS9kcmF3aW5nLWxpbmVzLWlzLWhhcmQpXHJcbi8vICAgd2lkdGg6IDFcclxuLy8gfVxyXG5jbGFzcyBMaW5rIHtcclxuICBzdGF0aWMgZGVmYXVsdFZhcmlhYmxlcyAoKSB7IC8vIENvcmUgdmFyaWFibGVzIGZvciBwYXRjaGVzLiBOb3QgJ293bicgdmFyaWFibGVzLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZW5kMDogbnVsbCwgICAgICAgLy8gVHVydGxlczogZW5kMCAmIDEgYXJlIHR1cnRsZSBlbmRzIG9mIHRoZSBsaW5rXHJcbiAgICAgIGVuZDE6IG51bGwsXHJcbiAgICAgIHR5cGVkQ29sb3I6IG51bGwsIC8vIEEgQ29sb3IuY29sb3IsIGNvbnZlcnRlZCBieSBnZXR0ZXIvc2V0dGVycyBiZWxvd1xyXG4gICAgICB3aWR0aDogMSAgICAgICAgICAvLyBUSFJFRTogbXVzdCBiZSAxLiBDYW52YXMyRCAodW5zdXBwb3J0ZWQpIGhhcyB3aWR0aHMuXHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIEluaXRpYWxpemUgYSBMaW5rXHJcbiAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgLy8gY29uc3QgdmFycyA9IExpbmsuZGVmYXVsdFZhcmlhYmxlcygpXHJcbiAgICAvLyBPYmplY3QuYXNzaWduKHRoaXMsIHZhcnMpXHJcbiAgICAvLyB0aGlzLmNvbG9yID0gbnVsbCAvLyBhdm9pZCBnZXR0ZXIvc2V0dGVyIHVzZWQgYnkgYXNzaWduXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIExpbmsuZGVmYXVsdFZhcmlhYmxlcygpKTtcclxuICB9XHJcbiAgaW5pdCAoZnJvbSwgdG8pIHtcclxuICAgIHRoaXMuZW5kMCA9IGZyb207XHJcbiAgICB0aGlzLmVuZDEgPSB0bztcclxuICAgIGZyb20ubGlua3MucHVzaCh0aGlzKTtcclxuICAgIHRvLmxpbmtzLnB1c2godGhpcyk7XHJcbiAgfVxyXG4gIC8vIFJlbW92ZSB0aGlzIGxpbmsgZnJvbSBpdHMgYWdlbnRzZXRcclxuICBkaWUgKCkge1xyXG4gICAgdGhpcy5hZ2VudFNldC5yZW1vdmVBZ2VudCh0aGlzKTtcclxuICAgIHV0aWwucmVtb3ZlSXRlbSh0aGlzLmVuZDAubGlua3MsIHRoaXMpO1xyXG4gICAgdXRpbC5yZW1vdmVJdGVtKHRoaXMuZW5kMS5saW5rcywgdGhpcyk7XHJcbiAgfVxyXG5cclxuICBib3RoRW5kcyAoKSB7IHJldHVybiBbdGhpcy5lbmQwLCB0aGlzLmVuZDFdIH1cclxuICBsZW5ndGggKCkgeyByZXR1cm4gdGhpcy5lbmQwLmRpc3RhbmNlKHRoaXMuZW5kMSkgfVxyXG4gIG90aGVyRW5kICh0dXJ0bGUpIHtcclxuICAgIGlmICh0dXJ0bGUgPT09IHRoaXMuZW5kMCkgcmV0dXJuIHRoaXMuZW5kMVxyXG4gICAgaWYgKHR1cnRsZSA9PT0gdGhpcy5lbmQxKSByZXR1cm4gdGhpcy5lbmQwXHJcbiAgICB0aHJvdyBFcnJvcihgTGluay5vdGhlckVuZDogdHVydGxlIG5vdCBhIGxpbmsgdHVydGxlOiAke3R1cnRsZX1gKVxyXG4gIH1cclxuXHJcbiAgLy8gVXNlIHR5cGVkQ29sb3IgYXMgdGhlIHJlYWwgY29sb3IuIEFtYXppbmdseSBlbm91Z2gsIHNldGRlZmF1bHRzXHJcbiAgLy8gb2YgJ2NvbG9yJyBlbmRzIHVwIGNhbGxpbmcgc2V0dGVyLCB0aHVzIG1ha2luZyB0eXBlZENvbG9yIHRoZSBkZWZhdWx0IG5hbWUuXHJcbiAgLy8gV2hldyFcclxuICBzZXRDb2xvciAoY29sb3IpIHtcclxuICAgIGNvbnN0IHR5cGVkQ29sb3IgPSBDb2xvci50b0NvbG9yKGNvbG9yKTsgLy8gQ29udmVydCB0byBDb2xvci5jb2xvclxyXG4gICAgY29uc3QgZml4ZWRDb2xvciA9IHRoaXMubGlua3MucmVuZGVyZXIuZml4ZWRDb2xvcjsgLy8gTW9kZWwgc2V0IHRvIENvbG9yLmNvbG9yXHJcbiAgICBpZiAoZml4ZWRDb2xvciAmJiAhdHlwZWRDb2xvci5lcXVhbHMoZml4ZWRDb2xvcikpIHtcclxuICAgICAgdXRpbC53YXJuKGBsaW5rcy5zZXRDb2xvcjogZml4ZWRDb2xvciAhPSBjb2xvciAke2ZpeGVkQ29sb3IudG9TdHJpbmcoKX1gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudHlwZWRDb2xvciA9IHR5cGVkQ29sb3I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldENvbG9yICgpIHsgcmV0dXJuIHRoaXMudHlwZWRDb2xvciB9XHJcbiAgc2V0IGNvbG9yIChjb2xvcikgeyB0aGlzLnNldENvbG9yKGNvbG9yKTsgfVxyXG4gIGdldCBjb2xvciAoKSB7IHJldHVybiB0aGlzLmdldENvbG9yKCkgfVxyXG4gIC8vIGNvbG9yIHByb3AgY2FuIGJlIHVzZWQgYnkgKm11c3QqIGJlIENvbG9yLmNvbG9yc1xyXG59XHJcblxyXG4vLyBMaW5rcyBhcmUgYSBjb2xsZWN0aW9uIG9mIGFsbCB0aGUgTGluayBvYmplY3RzIGJldHdlZW4gdHVydGxlcy5cclxuY2xhc3MgTGlua3MgZXh0ZW5kcyBBZ2VudFNldCB7XHJcbiAgLy8gY29uc3RydWN0b3IgKG1vZGVsLCBBZ2VudENsYXNzLCBuYW1lKSB7XHJcbiAgLy8gICAvLyBBZ2VudFNldCBzZXRzIHRoZXNlIHZhcmlhYmxlczpcclxuICAvLyAgIC8vIG1vZGVsLCBuYW1lLCBiYXNlU2V0LCB3b3JsZDogbW9kZWwud29ybGQgJiBhZ2VudFByb3RvOiBuZXcgQWdlbnRDbGFzc1xyXG4gIC8vICAgc3VwZXIobW9kZWwsIEFnZW50Q2xhc3MsIG5hbWUpXHJcbiAgLy8gICAvLyBTa2lwIGlmIGFuIGJhc2ljIEFycmF5IGN0b3Igb3IgYSBicmVlZFNldC4gU2VlIEFnZW50U2V0IGNvbW1lbnRzLlxyXG4gIC8vICAgLy8gaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ251bWJlcicgfHwgdGhpcy5pc0JyZWVkU2V0KCkpIHJldHVyblxyXG4gIC8vXHJcbiAgLy8gICAvLyB0aGlzLmxhYmVscyA9IFtdIC8vIHNwYXJzZSBhcnJheSBmb3IgbGFiZWxzXHJcbiAgLy8gfVxyXG5cclxuICAvLyBGYWN0b3J5OiBBZGQgMSBvciBtb3JlIGxpbmtzIGZyb20gdGhlIGZyb20gdHVydGxlIHRvIHRoZSB0byB0dXJ0bGUocykgd2hpY2hcclxuICAvLyBjYW4gYmUgYSBzaW5nbGUgdHVydGxlIG9yIGFuIGFycmF5IG9mIHR1cnRsZXMuIFRoZSBvcHRpb25hbCBpbml0XHJcbiAgLy8gcHJvYyBpcyBjYWxsZWQgb24gdGhlIG5ldyBsaW5rIGFmdGVyIGluc2VydGluZyBpbiB0aGUgYWdlbnRTZXQuXHJcbiAgY3JlYXRlIChmcm9tLCB0bywgaW5pdEZjbiA9IChsaW5rKSA9PiB7fSkge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRvKSkgdG8gPSBbdG9dO1xyXG4gICAgcmV0dXJuIHRvLm1hcCgodCkgPT4geyAvLyBSRU1JTkQ6IHNraXAgZHVwc1xyXG4gICAgICBjb25zdCBsaW5rID0gdGhpcy5hZGRBZ2VudCgpO1xyXG4gICAgICBsaW5rLmluaXQoZnJvbSwgdCk7XHJcbiAgICAgIGluaXRGY24obGluayk7XHJcbiAgICAgIGlmICghbGluay5jb2xvcikgbGluay5jb2xvciA9IHRoaXMucmFuZG9tQ29sb3IoKTtcclxuICAgICAgcmV0dXJuIGxpbmtcclxuICAgIH0pIC8vIFJFTUlORDogcmV0dXJuIHNpbmdsZSBsaW5rIGlmIHRvIG5vdCBhbiBhcnJheT9cclxuICB9XHJcbn1cclxuXHJcbi8vIGNsYXNzIFdvcmxkIGRlZmluZXMgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGZvciB0aGUgbW9kZWwuXHJcbi8vIEl0IHdpbGwgYmUgdXBncmFkZWQgd2l0aCBtZXRob2RzIGNvbnZlcnRpbmcgZnJvbSBvdGhlclxyXG4vLyB0cmFuc2Zvcm1zIGxpa2UgR0lTIGFuZCBEYXRhU2V0cy5cclxuXHJcbmNsYXNzIFdvcmxkIHtcclxuICBzdGF0aWMgZGVmYXVsdE9wdGlvbnMgKHNpemUgPSAxMywgbWF4ID0gMTYpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBhdGNoU2l6ZTogc2l6ZSxcclxuICAgICAgbWluWDogLW1heCxcclxuICAgICAgbWF4WDogbWF4LFxyXG4gICAgICBtaW5ZOiAtbWF4LFxyXG4gICAgICBtYXhZOiBtYXhcclxuICAgIH1cclxuICB9XHJcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgd29ybGQgdy8gZGVmYXVsdHMgb3ZlcnJpZGRlbiB3LyBvcHRpb25zLlxyXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zID0ge30pIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgV29ybGQuZGVmYXVsdE9wdGlvbnMoKSk7IC8vIGluaXRpYWwgdGhpcyB3LyBkZWZhdWx0c1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTsgLy8gb3ZlcnJpZGUgZGVmYXVsdHMgd2l0aCBvcHRpb25zXHJcbiAgICB0aGlzLnNldFdvcmxkKCk7XHJcbiAgfVxyXG4gIC8vIENvbXBsZXRlIHByb3BlcnRpZXMgZGVyaXZlZCBmcm9tIHBhdGNoU2l6ZSwgbWluWC9ZLCBtYXhYL1lcclxuICBzZXRXb3JsZCAoKSB7XHJcbiAgICB0aGlzLm51bVggPSB0aGlzLm1heFggLSB0aGlzLm1pblggKyAxO1xyXG4gICAgdGhpcy5udW1ZID0gdGhpcy5tYXhZIC0gdGhpcy5taW5ZICsgMTtcclxuICAgIHRoaXMud2lkdGggPSB0aGlzLm51bVggKiB0aGlzLnBhdGNoU2l6ZTtcclxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5udW1ZICogdGhpcy5wYXRjaFNpemU7XHJcbiAgICB0aGlzLm1pblhjb3IgPSB0aGlzLm1pblggLSAwLjU7XHJcbiAgICB0aGlzLm1heFhjb3IgPSB0aGlzLm1heFggKyAwLjU7XHJcbiAgICB0aGlzLm1pblljb3IgPSB0aGlzLm1pblkgLSAwLjU7XHJcbiAgICB0aGlzLm1heFljb3IgPSB0aGlzLm1heFkgKyAwLjU7XHJcbiAgICB0aGlzLmNlbnRlclggPSAodGhpcy5taW5YICsgdGhpcy5tYXhYKSAvIDI7XHJcbiAgICB0aGlzLmNlbnRlclkgPSAodGhpcy5taW5ZICsgdGhpcy5tYXhZKSAvIDI7XHJcbiAgfVxyXG4gIGlzT25Xb3JsZCAoeCwgeSkge1xyXG4gICAgcmV0dXJuICh0aGlzLm1pblhjb3IgPD0geCkgJiYgKHggPD0gdGhpcy5tYXhYY29yKSAmJlxyXG4gICAgICAgICAgICh0aGlzLm1pblljb3IgPD0geSkgJiYgKHkgPD0gdGhpcy5tYXhZY29yKVxyXG4gIH1cclxuICBzZXRDdHhUcmFuc2Zvcm0gKGN0eCkge1xyXG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICBjdHguY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC5zY2FsZSh0aGlzLnBhdGNoU2l6ZSwgLXRoaXMucGF0Y2hTaXplKTtcclxuICAgIGN0eC50cmFuc2xhdGUoLSh0aGlzLm1pblhjb3IpLCAtKHRoaXMubWF4WWNvcikpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUGF0Y2hlcyBhcmUgdGhlIHdvcmxkIG90aGVyIGFnZW50c2V0cyBsaXZlIG9uLiBUaGV5IGNyZWF0ZSBhIGNvb3JkIHN5c3RlbVxyXG4vLyBmcm9tIE1vZGVsJ3Mgd29ybGQgdmFsdWVzOiBzaXplLCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZXHJcbmNsYXNzIFBhdGNoZXMgZXh0ZW5kcyBBZ2VudFNldCB7XHJcbiAgY29uc3RydWN0b3IgKG1vZGVsLCBBZ2VudENsYXNzLCBuYW1lKSB7XHJcbiAgICAvLyBBZ2VudFNldCBzZXRzIHRoZXNlIHZhcmlhYmxlczpcclxuICAgIC8vIG1vZGVsLCBuYW1lLCBiYXNlU2V0LCB3b3JsZDogbW9kZWwud29ybGQsIGFnZW50UHJvdG86IG5ldyBBZ2VudENsYXNzXHJcbiAgICAvLyBSRU1JTkQ6IGFnZW50UHJvdG86IGRlZmF1bHRzLCBhZ2VudFNldCwgd29ybGQsIFtuYW1lXT1hZ2VudFNldC5iYXNlU2V0XHJcbiAgICBzdXBlcihtb2RlbCwgQWdlbnRDbGFzcywgbmFtZSk7XHJcblxyXG4gICAgLy8gU2tpcCBpZiBhIGJyZWVkU2V0IChkb24ndCByZWJ1aWxkIHBhdGNoZXMhKS5cclxuICAgIGlmICh0aGlzLmlzQnJlZWRTZXQoKSkgcmV0dXJuXHJcblxyXG4gICAgdGhpcy5wb3B1bGF0ZSgpO1xyXG4gICAgdGhpcy5zZXRQaXhlbHMoKTtcclxuICAgIHRoaXMubGFiZWxzID0gW107IC8vIHNwYXJzZSBhcnJheSBmb3IgbGFiZWxzXHJcbiAgfVxyXG4gIC8vIFNldCB1cCBhbGwgdGhlIHBhdGNoZXMuXHJcbiAgcG9wdWxhdGUgKCkge1xyXG4gICAgdXRpbC5yZXBlYXQodGhpcy5tb2RlbC53b3JsZC5udW1YICogdGhpcy5tb2RlbC53b3JsZC5udW1ZLCAoaSkgPT4ge1xyXG4gICAgICB0aGlzLmFkZEFnZW50KCk7IC8vIE9iamVjdC5jcmVhdGUodGhpcy5hZ2VudFByb3RvKSlcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyBTZXR1cCBwaXhlbHMgY3R4IHVzZWQgZm9yIHBhdGNoLmNvbG9yOiBgZHJhd2AgYW5kIGBpbXBvcnRDb2xvcnNgXHJcbiAgc2V0UGl4ZWxzICgpIHtcclxuICAgIGNvbnN0IHtudW1YLCBudW1ZfSA9IHRoaXMubW9kZWwud29ybGQ7XHJcbiAgICAvLyBjb25zdCBjdHggPSB0aGlzLm1vZGVsLmNvbnRleHRzLnBhdGNoZXNcclxuICAgIC8vIGNvbnN0IHBpeGVscyA9IHRoaXMucGl4ZWxzID0ge2FyZTF4MTogcGF0Y2hTaXplID09PSAxfVxyXG4gICAgLy8gcGl4ZWxzLmN0eCA9IHBpeGVscy5hcmUxeDEgPyBjdHggOiB1dGlsLmNyZWF0ZUN0eChudW1YLCBudW1ZKVxyXG4gICAgdGhpcy5waXhlbHMgPSB7XHJcbiAgICAgIGN0eDogdXRpbC5jcmVhdGVDdHgobnVtWCwgbnVtWSlcclxuICAgIH07XHJcbiAgICB0aGlzLnNldEltYWdlRGF0YSgpO1xyXG4gIH1cclxuICAvLyBDcmVhdGUgdGhlIHBpeGVscyBvYmplY3QgdXNlZCBieSBgc2V0UGl4ZWxzYCBhbmQgYGluc3RhbGxDb2xvcnNgXHJcbiAgc2V0SW1hZ2VEYXRhICgpIHtcclxuICAgIGNvbnN0IHBpeGVscyA9IHRoaXMucGl4ZWxzO1xyXG4gICAgcGl4ZWxzLmltYWdlRGF0YSA9IHV0aWwuY3R4SW1hZ2VEYXRhKHBpeGVscy5jdHgpO1xyXG4gICAgcGl4ZWxzLmRhdGE4ID0gcGl4ZWxzLmltYWdlRGF0YS5kYXRhO1xyXG4gICAgcGl4ZWxzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkocGl4ZWxzLmRhdGE4LmJ1ZmZlcik7XHJcbiAgfVxyXG5cclxuICBzZXREZWZhdWx0IChuYW1lLCB2YWx1ZSkge1xyXG4gICAgaWYgKG5hbWUgPT09ICdjb2xvcicpIHtcclxuICAgICAgdGhpcy5hc2socCA9PiB7IHAuc2V0Q29sb3IodmFsdWUpOyB9KTtcclxuICAgICAgdXRpbC5sb2dPbmNlKGBwYXRjaGVzLnNldERlZmF1bHQoY29sb3IsIHZhbHVlKTogY29sb3IgZGVmYXVsdCBub3Qgc3VwcG9ydGVkLiBDbGVhcmluZyB0byB2YWx1ZWApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3VwZXIuc2V0RGVmYXVsdChuYW1lLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIEdldC9TZXQgbGFiZWwuIFJFTUlORDogbm90IGltcGxlbWVudGVkLlxyXG4gIC8vIFNldCByZW1vdmVzIGxhYmVsIGlmIGxhYmVsIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gIC8vIEdldCByZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBsYWJlbC5cclxuICBzZXRMYWJlbCAocGF0Y2gsIGxhYmVsKSB7IC8vIFJFTUlORDogZG9lcyB0aGlzIHdvcmsgZm9yIGJyZWVkcz9cclxuICAgIGlmIChsYWJlbCA9PSBudWxsKSAvLyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgICBkZWxldGUgdGhpcy5sYWJlbHNbcGF0Y2guaWRdO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLmxhYmVsc1twYXRjaC5pZF0gPSBsYWJlbDtcclxuICB9XHJcbiAgZ2V0TGFiZWwgKHBhdGNoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sYWJlbHNbcGF0Y2guaWRdXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gdGhlIG9mZnNldHMgZnJvbSBhIHBhdGNoIGZvciBpdHMgOCBlbGVtZW50IG5laWdoYm9ycy5cclxuICAvLyBTcGVjaWFsaXplZCB0byBiZSBmYXN0ZXIgdGhhbiBpblJlY3QgYmVsb3cuXHJcbiAgbmVpZ2hib3JzT2Zmc2V0cyAoeCwgeSkge1xyXG4gICAgY29uc3Qge21pblgsIG1heFgsIG1pblksIG1heFksIG51bVh9ID0gdGhpcy5tb2RlbC53b3JsZDtcclxuICAgIGlmICh4ID09PSBtaW5YKSB7XHJcbiAgICAgIGlmICh5ID09PSBtaW5ZKSByZXR1cm4gWy1udW1YLCAtbnVtWCArIDEsIDFdXHJcbiAgICAgIGlmICh5ID09PSBtYXhZKSByZXR1cm4gWzEsIG51bVggKyAxLCBudW1YXVxyXG4gICAgICByZXR1cm4gWy1udW1YLCAtbnVtWCArIDEsIDEsIG51bVggKyAxLCBudW1YXVxyXG4gICAgfVxyXG4gICAgaWYgKHggPT09IG1heFgpIHtcclxuICAgICAgaWYgKHkgPT09IG1pblkpIHJldHVybiBbLW51bVggLSAxLCAtbnVtWCwgLTFdXHJcbiAgICAgIGlmICh5ID09PSBtYXhZKSByZXR1cm4gW251bVgsIG51bVggLSAxLCAtMV1cclxuICAgICAgcmV0dXJuIFstbnVtWCAtIDEsIC1udW1YLCBudW1YLCBudW1YIC0gMSwgLTFdXHJcbiAgICB9XHJcbiAgICBpZiAoeSA9PT0gbWluWSkgcmV0dXJuIFstbnVtWCAtIDEsIC1udW1YLCAtbnVtWCArIDEsIDEsIC0xXVxyXG4gICAgaWYgKHkgPT09IG1heFkpIHJldHVybiBbMSwgbnVtWCArIDEsIG51bVgsIG51bVggLSAxLCAtMV1cclxuICAgIHJldHVybiBbLW51bVggLSAxLCAtbnVtWCwgLW51bVggKyAxLCAxLCBudW1YICsgMSwgbnVtWCwgbnVtWCAtIDEsIC0xXVxyXG4gIH1cclxuICAvLyBSZXR1cm4gdGhlIG9mZnNldHMgZnJvbSBhIHBhdGNoIGZvciBpdHMgNCBlbGVtZW50IG5laWdoYm9ycyAoTixTLEUsVylcclxuICBuZWlnaGJvcnM0T2Zmc2V0cyAoeCwgeSkge1xyXG4gICAgY29uc3QgbnVtWCA9IHRoaXMubW9kZWwud29ybGQubnVtWDtcclxuICAgIHJldHVybiB0aGlzLm5laWdoYm9yc09mZnNldHMoeCwgeSlcclxuICAgICAgLmZpbHRlcigobikgPT4gTWF0aC5hYnMobikgPT09IDEgfHwgTWF0aC5hYnMobikgPT09IG51bVgpIC8vIHNsaWdodGx5IGZhc3RlclxyXG4gICAgICAvLyAuZmlsdGVyKChuKSA9PiBbMSwgLTEsIG51bVgsIC1udW1YXS5pbmRleE9mKG4pID49IDApXHJcbiAgICAgIC8vIC5maWx0ZXIoKG4pID0+IFsxLCAtMSwgbnVtWCwgLW51bVhdLmluY2x1ZGVzKG4pKSAvLyBzbG93ZXIgdGhhbiBpbmRleE9mXHJcbiAgfVxyXG4gIC8vIFJldHVybiBteSA4IHBhdGNoIG5laWdoYm9yc1xyXG4gIG5laWdoYm9ycyAocGF0Y2gpIHtcclxuICAgIGNvbnN0IHtpZCwgeCwgeX0gPSBwYXRjaDtcclxuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLm5laWdoYm9yc09mZnNldHMoeCwgeSk7XHJcbiAgICBjb25zdCBhcyA9IG5ldyBBZ2VudEFycmF5KG9mZnNldHMubGVuZ3RoKTtcclxuICAgIG9mZnNldHMuZm9yRWFjaCgobywgaSkgPT4geyBhc1tpXSA9IHRoaXNbbyArIGlkXTsgfSk7XHJcbiAgICByZXR1cm4gYXNcclxuICAgIC8vIG9mZnNldHMuZm9yRWFjaCgobywgaSwgYSkgPT4geyBhW2ldID0gdGhpc1tvICsgaWRdIH0pXHJcbiAgICAvLyByZXR1cm4gdGhpcy5hc0FnZW50U2V0KG9mZnNldHMpXHJcbiAgfVxyXG4gIC8vIFJldHVybiBteSA0IHBhdGNoIG5laWdoYm9yc1xyXG4gIG5laWdoYm9yczQgKHBhdGNoKSB7XHJcbiAgICBjb25zdCB7aWQsIHgsIHl9ID0gcGF0Y2g7XHJcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5uZWlnaGJvcnM0T2Zmc2V0cyh4LCB5KTtcclxuICAgIGNvbnN0IGFzID0gbmV3IEFnZW50QXJyYXkob2Zmc2V0cy5sZW5ndGgpO1xyXG4gICAgb2Zmc2V0cy5mb3JFYWNoKChvLCBpKSA9PiB7IGFzW2ldID0gdGhpc1tvICsgaWRdOyB9KTtcclxuICAgIHJldHVybiBhc1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIGEgcmFuZG9tIHZhbGlkIGludCB4LHkgcG9pbnQgaW4gcGF0Y2ggc3BhY2VcclxuICByYW5kb21QdCAoKSB7XHJcbiAgICAvLyBjb25zdCB7bWluWGNvciwgbWF4WGNvciwgbWluWWNvciwgbWF4WWNvcn0gPSB0aGlzLm1vZGVsLndvcmxkXHJcbiAgICAvLyByZXR1cm4gW3V0aWwucmFuZG9tRmxvYXQyKG1pblhjb3IsIG1heFhjb3IpLCB1dGlsLnJhbmRvbUZsb2F0MihtaW5ZY29yLCBtYXhZY29yKV1cclxuICAgIGNvbnN0IHttaW5YLCBtYXhYLCBtaW5ZLCBtYXhZfSA9IHRoaXMubW9kZWwud29ybGQ7XHJcbiAgICByZXR1cm4gW3V0aWwucmFuZG9tSW50MihtaW5YLCBtYXhYKSwgdXRpbC5yYW5kb21JbnQyKG1pblksIG1heFkpXVxyXG4gIH1cclxuXHJcbiAgaW5zdGFsbFBpeGVscyAoKSB7XHJcbiAgICBjb25zdCBwaXhlbHMgPSB0aGlzLnBpeGVscztcclxuICAgIHBpeGVscy5jdHgucHV0SW1hZ2VEYXRhKHBpeGVscy5pbWFnZURhdGEsIDAsIDApO1xyXG4gICAgcmV0dXJuIHBpeGVsc1xyXG4gIH1cclxuICAvLyBSRU1JTkQ6IFRocmVlIC4uIG5lZWQgcGl4ZWxzIC0+IHRleHR1cmVcclxuICAvLyBEcmF3IHRoZSBwYXRjaGVzIG9udG8gdGhlIGN0eCB1c2luZyB0aGUgcGl4ZWwgaW1hZ2UgZGF0YSBjb2xvcnMuXHJcbiAgLy8gZHJhdyAoY3R4ID0gdGhpcy5tb2RlbC5jb250ZXh0cy5wYXRjaGVzKSB7XHJcbiAgLy8gICBjb25zdCB7cGl4ZWxzfSA9IHRoaXNcclxuICAvLyAgIHBpeGVscy5jdHgucHV0SW1hZ2VEYXRhKHBpeGVscy5pbWFnZURhdGEsIDAsIDApXHJcbiAgLy8gICBpZiAoIXBpeGVscy5hcmUxeDEpXHJcbiAgLy8gICAgIHV0aWwuZmlsbEN0eFdpdGhJbWFnZShjdHgsIHBpeGVscy5jdHguY2FudmFzKVxyXG4gIC8vICAgZm9yIChjb25zdCBpIGluIHRoaXMubGFiZWxzKSB7IC8vIGBmb3IgLi4gaW5gOiBza2lwcyBzcGFyc2UgYXJyYXkgZ2Fwcy5cclxuICAvLyAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsc1tpXVxyXG4gIC8vICAgICBjb25zdCB7bGFiZWxPZmZzZXQ6IG9mZnNldCwgbGFiZWxDb2xvcjogY29sb3J9ID0gdGhpc1tpXVxyXG4gIC8vICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLnBhdGNoWFlUb1BpeGVsWFkoLi4udGhpcy5wYXRjaEluZGV4VG9YWShpKSlcclxuICAvLyAgICAgdXRpbC5jdHhEcmF3VGV4dChjdHgsIGxhYmVsLCB4ICsgb2Zmc2V0WzBdLCB5ICsgb2Zmc2V0WzFdLCBjb2xvci5nZXRDc3MoKSlcclxuICAvLyAgIH1cclxuICAvLyB9XHJcbiAgLy8gUkVNSU5EOiBObyBkcmF3aW5nIGxheWVyIHlldFxyXG4gIC8vIC8vIERyYXdzLCBvciBcImltcG9ydHNcIiBhbiBpbWFnZSBVUkwgaW50byB0aGUgZHJhd2luZyBsYXllci5cclxuICAvLyAvLyBUaGUgaW1hZ2UgaXMgc2NhbGVkIHRvIGZpdCB0aGUgZHJhd2luZyBsYXllci5cclxuICAvLyAvLyBUaGlzIGlzIGFuIGFzeW5jIGZ1bmN0aW9uLCB1c2luZyBlczYgUHJvbWlzZXMuXHJcbiAgLy8gaW1wb3J0RHJhd2luZyAoaW1hZ2VTcmMpIHtcclxuICAvLyAgIHV0aWwuaW1hZ2VQcm9taXNlKGltYWdlU3JjKVxyXG4gIC8vICAgLnRoZW4oKGltZykgPT4gdGhpcy5pbnN0YWxsRHJhd2luZyhpbWcpKVxyXG4gIC8vIH1cclxuICAvLyAvLyBEaXJlY3QgaW5zdGFsbCBpbWFnZSBpbnRvIHRoZSBnaXZlbiBjb250ZXh0LCBub3QgYXN5bmMuXHJcbiAgLy8gaW5zdGFsbERyYXdpbmcgKGltZywgY3R4ID0gdGhpcy5tb2RlbC5jb250ZXh0cy5kcmF3aW5nKSB7XHJcbiAgLy8gICB1dGlsLmZpbGxDdHhXaXRoSW1hZ2UoY3R4LCBpbWcpXHJcbiAgLy8gfVxyXG4gIGltcG9ydENvbG9ycyAoaW1hZ2VTcmMpIHtcclxuICAgIHV0aWwuaW1hZ2VQcm9taXNlKGltYWdlU3JjKVxyXG4gICAgLnRoZW4oKGltZykgPT4gdGhpcy5pbnN0YWxsQ29sb3JzKGltZykpO1xyXG4gIH1cclxuICAvLyBEaXJlY3QgaW5zdGFsbCBpbWFnZSBpbnRvIHRoZSBwYXRjaCBjb2xvcnMsIG5vdCBhc3luYy5cclxuICBpbnN0YWxsQ29sb3JzIChpbWcpIHtcclxuICAgIHV0aWwuZmlsbEN0eFdpdGhJbWFnZSh0aGlzLnBpeGVscy5jdHgsIGltZyk7XHJcbiAgICB0aGlzLnNldEltYWdlRGF0YSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gSW1wb3J0L2V4cG9ydCBEYXRhU2V0IHRvL2Zyb20gcGF0Y2ggdmFyaWFibGUgYHBhdGNoVmFyYC5cclxuICAvLyBgdXNlTmVhcmVzdGA6IHRydWUgZm9yIGZhc3Qgcm91bmRpbmcgdG8gbmVhcmVzdDsgZmFsc2UgZm9yIGJpLWxpbmVhci5cclxuICBpbXBvcnREYXRhU2V0IChkYXRhU2V0LCBwYXRjaFZhciwgdXNlTmVhcmVzdCA9IGZhbHNlKSB7XHJcbiAgICBpZiAodGhpcy5pc0JyZWVkU2V0KCkpIHsgLy8gUkVNSU5EOiBlcnJvclxyXG4gICAgICB1dGlsLndhcm4oJ1BhdGNoZXM6IGV4cG9ydERhdGFTZXQgY2FsbGVkIHdpdGggYnJlZWQsIHVzaW5nIHBhdGNoZXMnKTtcclxuICAgICAgdGhpcy5iYXNlU2V0LmltcG9ydERhdGFTZXQoZGF0YVNldCwgcGF0Y2hWYXIsIHVzZU5lYXJlc3QpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qge251bVgsIG51bVl9ID0gdGhpcy5tb2RlbC53b3JsZDtcclxuICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhU2V0LnJlc2FtcGxlKG51bVgsIG51bVksIHVzZU5lYXJlc3QpO1xyXG4gICAgdGhpcy5hc2socCA9PiB7IHBbcGF0Y2hWYXJdID0gZGF0YXNldC5kYXRhW3AuaWRdOyB9KTtcclxuICAgIC8vIGZvciAoY29uc3QgcGF0Y2ggb2YgdGhpcylcclxuICAgIC8vICAgcGF0Y2hbcGF0Y2hWYXJdID0gZGF0YXNldC5kYXRhW3BhdGNoLmlkXVxyXG4gIH1cclxuICBleHBvcnREYXRhU2V0IChwYXRjaFZhciwgVHlwZSA9IEFycmF5KSB7XHJcbiAgICBpZiAodGhpcy5pc0JyZWVkU2V0KCkpIHtcclxuICAgICAgdXRpbC53YXJuKCdQYXRjaGVzOiBleHBvcnREYXRhU2V0IGNhbGxlZCB3aXRoIGJyZWVkLCB1c2luZyBwYXRjaGVzJyk7XHJcbiAgICAgIHRoaXMuYmFzZVNldC5leHBvcnREYXRhU2V0KHBhdGNoVmFyLCBUeXBlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHtudW1YLCBudW1ZfSA9IHRoaXMubW9kZWwud29ybGQ7XHJcbiAgICAvLyBsZXQgZGF0YSA9IHV0aWwuYXJyYXlQcm9wcyh0aGlzLCBwYXRjaFZhcilcclxuICAgIGxldCBkYXRhID0gdGhpcy5wcm9wcyh0aGlzLCBwYXRjaFZhcik7XHJcbiAgICBkYXRhID0gdXRpbC5jb252ZXJ0QXJyYXkoZGF0YSwgVHlwZSk7XHJcbiAgICByZXR1cm4gbmV3IERhdGFTZXQobnVtWCwgbnVtWSwgZGF0YSlcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB0cnVlIGlmIHgseSBmbG9hdHMgYXJlIHdpdGhpbiBwYXRjaCB3b3JsZC5cclxuICAvLyBpc09uV29ybGQgKHgsIHkpIHtcclxuICAvLyAgIGNvbnN0IHttaW5YY29yLCBtYXhYY29yLCBtaW5ZY29yLCBtYXhZY29yfSA9IHRoaXMubW9kZWwud29ybGRcclxuICAvLyAgIHJldHVybiAobWluWGNvciA8PSB4KSAmJiAoeCA8PSBtYXhYY29yKSAmJiAobWluWWNvciA8PSB5KSAmJiAoeSA8PSBtYXhZY29yKVxyXG4gIC8vIH1cclxuICAvLyBSZXR1cm4gdGhlIHBhdGNoIGlkL2luZGV4IGdpdmVuIHZhbGlkIGludGVnZXIgeCx5IGluIHBhdGNoIGNvb3Jkc1xyXG4gIHBhdGNoSW5kZXggKHgsIHkpIHtcclxuICAgIGNvbnN0IHttaW5YLCBtYXhZLCBudW1YfSA9IHRoaXMubW9kZWwud29ybGQ7XHJcbiAgICByZXR1cm4gKHggLSBtaW5YKSArIChudW1YICogKG1heFkgLSB5KSlcclxuICB9XHJcbiAgLy8gcGF0Y2hYWVRvSW5kZXggKHgsIHkpIHtcclxuICAvLyAgIGNvbnN0IHttaW5YLCBtYXhZLCBudW1YfSA9IHRoaXMubW9kZWwud29ybGRcclxuICAvLyAgIHJldHVybiAoeCAtIG1pblgpICsgKG51bVggKiAobWF4WSAtIHkpKVxyXG4gIC8vIH1cclxuICAvLyAvLyBSZXR1cm4gdGhlIHBhdGNoIHgseSBwYXRjaCBjb29yZHMgZ2l2ZW4gYSB2YWxpZCBwYXRjaGVzIGlkL2luZGV4XHJcbiAgLy8gcGF0Y2hJbmRleFRvWFkgKGl4KSB7XHJcbiAgLy8gICBjb25zdCB7bWluWCwgbWF4WSwgbnVtWH0gPSB0aGlzLm1vZGVsLndvcmxkXHJcbiAgLy8gICByZXR1cm4gWyhpeCAlIG51bVgpICsgbWluWCwgbWF4WSAtIE1hdGguZmxvb3IoaXggLyBudW1YKV1cclxuICAvLyB9XHJcbiAgLy8gLy8gQ29udmVydCB0by9mcm9tIHBpeGVsIGNvb3JkcyAmIHBhdGNoIGNvb3Jkc1xyXG4gIC8vIHBpeGVsWFlUb1BhdGNoWFkgKHgsIHkpIHtcclxuICAvLyAgIGNvbnN0IHtwYXRjaFNpemUsIG1pblhjb3IsIG1heFljb3J9ID0gdGhpcy5tb2RlbC53b3JsZFxyXG4gIC8vICAgcmV0dXJuIFttaW5YY29yICsgKHggLyBwYXRjaFNpemUpLCBtYXhZY29yIC0gKHkgLyBwYXRjaFNpemUpXVxyXG4gIC8vIH1cclxuICAvLyBwYXRjaFhZVG9QaXhlbFhZICh4LCB5KSB7XHJcbiAgLy8gICBjb25zdCB7cGF0Y2hTaXplLCBtaW5YY29yLCBtYXhZY29yfSA9IHRoaXMubW9kZWwud29ybGRcclxuICAvLyAgIHJldHVybiBbKHggLSBtaW5YY29yKSAqIHBhdGNoU2l6ZSwgKG1heFljb3IgLSB5KSAqIHBhdGNoU2l6ZV1cclxuICAvLyB9XHJcblxyXG4gIC8vIFV0aWxzIGZvciBOZXRMb2dvIHBhdGNoIGxvY2F0aW9uIG1ldGhvZHMuXHJcbiAgLy8gQWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZiBub3Qgb253b3JsZC5cclxuICAvLyBOb3RlIHRoYXQgZm9vID09IG51bGwgY2hlY2tzIGZvciBib3RoIHVuZGVmaW5lZCBhbmQgbnVsbCAoPT0gdnMgPT09KVxyXG4gIC8vIGFuZCBpcyBjb25zaWRlcmVkIGFuIE9LIHByYWN0aWNlLlxyXG5cclxuICAvLyBSZXR1cm4gcGF0Y2ggYXQgeCx5IGZsb2F0IHZhbHVlcyBhY2NvcmRpbmcgdG8gdG9wb2xvZ3kuXHJcbiAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiBvZmYtd29ybGRcclxuICBwYXRjaCAoeCwgeSkge1xyXG4gICAgaWYgKCF0aGlzLm1vZGVsLndvcmxkLmlzT25Xb3JsZCh4LCB5KSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgY29uc3QgaW50WCA9IHggPT09IHRoaXMubW9kZWwud29ybGQubWF4WGNvclxyXG4gICAgICA/IHRoaXMubW9kZWwud29ybGQubWF4WCA6IE1hdGgucm91bmQoeCk7IC8vIGhhbmRsZSBuLjUgcm91bmQgdXAgdG8gbiArIDFcclxuICAgIGNvbnN0IGludFkgPSB5ID09PSB0aGlzLm1vZGVsLndvcmxkLm1heFljb3JcclxuICAgICAgPyB0aGlzLm1vZGVsLndvcmxkLm1heFkgOiBNYXRoLnJvdW5kKHkpO1xyXG4gICAgcmV0dXJuIHRoaXMucGF0Y2hYWShpbnRYLCBpbnRZKVxyXG4gIH1cclxuICAvLyBSZXR1cm4gdGhlIHBhdGNoIGF0IHgseSB3aGVyZSBib3RoIGFyZSB2YWxpZCBpbnRlZ2VyIHBhdGNoIGNvb3JkaW5hdGVzLlxyXG4gIHBhdGNoWFkgKHgsIHkpIHsgcmV0dXJuIHRoaXNbdGhpcy5wYXRjaEluZGV4KHgsIHkpXSB9XHJcblxyXG4gIC8vIFBhdGNoZXMgaW4gcmVjdGFuZ2xlIGR4LCBkeSBmcm9tIHAsIGR4LCBkeSBpbnRlZ2Vycy5cclxuICAvLyBCb3RoIGR4ICYgZHkgYXJlIGhhbGYgd2lkdGgvaGVpZ2h0IG9mIHJlY3RcclxuICBwYXRjaFJlY3QgKHAsIGR4LCBkeSA9IGR4LCBtZVRvbyA9IHRydWUpIHtcclxuICAgIC8vIFJldHVybiBjYWNoZWQgcmVjdCBpZiBvbmUgZXhpc3RzLlxyXG4gICAgLy8gaWYgKHAucFJlY3QgJiYgcC5wUmVjdC5sZW5ndGggPT09IGR4ICogZHkpIHJldHVybiBwLnBSZWN0XHJcbiAgICBpZiAocC5yZWN0Q2FjaGUpIHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNhY2hlSW5kZXgoZHgsIGR5LCBtZVRvbyk7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBwLnJlY3RDYWNoZVtpbmRleF07XHJcbiAgICAgIC8vIGNvbnN0IHJlY3QgPSBwLnJlY3RDYWNoZVt0aGlzLmNhY2hlSW5kZXgoZHgsIGR5LCBtZVRvbyldXHJcbiAgICAgIGlmIChyZWN0KSByZXR1cm4gcmVjdFxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVjdCA9IG5ldyBBZ2VudEFycmF5KCk7XHJcbiAgICBsZXQge21pblgsIG1heFgsIG1pblksIG1heFl9ID0gdGhpcy5tb2RlbC53b3JsZDtcclxuICAgIG1pblggPSBNYXRoLm1heChtaW5YLCBwLnggLSBkeCk7XHJcbiAgICBtYXhYID0gTWF0aC5taW4obWF4WCwgcC54ICsgZHgpO1xyXG4gICAgbWluWSA9IE1hdGgubWF4KG1pblksIHAueSAtIGR5KTtcclxuICAgIG1heFkgPSBNYXRoLm1pbihtYXhZLCBwLnkgKyBkeSk7XHJcbiAgICBmb3IgKGxldCB5ID0gbWluWTsgeSA8PSBtYXhZOyB5KyspIHtcclxuICAgICAgZm9yIChsZXQgeCA9IG1pblg7IHggPD0gbWF4WDsgeCsrKSB7XHJcbiAgICAgICAgY29uc3QgcG5leHQgPSB0aGlzLnBhdGNoWFkoeCwgeSk7XHJcbiAgICAgICAgaWYgKHAgIT09IHBuZXh0IHx8IG1lVG9vKSByZWN0LnB1c2gocG5leHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVjdFxyXG4gIH1cclxuXHJcbiAgLy8gUGVyZm9ybWFuY2U6IGNyZWF0ZSBhIGNhY2hlZCByZWN0IG9mIHRoaXMgc2l6ZSBpbiBzcGFyc2UgYXJyYXkuXHJcbiAgLy8gSW5kZXggb2YgY2FjaGVkIHJlY3QgaXMgZHggKiBkeSArIG1lVG9vID8gMCA6IC0xLlxyXG4gIC8vIFRoaXMgd29ya3MgZm9yIGVkZ2UgcmVjdHMgdGhhdCBhcmUgbm90IHRoYXQgZnVsbCBzaXplLlxyXG4gIC8vIHBhdGNoUmVjdCB3aWxsIHVzZSB0aGlzIGlmIG1hdGNoZXMgZHgsIGR5LCBtZVRvby5cclxuICBjYWNoZUluZGV4IChkeCwgZHkgPSBkeCwgbWVUb28gPSB0cnVlKSB7XHJcbiAgICByZXR1cm4gKDIgKiBkeCArIDEpICogKDIgKiBkeSArIDEpICsgKG1lVG9vID8gMCA6IC0xKVxyXG4gIH1cclxuICBjYWNoZVJlY3QgKGR4LCBkeSA9IGR4LCBtZVRvbyA9IHRydWUsIGNsZWFyID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNhY2hlSW5kZXgoZHgsIGR5LCBtZVRvbyk7XHJcbiAgICB0aGlzLmFzayhwID0+IHtcclxuICAgICAgaWYgKCFwLnJlY3RDYWNoZSB8fCBjbGVhcikgcC5yZWN0Q2FjaGUgPSBbXTtcclxuICAgICAgY29uc3QgcmVjdCA9IHRoaXMuaW5SZWN0KHAsIGR4LCBkeSwgbWVUb28pO1xyXG4gICAgICBwLnJlY3RDYWNoZVtpbmRleF0gPSByZWN0O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuLy8gUmV0dXJuIHBhdGNoZXMgd2l0aGluIHRoZSBwYXRjaCByZWN0LCBkZWZhdWx0IGlzIHNxdWFyZSAmIG1lVG9vXHJcbiAgLy8gaW5SZWN0IChwYXRjaCwgZHgsIGR5ID0gZHgsIG1lVG9vID0gdHJ1ZSkge1xyXG4gIC8vICAgcmV0dXJuIHRoaXMuaW5SZWN0KHBhdGNoLCBkeCwgZHksIG1lVG9vKVxyXG4gIC8vIH1cclxuICAvLyBQYXRjaGVzIGluIGNpcmNsZSByYWRpdXMgKGludGVnZXIpIGZyb20gcGF0Y2hcclxuICAvLyBpblJhZGl1cyAocGF0Y2gsIHJhZGl1cywgbWVUb28gPSB0cnVlKSB7XHJcbiAgLy8gICBjb25zdCByU3EgPSByYWRpdXMgKiByYWRpdXNcclxuICAvLyAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBZ2VudEFycmF5KClcclxuICAvLyAgIGNvbnN0IHNxRGlzdGFuY2UgPSB1dGlsLnNxRGlzdGFuY2UgLy8gMTAlIGZhc3RlclxyXG4gIC8vICAgY29uc3QgcFJlY3QgPSB0aGlzLmluUmVjdChwYXRjaCwgcmFkaXVzLCByYWRpdXMsIG1lVG9vKVxyXG4gIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwUmVjdC5sZW5ndGg7IGkrKykge1xyXG4gIC8vICAgICBjb25zdCBwID0gcFJlY3RbaV1cclxuICAvLyAgICAgaWYgKHNxRGlzdGFuY2UocGF0Y2gueCwgcGF0Y2gueSwgcC54LCBwLnkpIDw9IHJTcSkgcmVzdWx0LnB1c2gocClcclxuICAvLyAgIH1cclxuICAvLyAgIHJldHVybiByZXN1bHRcclxuICAvLyB9XHJcbiAgaW5SZWN0IChwYXRjaCwgZHgsIGR5ID0gZHgsIG1lVG9vID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgcFJlY3QgPSB0aGlzLnBhdGNoUmVjdChwYXRjaCwgZHgsIGR5LCBtZVRvbyk7XHJcbiAgICBpZiAodGhpcy5pc0Jhc2VTZXQoKSkgcmV0dXJuIHBSZWN0XHJcbiAgICByZXR1cm4gcFJlY3Qud2l0aEJyZWVkKHRoaXMpXHJcbiAgfVxyXG4gIGluUmFkaXVzIChwYXRjaCwgcmFkaXVzLCBtZVRvbyA9IHRydWUpIHtcclxuICAgIGNvbnN0IHBSZWN0ID0gdGhpcy5pblJlY3QocGF0Y2gsIHJhZGl1cywgcmFkaXVzLCBtZVRvbyk7XHJcbiAgICByZXR1cm4gcFJlY3QuaW5SYWRpdXMocGF0Y2gsIHJhZGl1cywgbWVUb28pXHJcbiAgfVxyXG4gIC8vIFBhdGNoZXMgaW4gY29uZSBmcm9tIHAgaW4gZGlyZWN0aW9uIGBhbmdsZWAsIHdpdGggYGNvbmVBbmdsZWAgYW5kIGByYWRpdXNgXHJcbiAgaW5Db25lIChwYXRjaCwgcmFkaXVzLCBjb25lQW5nbGUsIGRpcmVjdGlvbiwgbWVUb28gPSB0cnVlKSB7XHJcbiAgICBjb25zdCBwUmVjdCA9IHRoaXMuaW5SZWN0KHBhdGNoLCByYWRpdXMsIHJhZGl1cywgbWVUb28pO1xyXG4gICAgcmV0dXJuIHBSZWN0LmluQ29uZShwYXRjaCwgcmFkaXVzLCBjb25lQW5nbGUsIGRpcmVjdGlvbiwgbWVUb28pXHJcblxyXG4gICAgLy8gY29uc3QgcmVzdWx0ID0gbmV3IEFnZW50QXJyYXkoKVxyXG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBwUmVjdC5sZW5ndGg7IGkrKykge1xyXG4gICAgLy8gICBjb25zdCBwID0gcFJlY3RbaV1cclxuICAgIC8vICAgY29uc3QgaXNJbiA9IHV0aWwuaW5Db25lKHAueCwgcC55LCByYWRpdXMsIGNvbmVBbmdsZSwgZGlyZWN0aW9uLCBwYXRjaC54LCBwYXRjaC55KVxyXG4gICAgLy8gICBpZiAoaXNJbiAmJiAocGF0Y2ggIT09IHAgfHwgbWVUb28pKSByZXN1bHQucHVzaChwKVxyXG4gICAgLy8gfVxyXG4gICAgLy8gcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIHBhdGNoIGF0IGRpc3RhbmNlIGFuZCBhbmdsZSBmcm9tIG9iaidzIChwYXRjaCBvciB0dXJ0bGUpXHJcbiAgLy8geCwgeSAoZmxvYXRzKS4gSWYgb2ZmIHdvcmxkLCByZXR1cm4gdW5kZWZpbmVkLlxyXG4gIC8vIFRvIHVzZSBoZWFkaW5nOiBwYXRjaEF0RGlyZWN0aW9uQW5kRGlzdGFuY2Uob2JqLCB1dGlsLmFuZ2xlKGhlYWRpbmcpLCBkaXN0YW5jZSlcclxuICAvLyBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGUgYW5nbGUgb2YgdGhlIG9iaiAuLiB0dXJ0bGUudGhldGEgZm9yIGV4YW1wbGUuXHJcbiAgcGF0Y2hBdERpcmVjdGlvbkFuZERpc3RhbmNlIChvYmosIGFuZ2xlLCBkaXN0YW5jZSkge1xyXG4gICAgbGV0IHt4LCB5fSA9IG9iajtcclxuICAgIHggPSB4ICsgZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICB5ID0geSArIGRpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgcmV0dXJuIHRoaXMucGF0Y2goeCwgeSlcclxuICB9XHJcbiAgLy8gcGF0Y2hMZWZ0QW5kQWhlYWQgKGRUaGV0YSwgZGlzdGFuY2UpIHtcclxuICAvLyAgIHJldHVybiB0aGlzLnBhdGNoQXREaXJlY3Rpb25BbmREaXN0YW5jZShkVGhldGEsIGRpc3RhbmNlKVxyXG4gIC8vIH1cclxuICAvLyBwYXRjaFJpZ2h0QW5kQWhlYWQgKGRUaGV0YSwgZGlzdGFuY2UpIHtcclxuICAvLyAgIHJldHVybiB0aGlzLnBhdGNoQXREaXJlY3Rpb25BbmREaXN0YW5jZSgtZFRoZXRhLCBkaXN0YW5jZSlcclxuICAvLyB9XHJcblxyXG4gIC8vIERpZmZ1c2UgdGhlIHZhbHVlIG9mIHBhdGNoIHZhcmlhYmxlIGBwLnZgIGJ5IGRpc3RyaWJ1dGluZyBgcmF0ZWAgcGVyY2VudFxyXG4gIC8vIG9mIGVhY2ggcGF0Y2gncyB2YWx1ZSBvZiBgdmAgdG8gaXRzIG5laWdoYm9ycy5cclxuICAvLyBJZiBhIGNvbG9yIG1hcCBpcyBnaXZlbiwgc2NhbGUgdGhlIHBhdGNoIGNvbG9yIHZpYSB2YXJpYWJsZSdzIHZhbHVlXHJcbiAgLy8gSWYgdGhlIHBhdGNoIGhhcyBsZXNzIHRoYW4gNC84IG5laWdoYm9ycywgcmV0dXJuIHRoZSBleHRyYSB0byB0aGUgcGF0Y2guXHJcbiAgZGlmZnVzZSAodiwgcmF0ZSwgY29sb3JNYXAgPSBudWxsLCBtaW4gPSAwLCBtYXggPSAxKSB7XHJcbiAgICB0aGlzLmRpZmZ1c2VOKDgsIHYsIHJhdGUsIGNvbG9yTWFwLCBtaW4sIG1heCk7XHJcbiAgfVxyXG4gIGRpZmZ1c2U0ICh2LCByYXRlLCBjb2xvck1hcCA9IG51bGwsIG1pbiA9IDAsIG1heCA9IDEpIHtcclxuICAgIHRoaXMuZGlmZnVzZU4oNCwgdiwgcmF0ZSwgY29sb3JNYXAsIG1pbiwgbWF4KTtcclxuICB9XHJcbiAgZGlmZnVzZU4gKG4sIHYsIHJhdGUsIGNvbG9yTWFwID0gbnVsbCwgbWluID0gMCwgbWF4ID0gMSkge1xyXG4gICAgLy8gTm90ZTogZm9yLW9mIGxvb3BzIHJlbW92ZWQ6IGNocm9tZSBjYW4ndCBvcHRpbWl6ZSB0aGVtXHJcbiAgICAvLyB0ZXN0L2FwcHMvcGF0Y2hlcy5qcyAyMmZwcyAtPiA2MGZwc1xyXG4gICAgLy8gemVybyB0ZW1wIHZhcmlhYmxlIGlmIG5vdCB5ZXQgc2V0XHJcbiAgICBpZiAodGhpc1swXS5fZGlmZnVzZU5leHQgPT09IHVuZGVmaW5lZClcclxuICAgICAgLy8gZm9yIChjb25zdCBwIG9mIHRoaXMpIHAuX2RpZmZ1c2VOZXh0ID0gMFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHRoaXNbaV0uX2RpZmZ1c2VOZXh0ID0gMDtcclxuXHJcbiAgICAvLyBwYXNzIDE6IGNhbGN1bGF0ZSBjb250cmlidXRpb24gb2YgYWxsIHBhdGNoZXMgdG8gdGhlbXNlbHZlcyBhbmQgbmVpZ2hib3JzXHJcbiAgICAvLyBmb3IgKGNvbnN0IHAgb2YgdGhpcykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHAgPSB0aGlzW2ldO1xyXG4gICAgICBjb25zdCBkdiA9IHBbdl0gKiByYXRlO1xyXG4gICAgICBjb25zdCBkdm4gPSBkdiAvIG47XHJcbiAgICAgIGNvbnN0IG5laWdoYm9ycyA9IChuID09PSA4KSA/IHAubmVpZ2hib3JzIDogcC5uZWlnaGJvcnM0O1xyXG4gICAgICBjb25zdCBubiA9IG5laWdoYm9ycy5sZW5ndGg7XHJcbiAgICAgIHAuX2RpZmZ1c2VOZXh0ICs9IHBbdl0gLSBkdiArIChuIC0gbm4pICogZHZuO1xyXG4gICAgICAvLyBmb3IgKGNvbnN0IG4gb2YgbmVpZ2hib3JzKSBuLl9kaWZmdXNlTmV4dCArPSBkdm5cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIG5laWdoYm9yc1tpXS5fZGlmZnVzZU5leHQgKz0gZHZuO1xyXG4gICAgfVxyXG4gICAgLy8gcGFzcyAyOiBzZXQgbmV3IHZhbHVlIGZvciBhbGwgcGF0Y2hlcywgemVybyB0ZW1wLFxyXG4gICAgLy8gbW9kaWZ5IGNvbG9yIGlmIGNvbG9yTWFwIGdpdmVuXHJcbiAgICAvLyBmb3IgKGNvbnN0IHAgb2YgdGhpcykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHAgPSB0aGlzW2ldO1xyXG4gICAgICBwW3ZdID0gcC5fZGlmZnVzZU5leHQ7XHJcbiAgICAgIHAuX2RpZmZ1c2VOZXh0ID0gMDtcclxuICAgICAgaWYgKGNvbG9yTWFwKVxyXG4gICAgICAgIHAuc2V0Q29sb3IoY29sb3JNYXAuc2NhbGVDb2xvcihwW3ZdLCBtaW4sIG1heCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ2xhc3MgUGF0Y2ggaW5zdGFuY2VzIHJlcHJlc2VudCBhIHJlY3RhbmdsZSBvbiBhIGdyaWQuICBUaGV5IGhvbGQgdmFyaWFibGVzXHJcbi8vIHRoYXQgYXJlIGluIHRoZSBwYXRjaGVzIHRoZSB0dXJ0bGVzIGxpdmUgb24uICBUaGUgc2V0IG9mIGFsbCBwYXRjaGVzXHJcbi8vIGlzIHRoZSB3b3JsZCBvbiB3aGljaCB0aGUgdHVydGxlcyBsaXZlIGFuZCB0aGUgbW9kZWwgcnVucy5cclxuXHJcbi8vIEZseXdlaWdodCBvYmplY3QgY3JlYXRpb246XHJcbi8vIE9iamVjdHMgd2l0aGluIEFnZW50U2V0cyB1c2UgXCJwcm90b3R5cGFsIGluaGVyaXRhbmNlXCIgdmlhIE9iamVjdC5jcmVhdGUoKS5cclxuLy8gSGVyZSwgdGhlIFBhdGNoIGNsYXNzIGlzIGdpdmVuIHRvIFBhdGNoZXMgZm9yIHVzZSBjcmVhdGluZyBQcm90byBvYmplY3RzXHJcbi8vIChuZXcgUGF0Y2goYWdlbnRTZXQpKSwgYnV0IG9ubHkgb25jZSBwZXIgbW9kZWwvYnJlZWQuXHJcbi8vIFRoZSBmbHl3ZWlnaHQgUGF0Y2ggb2JqZWN0cyBhcmUgY3JlYXRlZCB2aWEgT2JqZWN0LmNyZWF0ZShwcm90b09iamVjdCksXHJcbi8vIFRoaXMgbGV0cyB0aGUgbmV3IFBhdGNoKGFnZW50c2V0KSBvYmhlY3QgYmUgXCJkZWZhdWx0c1wiLlxyXG5jbGFzcyBQYXRjaCB7XHJcbiAgc3RhdGljIGRlZmF1bHRWYXJpYWJsZXMgKCkgeyAvLyBDb3JlIHZhcmlhYmxlcyBmb3IgcGF0Y2hlcy4gTm90ICdvd24nIHZhcmlhYmxlcy5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vIGlkOiBudWxsLCAgICAgICAgICAgICAvLyB1bmlxdWUgaWQsIHByb21vdGVkIGJ5IGFnZW50c2V0J3MgYWRkKCkgbWV0aG9kXHJcbiAgICAgIC8vIGFnZW50U2V0OiBudWxsLCAgICAgICAvLyBteSBhZ2VudHNldC9icmVlZFxyXG4gICAgICAvLyBtb2RlbDogbnVsbCwgICAgICAgICAgLy8gbXkgbW9kZWxcclxuICAgICAgLy8gcGF0Y2hlczogbnVsbCwgICAgICAgIC8vIG15IHBhdGNoZXMvYmFzZVNldCwgc2V0IGJ5IGN0b3JcclxuXHJcbiAgICAgIHR1cnRsZXM6IHVuZGVmaW5lZCwgICAgICAvLyB0aGUgdHVydGxlcyBvbiBtZS4gTGF4eSBldmFsdWVkLCBzZWUgdHVydGxlc0hlcmUgYmVsb3dcclxuICAgICAgbGFiZWxPZmZzZXQ6IFswLCAwXSwgIC8vIHRleHQgcGl4ZWwgb2Zmc2V0IGZyb20gdGhlIHBhdGNoIGNlbnRlclxyXG4gICAgICBsYWJlbENvbG9yOiBDb2xvci5jb2xvcigwLCAwLCAwKSAvLyB0aGUgbGFiZWwgY29sb3JcclxuICAgICAgLy8gR2V0dGVyIHZhcmlhYmxlczogbGFiZWwsIGNvbG9yLCB4LCB5LCBuZWlnaGJvcnMsIG5laWdoYm9yczRcclxuICAgIH1cclxuICB9XHJcbiAgLy8gSW5pdGlhbGl6ZSBhIFBhdGNoIGdpdmVuIGl0cyBQYXRjaGVzIEFnZW50U2V0LlxyXG4gIGNvbnN0cnVjdG9yICgpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgUGF0Y2guZGVmYXVsdFZhcmlhYmxlcygpKTtcclxuICB9XHJcbiAgLy8gR2V0dGVyIGZvciB4LHkgZGVyaXZlZCBmcm9tIHBhdGNoIGlkLCB0aHVzIG5vIHNldHRlci5cclxuICBnZXQgeCAoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMuaWQgJSB0aGlzLm1vZGVsLndvcmxkLm51bVgpICsgdGhpcy5tb2RlbC53b3JsZC5taW5YXHJcbiAgfVxyXG4gIGdldCB5ICgpIHtcclxuICAgIHJldHVybiB0aGlzLm1vZGVsLndvcmxkLm1heFkgLSBNYXRoLmZsb29yKHRoaXMuaWQgLyB0aGlzLm1vZGVsLndvcmxkLm51bVgpXHJcbiAgfVxyXG4gIGlzT25FZGdlICgpIHtcclxuICAgIGNvbnN0IHt4LCB5LCBtb2RlbH0gPSB0aGlzO1xyXG4gICAgY29uc3Qge21pblgsIG1heFgsIG1pblksIG1heFl9ID0gbW9kZWwud29ybGQ7XHJcbiAgICByZXR1cm4geCA9PT0gbWluWCB8fCB4ID09PSBtYXhYIHx8IHkgPT09IG1pblkgfHwgeSA9PT0gbWF4WVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0dGVyIGZvciBuZWlnaGJvcnMgb2YgdGhpcyBwYXRjaC5cclxuICAvLyBVc2VzIGxhenkgZXZhbHVhdGlvbiB0byBwcm9tb3RlIG5laWdoYm9ycyB0byBpbnN0YW5jZSB2YXJpYWJsZXMuXHJcbiAgLy8gVG8gYXZvaWQgcHJvbW90aW9uLCB1c2UgYHBhdGNoZXMubmVpZ2hib3JzKHRoaXMpYC5cclxuICAvLyBQcm9tb3Rpb24gbWFrZXMgZ2V0dGVycyBhY2Nlc3NlZCBvbmx5IG9uY2UuXHJcbiAgLy8gZGVmaW5lUHJvcGVydHkgcmVxdWlyZWQ6IGNhbid0IHNldCB0aGlzLm5laWdoYm9ycyB3aGVuIGdldHRlciBkZWZpbmVkLlxyXG4gIGdldCBuZWlnaGJvcnMgKCkgeyAvLyBsYXp5IHByb21vdGUgbmVpZ2hib3JzIGZyb20gZ2V0dGVyIHRvIGluc3RhbmNlIHByb3AuXHJcbiAgICBjb25zdCBuID0gdGhpcy5wYXRjaGVzLm5laWdoYm9ycyh0aGlzKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmVpZ2hib3JzJywge3ZhbHVlOiBuLCBlbnVtZXJhYmxlOiB0cnVlfSk7XHJcbiAgICByZXR1cm4gblxyXG4gIH1cclxuICBnZXQgbmVpZ2hib3JzNCAoKSB7XHJcbiAgICBjb25zdCBuID0gdGhpcy5wYXRjaGVzLm5laWdoYm9yczQodGhpcyk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25laWdoYm9yczQnLCB7dmFsdWU6IG4sIGVudW1lcmFibGU6IHRydWV9KTtcclxuICAgIHJldHVybiBuXHJcbiAgfVxyXG4gIC8vIFNpbWlsYXIgZm9yIGNhY2hpbmcgdHVydGxlcyBoZXJlXHJcbiAgLy8gZ2V0IHR1cnRsZXMgKCkge1xyXG4gIC8vICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0dXJ0bGVzJywge3ZhbHVlOiBbXSwgZW51bWVyYWJsZTogdHJ1ZX0pXHJcbiAgLy8gICByZXR1cm4gdGhpcy50dXJ0bGVzXHJcbiAgLy8gfVxyXG5cclxuICAvLyBNYW5hZ2UgY29sb3JzIGJ5IGRpcmVjdGx5IHNldHRpbmcgcGl4ZWxzIGluIFBhdGNoZXMgcGl4ZWxzIG9iamVjdC5cclxuICAvLyBXaXRoIGdldHRlci9zZXR0ZXJzLCBzbGlnaHQgcGVyZm9ybWFuY2UgaGl0IGJ1dCB3b3J0aCBpdCFcclxuICBzZXRDb2xvciAoY29sb3IpIHtcclxuICAgIHRoaXMucGF0Y2hlcy5waXhlbHMuZGF0YVt0aGlzLmlkXSA9IENvbG9yLnRvQ29sb3IoY29sb3IpLmdldFBpeGVsKCk7XHJcbiAgfVxyXG4gIC8vIE9wdGltaXphdGlvbjogSWYgc2hhcmVkIGNvbG9yIHByb3ZpZGVkLCBzaGFyZWRDb2xvciBpcyBtb2RpZmllZCBhbmRcclxuICAvLyByZXR1cm5lZC4gT3RoZXJ3aXNlIG5ldyBjb2xvciByZXR1cm5lZC5cclxuICBnZXRDb2xvciAoc2hhcmVkQ29sb3IgPSBudWxsKSB7XHJcbiAgICBjb25zdCBwaXhlbCA9IHRoaXMucGF0Y2hlcy5waXhlbHMuZGF0YVt0aGlzLmlkXTtcclxuICAgIGlmIChzaGFyZWRDb2xvcikge1xyXG4gICAgICBzaGFyZWRDb2xvci5waXhlbCA9IHBpeGVsO1xyXG4gICAgICByZXR1cm4gc2hhcmVkQ29sb3JcclxuICAgIH1cclxuICAgIHJldHVybiBDb2xvci50b0NvbG9yKHBpeGVsKVxyXG4gIH1cclxuICBnZXQgY29sb3IgKCkgeyByZXR1cm4gdGhpcy5nZXRDb2xvcigpIH1cclxuICBzZXQgY29sb3IgKGNvbG9yKSB7IHRoaXMuc2V0Q29sb3IoY29sb3IpOyB9XHJcblxyXG4gIC8vIFNldCBsYWJlbC4gRXJhc2UgbGFiZWwgdmlhIHNldHRpbmcgdG8gdW5kZWZpbmVkLlxyXG4gIHNldExhYmVsIChsYWJlbCkge1xyXG4gICAgdGhpcy5wYXRjaGVzLnNldExhYmVsKHRoaXMsIGxhYmVsKTtcclxuICB9XHJcbiAgZ2V0TGFiZWwgKCkge1xyXG4gICAgdGhpcy5wYXRjaGVzLmdldExhYmVsKHRoaXMpO1xyXG4gIH1cclxuICBnZXQgbGFiZWwgKCkgeyByZXR1cm4gdGhpcy5nZXRMYWJlbCgpIH1cclxuICBzZXQgbGFiZWwgKGxhYmVsKSB7IHJldHVybiB0aGlzLnNldExhYmVsKGxhYmVsKSB9XHJcblxyXG4gIC8vIFByb21vdGUgdGhpcy50dXJ0bGVzIG9uIGZpcnN0IGNhbGwgdG8gdHVydGxlc0hlcmUuXHJcbiAgdHVydGxlc0hlcmUgKCkge1xyXG4gICAgaWYgKHRoaXMudHVydGxlcyA9PSBudWxsKSB7XHJcbiAgICAgIC8vIHRoaXMucGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4geyBwYXRjaC50dXJ0bGVzID0gW10gfSlcclxuICAgICAgLy8gdGhpcy5tb2RlbC50dXJ0bGVzLmZvckVhY2goKHR1cnRsZSkgPT4ge1xyXG4gICAgICAvLyAgIHR1cnRsZS5wYXRjaC50dXJ0bGVzLnB1c2godGhpcylcclxuICAgICAgLy8gfSlcclxuICAgICAgdGhpcy5wYXRjaGVzLmFzayhwID0+IHsgcC50dXJ0bGVzID0gW107IH0pO1xyXG4gICAgICB0aGlzLm1vZGVsLnR1cnRsZXMuYXNrKHQgPT4geyB0LnBhdGNoLnR1cnRsZXMucHVzaCh0KTsgfSk7XHJcblxyXG4gICAgICAvLyBmb3IgKGNvbnN0IHBhdGNoIG9mIHRoaXMucGF0Y2hlcylcclxuICAgICAgLy8gICBwYXRjaC50dXJ0bGVzID0gW11cclxuICAgICAgLy8gZm9yIChjb25zdCB0dXJ0bGUgb2YgdGhpcy5tb2RlbC50dXJ0bGVzKVxyXG4gICAgICAvLyAgIHR1cnRsZS5wYXRjaC50dXJ0bGVzLnB1c2godHVydGxlKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudHVydGxlc1xyXG4gIH1cclxuICAvLyBSZXR1cm5zIGFib3ZlIGJ1dCByZXR1cm5pbmcgb25seSB0dXJ0bGVzIG9mIHRoaXMgYnJlZWQuXHJcbiAgYnJlZWRzSGVyZSAoYnJlZWQpIHtcclxuICAgIGNvbnN0IHR1cnRsZXMgPSB0aGlzLnR1cnRsZXNIZXJlKCk7XHJcbiAgICByZXR1cm4gdHVydGxlcy53aXRoQnJlZWQoYnJlZWQpXHJcbiAgICAvLyByZXR1cm4gdHVydGxlcy5maWx0ZXIoKHR1cnRsZSkgPT4gdHVydGxlLmFnZW50U2V0ID09PSBicmVlZClcclxuICB9XHJcblxyXG4gIC8vIDYgbWV0aG9kcyBpbiBib3RoIFBhdGNoICYgVHVydGxlIG1vZHVsZXNcclxuICAvLyBEaXN0YW5jZSBmcm9tIG1lIHRvIHgsIHkuIFJFTUlORDogTm8gb2ZmLXdvcmxkIHRlc3QgZG9uZVxyXG4gIGRpc3RhbmNlWFkgKHgsIHkpIHsgcmV0dXJuIHV0aWwuZGlzdGFuY2UodGhpcy54LCB0aGlzLnksIHgsIHkpIH1cclxuICAvLyBSZXR1cm4gZGlzdGFuY2UgZnJvbSBtZSB0byBvYmplY3QgaGF2aW5nIGFuIHgseSBwYWlyICh0dXJ0bGUsIHBhdGNoLCAuLi4pXHJcbiAgZGlzdGFuY2UgKGFnZW50KSB7IHJldHVybiB0aGlzLmRpc3RhbmNlWFkoYWdlbnQueCwgYWdlbnQueSkgfVxyXG4gIC8vIFJldHVybiBhbmdsZSB0b3dhcmRzIGFnZW50L3gseVxyXG4gIC8vIFVzZSB1dGlsLmhlYWRpbmcgdG8gY29udmVydCB0byBoZWFkaW5nXHJcbiAgdG93YXJkcyAoYWdlbnQpIHsgcmV0dXJuIHRoaXMudG93YXJkc1hZKGFnZW50LngsIGFnZW50LnkpIH1cclxuICB0b3dhcmRzWFkgKHgsIHkpIHsgcmV0dXJuIHV0aWwucmFkaWFuc1Rvd2FyZCh0aGlzLngsIHRoaXMueSwgeCwgeSkgfVxyXG4gIC8vIFJldHVybiBwYXRjaCB3LyBnaXZlbiBwYXJhbWV0ZXJzLiBSZXR1cm4gdW5kZWZpbmVkIGlmIG9mZi13b3JsZC5cclxuICAvLyBSZXR1cm4gcGF0Y2ggZHgsIGR5IGZyb20gbXkgcG9zaXRpb24uXHJcbiAgcGF0Y2hBdCAoZHgsIGR5KSB7IHJldHVybiB0aGlzLnBhdGNoZXMucGF0Y2godGhpcy54ICsgZHgsIHRoaXMueSArIGR5KSB9XHJcbiAgcGF0Y2hBdERpcmVjdGlvbkFuZERpc3RhbmNlIChkaXJlY3Rpb24sIGRpc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXRjaGVzLnBhdGNoQXREaXJlY3Rpb25BbmREaXN0YW5jZSh0aGlzLCBkaXJlY3Rpb24sIGRpc3RhbmNlKVxyXG4gIH1cclxuXHJcbiAgLy8gVXNlIHRoZSBhZ2VudHNldCB2ZXJzaW9ucyBzbyB0aGF0IGJyZWVkcyBjYW4gY29uc2lkZXJlZC5cclxuICAvLyBPdGhlcndpc2Ugd2UnZCBoYXZlIHRvIHVzZSB0aGUgcGF0Y2ggYnJlZWQganVzdCB0byBiZSBjb25zaXN0YW50LlxyXG4gIC8vIGluUmVjdCAocGF0Y2gsIGR4LCBkeSA9IGR4LCBtZVRvbyA9IHRydWUpIHtcclxuICAvLyAgIHJldHVybiB0aGlzLnBhdGNoZXMuaW5SZWN0KHRoaXMsIGR4LCBkeSwgbWVUb28pXHJcbiAgLy8gfVxyXG4gIC8vIGluUmFkaXVzIChyYWRpdXMsIG1lVG9vID0gdHJ1ZSkgeyAvLyByYWRpdXMgaXMgaW50ZWdlclxyXG4gIC8vICAgcmV0dXJuIHRoaXMucGF0Y2hlcy5pblJhZGl1cyh0aGlzLCByYWRpdXMsIG1lVG9vKVxyXG4gIC8vIH1cclxuICAvLyBpbkNvbmUgKHJhZGl1cywgY29uZUFuZ2xlLCBkaXJlY3Rpb24sIG1lVG9vID0gdHJ1ZSkge1xyXG4gIC8vICAgcmV0dXJuIHRoaXMucGF0Y2hlcy5pblJhZGl1cyh0aGlzLCByYWRpdXMsIGNvbmVBbmdsZSwgZGlyZWN0aW9uLCBtZVRvbylcclxuICAvLyB9XHJcblxyXG4gIC8vIEJyZWVkIGdldC9zZXQgbWF0aG9kcyBhbmQgZ2V0dGVyL3NldHRlciB2ZXJzaW9ucy5cclxuICAvLyBzZXRCcmVlZCAoYnJlZWQpIHsgYnJlZWQuc2V0QnJlZWQodGhpcykgfVxyXG4gIC8vIGdldCBicmVlZCAoKSB7IHJldHVybiB0aGlzLmFnZW50U2V0IH1cclxuICAvLyBpc0JyZWVkIChuYW1lKSB7IHJldHVybiB0aGlzLmFnZW50U2V0Lm5hbWUgPT09IG5hbWUgfVxyXG5cclxuICBzcHJvdXQgKG51bSA9IDEsIGJyZWVkID0gdGhpcy5tb2RlbC50dXJ0bGVzLCBpbml0RmNuID0gKHR1cnRsZSkgPT4ge30pIHtcclxuICAgIHJldHVybiBicmVlZC5jcmVhdGUobnVtLCAodHVydGxlKSA9PiB7XHJcbiAgICAgIHR1cnRsZS5zZXR4eSh0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgIGluaXRGY24odHVydGxlKTtcclxuICAgIH0pXHJcbiAgfVxyXG59XHJcblxyXG4vLyBUdXJ0bGVzIGFyZSB0aGUgd29ybGQgb3RoZXIgYWdlbnRzZXRzIGxpdmUgb24uIFRoZXkgY3JlYXRlIGEgY29vcmQgc3lzdGVtXHJcbi8vIGZyb20gTW9kZWwncyB3b3JsZCB2YWx1ZXM6IHNpemUsIG1pblgsIG1heFgsIG1pblksIG1heFlcclxuY2xhc3MgVHVydGxlcyBleHRlbmRzIEFnZW50U2V0IHtcclxuICAvLyBjb25zdHJ1Y3RvciAobW9kZWwsIEFnZW50Q2xhc3MsIG5hbWUpIHtcclxuICAvLyAgIC8vIC8vIEFnZW50U2V0IHNldHMgdGhlc2UgdmFyaWFibGVzOlxyXG4gIC8vICAgLy8gLy8gbW9kZWwsIG5hbWUsIGJhc2VTZXQsIHdvcmxkOiBtb2RlbC53b3JsZCAmIGFnZW50UHJvdG86IG5ldyBBZ2VudENsYXNzXHJcbiAgLy8gICBzdXBlcihtb2RlbCwgQWdlbnRDbGFzcywgbmFtZSlcclxuICAvLyAgIC8vIC8vIFNraXAgaWYgYW4gYmFzaWMgQXJyYXkgY3RvciBvciBhIGJyZWVkU2V0LiBTZWUgQWdlbnRTZXQgY29tbWVudHMuXHJcbiAgLy8gICAvL1xyXG4gIC8vICAgLy8gLy8gaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ251bWJlcicgfHwgdGhpcy5pc0JyZWVkU2V0KCkpIHJldHVyblxyXG4gIC8vICAgLy9cclxuICAvLyAgIC8vIC8vIHRoaXMubW9kZWwud29ybGQgPSBtb2RlbC53b3JsZFxyXG4gIC8vICAgLy8gLy8gdGhpcy5sYWJlbHMgPSBbXSAvLyBzcGFyc2UgYXJyYXkgZm9yIGxhYmVsc1xyXG4gIC8vICAgLy8gLy8gdGhpcy5zcHJpdGVTaGVldCA9IG5ldyBTcHJpdGVTaGVldCgpXHJcbiAgLy8gICAvLyAvLyB0aGlzLmNvbG9yTWFwID0gQ29sb3JNYXAuQmFzaWMxNlxyXG4gIC8vIH1cclxuICBjcmVhdGUgKG51bSA9IDEsIGluaXRGY24gPSAodHVydGxlKSA9PiB7fSkge1xyXG4gICAgcmV0dXJuIHV0aWwucmVwZWF0KG51bSwgKGksIGEpID0+IHtcclxuICAgICAgY29uc3QgdHVydGxlID0gdGhpcy5hZGRBZ2VudCgpO1xyXG4gICAgICB0dXJ0bGUudGhldGEgPSB1dGlsLnJhbmRvbUZsb2F0KE1hdGguUEkgKiAyKTtcclxuICAgICAgaWYgKHRoaXMucmVuZGVyZXIudXNlU3ByaXRlcykgLy8gZmFrZSBzcHJpdGUgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgdHVydGxlLnNwcml0ZSA9XHJcbiAgICAgICAgICB7c2hhcGU6IHR1cnRsZS5zaGFwZUZjbiwgY29sb3I6IHRoaXMucmFuZG9tQ29sb3IoKSwgbmVlZHNVcGRhdGU6IHRydWV9O1xyXG4gICAgICBpbml0RmNuKHR1cnRsZSk7XHJcbiAgICAgIGEucHVzaCh0dXJ0bGUpO1xyXG4gICAgfSlcclxuICB9XHJcbiAgLy8gY2xlYXIgKCkge1xyXG4gIC8vICAgd2hpbGUgKHRoaXMuYW55KCkpIHRoaXMubGFzdC5kaWUoKSAvLyBkaWUgYSB0dXJ0bGUgbWV0aG9kXHJcbiAgLy8gfVxyXG5cclxuICAvLyBSZXR1cm4gYSByYW5kb20gdmFsaWQgZmxvYXQgeCx5IHBvaW50IGluIHR1cnRsZSBjb29yZCBzcGFjZS5cclxuICByYW5kb21QdCAoKSB7XHJcbiAgICBjb25zdCB7bWluWGNvciwgbWF4WGNvciwgbWluWWNvciwgbWF4WWNvcn0gPSB0aGlzLm1vZGVsLndvcmxkO1xyXG4gICAgcmV0dXJuIFt1dGlsLnJhbmRvbUZsb2F0MihtaW5YY29yLCBtYXhYY29yKSwgdXRpbC5yYW5kb21GbG9hdDIobWluWWNvciwgbWF4WWNvcildXHJcbiAgICAvLyBjb25zdCB7bWluWCwgbWF4WCwgbWluWSwgbWF4WX0gPSB0aGlzLm1vZGVsLndvcmxkXHJcbiAgICAvLyByZXR1cm4gW3V0aWwucmFuZG9tSW50MihtaW5YLCBtYXhYKSwgdXRpbC5yYW5kb21JbnQyKG1pblksIG1heFkpXVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoaXMgYnJlZWQgd2l0aGluIHRoZSBhcnJheSBvZiBwYXRjaHNcclxuICBpblBhdGNoZXMgKHBhdGNoZXMpIHtcclxuICAgIGxldCBhcnJheSA9IG5ldyBBZ2VudEFycmF5KCk7IC8vIFtdXHJcbiAgICBmb3IgKGNvbnN0IHAgb2YgcGF0Y2hlcykgYXJyYXkucHVzaCguLi5wLnR1cnRsZXNIZXJlKCkpO1xyXG4gICAgLy8gUkVNSU5EOiBjYW4ndCB1c2Ugd2l0aEJyZWVkIC4uIGl0cyBub3QgYW4gQWdlbnRTZXQuIE1vdmUgdG8gQWdlbnRBcnJheVxyXG4gICAgaWYgKHRoaXMuaXNCcmVlZFNldCgpKSBhcnJheSA9IGFycmF5LmZpbHRlcigoYSkgPT4gYS5hZ2VudFNldCA9PT0gdGhpcyk7XHJcbiAgICByZXR1cm4gYXJyYXlcclxuICB9XHJcbiAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHR1cnRsZXMvYnJlZWRzIHdpdGhpbiB0aGUgcGF0Y2hSZWN0LCBkeC95IGludGVnZXJzXHJcbiAgLy8gTm90ZTogd2lsbCByZXR1cm4gdHVydGxlIHRvby4gQWxzbyBzbGlnaHRseSBpbmFjY3VyYXRlIGR1ZSB0byBiZWluZ1xyXG4gIC8vIHBhdGNoIGJhc2VkLCBub3QgdHVydGxlIGJhc2VkLlxyXG4gIGluUGF0Y2hSZWN0ICh0dXJ0bGUsIGR4LCBkeSA9IGR4LCBtZVRvbyA9IGZhbHNlKSB7XHJcbiAgICAvLyBtZVRvbzogdHJ1ZSBmb3IgcGF0Y2hlcywgY291bGQgaGF2ZSBzZXZlcmFsIHR1cnRsZXMgb24gcGF0Y2hcclxuICAgIGNvbnN0IHBhdGNoZXMgPSB0aGlzLm1vZGVsLnBhdGNoZXMuaW5SZWN0KHR1cnRsZS5wYXRjaCwgZHgsIGR5LCB0cnVlKTtcclxuICAgIGNvbnN0IGFnZW50cyA9IHRoaXMuaW5QYXRjaGVzKHBhdGNoZXMpO1xyXG4gICAgaWYgKCFtZVRvbykgdXRpbC5yZW1vdmVJdGVtKGFnZW50cywgdHVydGxlKTsgLy8gZG9uJ3QgdXNlIGFnZW50cy5yZW1vdmVBZ2VudDogYnJlZWRzXHJcbiAgICByZXR1cm4gYWdlbnRzIC8vIHRoaXMuaW5QYXRjaGVzKHBhdGNoZXMpXHJcbiAgfVxyXG4gIC8vIFJldHVybiB0aGUgbWVtYmVycyBvZiB0aGlzIGFnZW50c2V0IHRoYXQgYXJlIHdpdGhpbiByYWRpdXMgZGlzdGFuY2VcclxuICAvLyBmcm9tIG1lLCB1c2luZyBhIHBhdGNoIHJlY3QuXHJcbiAgaW5SYWRpdXMgKHR1cnRsZSwgcmFkaXVzLCBtZVRvbyA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBhZ2VudHMgPSB0aGlzLmluUGF0Y2hSZWN0KHR1cnRsZSwgcmFkaXVzLCByYWRpdXMsIHRydWUpO1xyXG4gICAgcmV0dXJuIGFnZW50cy5pblJhZGl1cyh0dXJ0bGUsIHJhZGl1cywgbWVUb28pXHJcbiAgfVxyXG4gIGluQ29uZSAodHVydGxlLCByYWRpdXMsIGNvbmVBbmdsZSwgbWVUb28gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgYWdlbnRzID0gdGhpcy5pblBhdGNoUmVjdCh0dXJ0bGUsIHJhZGl1cywgcmFkaXVzLCB0cnVlKTtcclxuICAgIHJldHVybiBhZ2VudHMuaW5Db25lKHR1cnRsZSwgcmFkaXVzLCBjb25lQW5nbGUsIHR1cnRsZS50aGV0YSwgbWVUb28pXHJcbiAgfVxyXG5cclxuICAvLyBDaXJjbGUgTGF5b3V0OiBwb3NpdGlvbiB0aGUgdHVydGxlcyBpbiB0aGlzIGJyZWVkIGluIGFuIGVxdWFsbHlcclxuICAvLyBzcGFjZWQgY2lyY2xlIG9mIHRoZSBnaXZlbiByYWRpdXMsIHdpdGggdGhlIGluaXRpYWwgdHVydGxlXHJcbiAgLy8gYXQgdGhlIGdpdmVuIHN0YXJ0IGFuZ2xlIChkZWZhdWx0IHRvIHBpLzIgb3IgXCJ1cFwiKSBhbmQgaW4gdGhlXHJcbiAgLy8gKzEgb3IgLTEgZGlyZWN0aW9uIChjb3VudGVyIGNsb2Nrd2lzZSBvciBjbG9ja3dpc2UpXHJcbiAgLy8gZGVmYXVsdGluZyB0byAtMSAoY2xvY2t3aXNlKS5cclxuICBsYXlvdXRDaXJjbGUgKHJhZGl1cywgY2VudGVyID0gWzAsIDBdLCBzdGFydEFuZ2xlID0gTWF0aC5QSSAvIDIsIGRpcmVjdGlvbiA9IC0xKSB7XHJcbiAgICBjb25zdCBkVGhldGEgPSAyICogTWF0aC5QSSAvIHRoaXMubGVuZ3RoO1xyXG4gICAgY29uc3QgW3gwLCB5MF0gPSBjZW50ZXI7XHJcbiAgICB0aGlzLmFzaygodHVydGxlLCBpKSA9PiB7XHJcbiAgICAgIHR1cnRsZS5zZXR4eSh4MCwgeTApO1xyXG4gICAgICB0dXJ0bGUudGhldGEgPSBzdGFydEFuZ2xlICsgKGRpcmVjdGlvbiAqIGRUaGV0YSAqIGkpO1xyXG4gICAgICB0dXJ0bGUuZm9yd2FyZChyYWRpdXMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBGbHl3ZWlnaHQgb2JqZWN0IGNyZWF0aW9uLCBzZWUgUGF0Y2gvUGF0Y2hlcy5cclxuXHJcbi8vIENsYXNzIFR1cnRsZSBpbnN0YW5jZXMgcmVwcmVzZW50IHRoZSBkeW5hbWljLCBiZWhhdmlvcmFsIGVsZW1lbnQgb2YgbW9kZWxpbmcuXHJcbi8vIEVhY2ggdHVydGxlIGtub3dzIHRoZSBwYXRjaCBpdCBpcyBvbiwgYW5kIGludGVyYWN0cyB3aXRoIHRoYXQgYW5kIG90aGVyXHJcbi8vIHBhdGNoZXMsIGFzIHdlbGwgYXMgb3RoZXIgdHVydGxlcy5cclxuXHJcbmNsYXNzIFR1cnRsZSB7XHJcbiAgc3RhdGljIGRlZmF1bHRWYXJpYWJsZXMgKCkge1xyXG4gICAgcmV0dXJuIHsgLy8gQ29yZSB2YXJpYWJsZXMgZm9yIHR1cnRsZXMuIE5vdCAnb3duJyB2YXJpYWJsZXMuXHJcbiAgICAgIHg6IDAsICAgICAgICAgICAgIC8vIHgsIHksIHogaW4gcGF0Y2hTaXplIHVuaXRzLlxyXG4gICAgICB5OiAwLCAgICAgICAgICAgICAvLyBVc2UgdHVydGxlcy5zZXREZWZhdWx0KCd6JywgbnVtKSB0byBjaGFuZ2UgZGVmYXVsdCBoZWlnaHRcclxuICAgICAgejogMCxcclxuICAgICAgdGhldGE6IDAsICAgICAgICAgLy8gbXkgZXVjbGlkZWFuIGRpcmVjdGlvbiwgcmFkaWFucyBmcm9tIHggYXhpcywgY291bnRlci1jbG9ja3dpc2VcclxuICAgICAgc2l6ZTogMSwgICAgICAgICAgLy8gc2l6ZSBpbiBwYXRjaGVzLCBkZWZhdWx0IHRvIG9uZSBwYXRjaFxyXG5cclxuICAgICAgLy8gcGF0Y2g6IG51bGwsICAgLy8gdGhlIHBhdGNoIEknbSBvbiAuLiB1c2VzIGdldHRlciBiZWxvd1xyXG4gICAgICAvLyBsaW5rczogbnVsbCwgICAvLyB0aGUgbGlua3MgaGF2aW5nIG1lIGFzIGFuIGVuZCBwb2ludCAuLiBsYXp5IHByb21vdGVkIGJlbG93XHJcbiAgICAgIGF0RWRnZTogJ2NsYW1wJywgIC8vIFdoYXQgdG8gZG8gaWYgSSB3YW5kZXIgb2ZmIHdvcmxkLiBDYW4gYmUgJ2NsYW1wJywgJ3dyYXAnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdib3VuY2UnLCBvciBhIGZ1bmN0aW9uLCBzZWUgaGFuZGxlRWRnZSgpIG1ldGhvZFxyXG4gICAgICBzcHJpdGU6IG51bGwsXHJcbiAgICAgIHR5cGVkQ29sb3I6IG51bGwsXHJcbiAgICAgIHR5cGVkU3Ryb2tlQ29sb3I6IG51bGwsXHJcbiAgICAgIHNoYXBlRmNuOiBgZGVmYXVsdGBcclxuXHJcbiAgICAgIC8vIHNwcml0ZUZjbjogJ2RlZmF1bHQnLFxyXG4gICAgICAvLyBzcHJpdGVDb2xvcjogQ29sb3IuY29sb3IoMjU1LCAwLCAwKSxcclxuXHJcbiAgICAgIC8vIGxhYmVsT2Zmc2V0OiBbMCwgMF0sICAvLyB0ZXh0IHBpeGVsIG9mZnNldCBmcm9tIHRoZSB0dXJ0bGUgY2VudGVyXHJcbiAgICAgIC8vIGxhYmVsQ29sb3I6IENvbG9yLmNvbG9yKDAsIDAsIDApIC8vIHRoZSBsYWJlbCBjb2xvclxyXG4gICAgfVxyXG4gIH1cclxuICAvLyBJbml0aWFsaXplIGEgVHVydGxlIGdpdmVuIGl0cyBUdXJ0bGVzIEFnZW50U2V0LlxyXG4gIGNvbnN0cnVjdG9yICgpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgVHVydGxlLmRlZmF1bHRWYXJpYWJsZXMoKSk7XHJcbiAgfVxyXG4gIGRpZSAoKSB7XHJcbiAgICB0aGlzLmFnZW50U2V0LnJlbW92ZUFnZW50KHRoaXMpOyAvLyByZW1vdmUgbWUgZnJvbSBteSBiYXNlU2V0IGFuZCBicmVlZFxyXG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoJ2xpbmtzJykpIC8vIGRvbid0IHByb21vdGUgbGlua3NcclxuICAgICAgd2hpbGUgKHRoaXMubGlua3MubGVuZ3RoID4gMCkgdGhpcy5saW5rc1swXS5kaWUoKTtcclxuICAgIGlmICh0aGlzLnBhdGNoLnR1cnRsZXMgIT0gbnVsbClcclxuICAgICAgdXRpbC5yZW1vdmVJdGVtKHRoaXMucGF0Y2gudHVydGxlcywgdGhpcyk7XHJcbiAgfVxyXG4gIC8vIC8vIEJyZWVkIGdldC9zZXQgbWF0aG9kcy5cclxuICAvLyBzZXRCcmVlZCAoYnJlZWQpIHsgYnJlZWQuc2V0QnJlZWQodGhpcykgfVxyXG4gIC8vIGdldCBicmVlZCAoKSB7IHJldHVybiB0aGlzLmFnZW50U2V0IH1cclxuXHJcbiAgLy8gRmFjdG9yeTogY3JlYXRlIG51bSBuZXcgdHVydGxlcyBhdCB0aGlzIHR1cnRsZSdzIGxvY2F0aW9uLiBUaGUgb3B0aW9uYWwgaW5pdFxyXG4gIC8vIHByb2MgaXMgY2FsbGVkIG9uIHRoZSBuZXcgdHVydGxlIGFmdGVyIGluc2VydGluZyBpbiBpdHMgYWdlbnRTZXQuXHJcbiAgaGF0Y2ggKG51bSA9IDEsIGFnZW50U2V0ID0gdGhpcy5hZ2VudFNldCwgaW5pdCA9ICh0dXJ0bGUpID0+IHt9KSB7XHJcbiAgICByZXR1cm4gYWdlbnRTZXQuY3JlYXRlKG51bSwgKHR1cnRsZSkgPT4ge1xyXG4gICAgICB0dXJ0bGUuc2V0eHkodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAvLyB0dXJ0bGUuY29sb3IgPSB0aGlzLmNvbG9yIC8vIFJFTUlORDogc3ByaXRlIHZzIGNvbG9yXHJcbiAgICAgIC8vIGhhdGNoZWQgdHVydGxlIGluaGVyaXRzIHBhcmVudHMnIG93blZhcmlhYmxlc1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhZ2VudFNldC5vd25WYXJpYWJsZXMpXHJcbiAgICAgICAgaWYgKHR1cnRsZVtrZXldID09IG51bGwpIHR1cnRsZVtrZXldID0gdGhpc1trZXldO1xyXG4gICAgICBpbml0KHR1cnRsZSk7XHJcbiAgICB9KVxyXG4gIH1cclxuICAvLyBHZXR0ZXIgZm9yIGxpbmtzIGZvciB0aGlzIHR1cnRsZS4gUkVNSU5EOiB1c2UgbmV3IEFnZW50U2V0KDApP1xyXG4gIC8vIFVzZXMgbGF6eSBldmFsdWF0aW9uIHRvIHByb21vdGUgbGlua3MgdG8gaW5zdGFuY2UgdmFyaWFibGVzLlxyXG4gIC8vIFJFTUlORDogTGV0IGxpbmtzIGNyZWF0ZSB0aGUgYXJyYXkgYXMgbmVlZGVkLCBsZXNzIFwidHJpY2t5XCJcclxuICBnZXQgbGlua3MgKCkgeyAvLyBsYXp5IHByb21vdGUgbGlua3MgZnJvbSBnZXR0ZXIgdG8gaW5zdGFuY2UgcHJvcC5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGlua3MnLCB7dmFsdWU6IFtdLCBlbnVtZXJhYmxlOiB0cnVlfSk7XHJcbiAgICByZXR1cm4gdGhpcy5saW5rc1xyXG4gIH1cclxuICAvLyBHZXR0ZXIgZm9yIHRoZSBwYXRjaHMgYW5kIHRoZSBwYXRjaCBJJ20gb24uIFJldHVybiBudWxsIGlmIG9mZi13b3JsZC5cclxuICBnZXQgcGF0Y2ggKCkgeyByZXR1cm4gdGhpcy5tb2RlbC5wYXRjaGVzLnBhdGNoKHRoaXMueCwgdGhpcy55KSB9XHJcbiAgLy8gZ2V0IHBhdGNoZXMgKCkgeyByZXR1cm4gdGhpcy5tb2RlbC5wYXRjaGVzIH1cclxuXHJcbiAgLy8gSGVhZGluZyB2cyBFdWNsaWRlYW4gQW5nbGVzLiBEaXJlY3Rpb24gZm9yIGNsYXJpdHkgd2hlbiBhbWJpZ3VpdHkuXHJcbiAgZ2V0IGhlYWRpbmcgKCkgeyByZXR1cm4gdXRpbC5oZWFkaW5nKHRoaXMudGhldGEpIH1cclxuICBzZXQgaGVhZGluZyAoaGVhZGluZykgeyB0aGlzLnRoZXRhID0gdXRpbC5hbmdsZShoZWFkaW5nKTsgfVxyXG4gIGdldCBkaXJlY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50aGV0YSB9XHJcbiAgc2V0IGRpcmVjdGlvbiAodGhldGEpIHsgdGhpcy50aGV0YSA9IHRoZXRhOyB9XHJcblxyXG4gIC8vIHNldENvbG9yIChhbnlDb2xvcikgeyB0aGlzLmNvbG9yID0gQ29sb3IudG9Db2xvcihhbnlDb2xvcikgfVxyXG4gIC8vIGdldENvbG9yICgpIHtcclxuICAvLyAgIGlmICh0aGlzLmNvbG9yKSByZXR1cm5cclxuICAvLyAgIHJldHVybiB0aGlzLmNvbG9yIHx8IHRoaXMuc3ByaXRlXHJcbiAgLy8gfVxyXG5cclxuICAvLyBDcmVhdGUgbXkgc3ByaXRlIHZpYSBzaGFwZTogc3ByaXRlLCBmY24sIHN0cmluZywgb3IgaW1hZ2UvY2FudmFzXHJcbiAgc2V0U3ByaXRlIChzaGFwZSA9IHRoaXMuc2hhcGUsIGNvbG9yID0gdGhpcy5jb2xvciwgc3Ryb2tlQ29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yKSB7XHJcbiAgICBpZiAoc2hhcGUuc2hlZXQpIHsgdGhpcy5zcHJpdGUgPSBzaGFwZTsgcmV0dXJuIH0gLy8gc3JjIGlzIGEgc3ByaXRlXHJcbiAgICBjb25zdCBzcyA9IHRoaXMubW9kZWwuc3ByaXRlU2hlZXQ7XHJcbiAgICBjb2xvciA9IGNvbG9yIHx8IHRoaXMudHVydGxlcy5yYW5kb21Db2xvcigpO1xyXG4gICAgdGhpcy5zcHJpdGUgPSBzcy5uZXdTcHJpdGUoc2hhcGUsIGNvbG9yLCBzdHJva2VDb2xvcik7XHJcbiAgfVxyXG4gIHNldFNpemUgKHNpemUpIHsgdGhpcy5zaXplID0gc2l6ZTsgfSAvLyAqIHRoaXMubW9kZWwud29ybGQucGF0Y2hTaXplIH1cclxuXHJcbiAgc2V0Q29sb3IgKGNvbG9yKSB7XHJcbiAgICAvLyBpZiAodGhpcy50dXJ0bGVzLnNldHRpbmdEZWZhdWx0KHRoaXMpKSBjb25zb2xlLmxvZyhgc2V0dGluZyBkZWZhdWx0IGNvbG9yICR7Y29sb3J9YClcclxuICAgIC8vIGlmICghdGhpcy5pZCkgY29uc29sZS5sb2coYHNldHRpbmcgZGVmYXVsdCBjb2xvciAke2NvbG9yfWApXHJcbiAgICBjb25zdCB0eXBlZENvbG9yID0gQ29sb3IudG9Db2xvcihjb2xvcik7IC8vIENvbnZlcnQgdG8gQ29sb3IuY29sb3JcclxuICAgIGNvbnN0IGZpeGVkQ29sb3IgPSB0aGlzLnR1cnRsZXMucmVuZGVyZXIuZml4ZWRDb2xvcjsgLy8gTW9kZWwgc2V0IHRvIENvbG9yLmNvbG9yXHJcbiAgICBpZiAoZml4ZWRDb2xvciAmJiAhdHlwZWRDb2xvci5lcXVhbHMoZml4ZWRDb2xvcikpIHtcclxuICAgICAgdXRpbC53YXJuKGB0dXJ0bGUuc2V0Q29sb3I6IGZpeGVkQ29sb3IgIT0gY29sb3IgJHtmaXhlZENvbG9yLnRvU3RyaW5nKCl9YCk7XHJcbiAgICAvLyB9IGVsc2UgaWYgKHRoaXMuc3ByaXRlICYmICFzZXR0aW5nRGVmYXVsdCkge1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLnNwcml0ZSkgeyAvLyBkZWZhdWx0IHNwcml0ZSBzaG91bGQgYWx3YXlzIGJlIG51bGxcclxuICAgICAgdGhpcy5zcHJpdGUuY29sb3IgPSB0eXBlZENvbG9yO1xyXG4gICAgICB0aGlzLnNwcml0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICB9IGVsc2UgeyAvLyB3aWxsIHNldCBkZWZhdWx0IGNvbG9yIG9yIGluc3RhbmNlIGNvbG9yIChpZiBub3QgZml4ZWQgZXRjKVxyXG4gICAgICB0aGlzLnR5cGVkQ29sb3IgPSB0eXBlZENvbG9yO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRDb2xvciAoKSB7IHJldHVybiB0aGlzLnNwcml0ZSA/IHRoaXMuc3ByaXRlLmNvbG9yIDogdGhpcy50eXBlZENvbG9yIH1cclxuICBzZXQgY29sb3IgKGNvbG9yKSB7IHRoaXMuc2V0Q29sb3IoY29sb3IpOyB9XHJcbiAgZ2V0IGNvbG9yICgpIHsgcmV0dXJuIHRoaXMuZ2V0Q29sb3IoKSB9XHJcblxyXG4gIHNldFN0cm9rZUNvbG9yIChjb2xvcikge1xyXG4gICAgY29uc3QgdHlwZWRDb2xvciA9IENvbG9yLnRvQ29sb3IoY29sb3IpOyAvLyBDb252ZXJ0IHRvIENvbG9yLmNvbG9yXHJcbiAgICBjb25zdCBmaXhlZENvbG9yID0gdGhpcy50dXJ0bGVzLnJlbmRlcmVyLmZpeGVkQ29sb3I7IC8vIE1vZGVsIHNldCB0byBDb2xvci5jb2xvclxyXG4gICAgaWYgKGZpeGVkQ29sb3IpIHtcclxuICAgICAgdXRpbC53YXJuKGB0dXJ0bGUuc2V0U3Ryb2tlQ29sb3I6IGZpeGVkQ29sb3IgJHtmaXhlZENvbG9yLnRvU3RyaW5nKCl9YCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3ByaXRlKSB7IC8vIGRlZmF1bHQgc3ByaXRlIHNob3VsZCBhbHdheXMgYmUgbnVsbFxyXG4gICAgICB0aGlzLnNwcml0ZS5zdHJva2VDb2xvciA9IHR5cGVkQ29sb3I7XHJcbiAgICAgIHRoaXMuc3ByaXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7IC8vIHdpbGwgc2V0IGRlZmF1bHQgY29sb3Igb3IgaW5zdGFuY2UgY29sb3JcclxuICAgICAgdGhpcy50eXBlZFN0cm9rZUNvbG9yID0gdHlwZWRDb2xvcjtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0U3Ryb2tlQ29sb3IgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlID8gdGhpcy5zcHJpdGUuc3Ryb2tlQ29sb3IgOiB0aGlzLnR5cGVkU3Ryb2tlQ29sb3JcclxuICB9XHJcbiAgc2V0IHN0cm9rZENvbG9yIChjb2xvcikgeyB0aGlzLnNldFN0cm9rZUNvbG9yKGNvbG9yKTsgfVxyXG4gIGdldCBzdHJva2RDb2xvciAoKSB7IHJldHVybiB0aGlzLmdldFN0cm9rZUNvbG9yKCkgfVxyXG5cclxuICBzZXRTaGFwZSAoc2hhcGUpIHtcclxuICAgIGNvbnN0IGZpeGVkU2hhcGUgPSB0aGlzLnR1cnRsZXMucmVuZGVyZXIuZml4ZWRTaGFwZTtcclxuICAgIGlmIChmaXhlZFNoYXBlICYmIGZpeGVkU2hhcGUgIT09IHNoYXBlKSB7XHJcbiAgICAgIHV0aWwud2FybihgdHVydGxlLnNldFNoYXBlOiBmaXhlZFNoYXBlICR7Zml4ZWRTaGFwZX1gKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zcHJpdGUpIHtcclxuICAgICAgdGhpcy5zcHJpdGUuc2hhcGUgPSBzaGFwZTtcclxuICAgICAgdGhpcy5zcHJpdGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zaGFwZUZjbiA9IHNoYXBlO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRTaGFwZSAoKSB7IHJldHVybiB0aGlzLnNwcml0ZSA/IHRoaXMuc3ByaXRlLnNoYXBlIDogdGhpcy5zaGFwZUZjbiB9XHJcbiAgc2V0IHNoYXBlIChzaGFwZSkgeyB0aGlzLnNldFNoYXBlKHNoYXBlKTsgfVxyXG4gIGdldCBzaGFwZSAoKSB7IHJldHVybiB0aGlzLmdldFNoYXBlKCkgfVxyXG5cclxuICAvLyBzZXREcmF3U3ByaXRlIChmY24sIGNvbG9yLCBjb2xvcjIpIHtcclxuICAvLyAgIHRoaXMuc3ByaXRlID0gdGhpcy5tb2RlbC5zcHJpdGVTaGVldC5hZGREcmF3aW5nKGZjbiwgY29sb3IpXHJcbiAgLy8gfVxyXG5cclxuICAvLyBTZXQgeCwgeSBwb3NpdGlvbi4gSWYgeiBnaXZlbiwgb3ZlcnJpZGUgZGVmYXVsdCB6LlxyXG4gIC8vIENhbGwgaGFuZGxlRWRnZSh4LCB5KSBpZiB4LCB5IG9mZi13b3JsZC5cclxuICBzZXR4eSAoeCwgeSwgeiA9IG51bGwpIHtcclxuICAgIGNvbnN0IHAwID0gdGhpcy5wYXRjaDtcclxuICAgIGlmICh6KSB0aGlzLnogPSB6OyAvLyBkb24ndCBwcm9tb3RlIHogaWYgbnVsbCwgdXNlIGRlZmF1bHQgeiBpbnN0ZWFkLlxyXG4gICAgaWYgKHRoaXMubW9kZWwud29ybGQuaXNPbldvcmxkKHgsIHkpKSB7XHJcbiAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgIHRoaXMueSA9IHk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmhhbmRsZUVkZ2UoeCwgeSk7XHJcbiAgICAgIC8vIGNvbnN0IHttaW5YY29yLCBtYXhYY29yLCBtaW5ZY29yLCBtYXhZY29yfSA9IHRoaXMubW9kZWwud29ybGRcclxuICAgICAgLy8gaWYgKHRoaXMud3JhcCkge1xyXG4gICAgICAvLyAgIHRoaXMueCA9IHV0aWwud3JhcCh4LCBtaW5YY29yLCBtYXhYY29yKVxyXG4gICAgICAvLyAgIHRoaXMueSA9IHV0aWwud3JhcCh5LCBtaW5ZY29yLCBtYXhZY29yKVxyXG4gICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAvLyAgIHRoaXMueCA9IHV0aWwuY2xhbXAoeCwgbWluWGNvciwgbWF4WGNvcilcclxuICAgICAgLy8gICB0aGlzLnkgPSB1dGlsLmNsYW1wKHksIG1pblljb3IsIG1heFljb3IpXHJcbiAgICAgIC8vIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHAgPSB0aGlzLnBhdGNoO1xyXG4gICAgaWYgKHAudHVydGxlcyAhPSBudWxsICYmIHAgIT09IHAwKSB7XHJcbiAgICAgIHV0aWwucmVtb3ZlSXRlbShwMC50dXJ0bGVzLCB0aGlzKTtcclxuICAgICAgcC50dXJ0bGVzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIEhhbmRsZSB0dXJ0bGUgaWYgeCx5IG9mZi13b3JsZFxyXG4gIGhhbmRsZUVkZ2UgKHgsIHkpIHtcclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHRoaXMuYXRFZGdlKSkge1xyXG4gICAgICBjb25zdCB7bWluWGNvciwgbWF4WGNvciwgbWluWWNvciwgbWF4WWNvcn0gPSB0aGlzLm1vZGVsLndvcmxkO1xyXG4gICAgICBpZiAodGhpcy5hdEVkZ2UgPT09ICd3cmFwJykge1xyXG4gICAgICAgIHRoaXMueCA9IHV0aWwud3JhcCh4LCBtaW5YY29yLCBtYXhYY29yKTtcclxuICAgICAgICB0aGlzLnkgPSB1dGlsLndyYXAoeSwgbWluWWNvciwgbWF4WWNvcik7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hdEVkZ2UgPT09ICdjbGFtcCcgfHwgdGhpcy5hdEVkZ2UgPT09ICdib3VuY2UnKSB7XHJcbiAgICAgICAgdGhpcy54ID0gdXRpbC5jbGFtcCh4LCBtaW5YY29yLCBtYXhYY29yKTtcclxuICAgICAgICB0aGlzLnkgPSB1dGlsLmNsYW1wKHksIG1pblljb3IsIG1heFljb3IpO1xyXG4gICAgICAgIGlmICh0aGlzLmF0RWRnZSA9PT0gJ2JvdW5jZScpIHtcclxuICAgICAgICAgIGlmICh0aGlzLnggPT09IG1pblhjb3IgfHwgdGhpcy54ID09PSBtYXhYY29yKVxyXG4gICAgICAgICAgICB0aGlzLnRoZXRhID0gTWF0aC5QSSAtIHRoaXMudGhldGE7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMudGhldGEgPSAtdGhpcy50aGV0YTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoYHR1cnRsZS5oYW5kbGVFZGdlOiBiYWQgYXRFZGdlOiAke3RoaXMuYXRFZGdlfWApXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYXRFZGdlKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBQbGFjZSB0aGUgdHVydGxlIGF0IHRoZSBnaXZlbiBwYXRjaC90dXJ0bGUgbG9jYXRpb25cclxuICBtb3ZlVG8gKGFnZW50KSB7IHRoaXMuc2V0eHkoYWdlbnQueCwgYWdlbnQueSk7IH1cclxuICAvLyBNb3ZlIGZvcndhcmQgKGFsb25nIHRoZXRhKSBkIHVuaXRzIChwYXRjaCBjb29yZHMpLFxyXG4gIGZvcndhcmQgKGQpIHtcclxuICAgIHRoaXMuc2V0eHkodGhpcy54ICsgZCAqIE1hdGguY29zKHRoaXMudGhldGEpLCB0aGlzLnkgKyBkICogTWF0aC5zaW4odGhpcy50aGV0YSkpO1xyXG4gIH1cclxuICAvLyBDaGFuZ2UgY3VycmVudCBkaXJlY3Rpb24gYnkgcmFkIHJhZGlhbnMgd2hpY2ggY2FuIGJlICsgKGxlZnQpIG9yIC0gKHJpZ2h0KS5cclxuICByb3RhdGUgKHJhZCkgeyB0aGlzLnRoZXRhID0gdXRpbC5tb2QodGhpcy50aGV0YSArIHJhZCwgTWF0aC5QSSAqIDIpOyB9XHJcbiAgcmlnaHQgKHJhZCkgeyB0aGlzLnJvdGF0ZSgtcmFkKTsgfVxyXG4gIGxlZnQgKHJhZCkgeyB0aGlzLnJvdGF0ZShyYWQpOyB9XHJcblxyXG4gIC8vIFNldCBteSBkaXJlY3Rpb24gdG93YXJkcyB0dXJ0bGUvcGF0Y2ggb3IgeCx5LlxyXG4gIC8vIFwiZGlyZWN0aW9uXCIgaXMgZXVjbGlkZWFuIHJhZGlhbnMuXHJcbiAgZmFjZSAoYWdlbnQpIHsgdGhpcy50aGV0YSA9IHRoaXMudG93YXJkcyhhZ2VudCk7IH1cclxuICBmYWNlWFkgKHgsIHkpIHsgdGhpcy50aGV0YSA9IHRoaXMudG93YXJkc1hZKHgsIHkpOyB9XHJcblxyXG4gIC8vIFJldHVybiB0aGUgcGF0Y2ggYWhlYWQgb2YgdGhpcyB0dXJ0bGUgYnkgZGlzdGFuY2UgKHBhdGNoU2l6ZSB1bml0cykuXHJcbiAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiBvZmYtd29ybGQuXHJcbiAgcGF0Y2hBaGVhZCAoZGlzdGFuY2UpIHtcclxuICAgIHJldHVybiB0aGlzLnBhdGNoQXREaXJlY3Rpb25BbmREaXN0YW5jZSh0aGlzLnRoZXRhLCBkaXN0YW5jZSlcclxuICB9XHJcbiAgLy8gVXNlIHBhdGNoQWhlYWQgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgdHVydGxlIGNhbiBtb3ZlIGZvcndhcmQgYnkgZGlzdGFuY2UuXHJcbiAgY2FuTW92ZSAoZGlzdGFuY2UpIHsgcmV0dXJuIHRoaXMucGF0Y2hBaGVhZChkaXN0YW5jZSkgIT0gbnVsbCB9IC8vIG51bGwgLyB1bmRlZmluZWRcclxuICBwYXRjaExlZnRBbmRBaGVhZCAoYW5nbGUsIGRpc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXRjaEF0RGlyZWN0aW9uQW5kRGlzdGFuY2UoYW5nbGUgKyB0aGlzLnRoZXRhLCBkaXN0YW5jZSlcclxuICB9XHJcbiAgcGF0Y2hSaWdodEFuZEFoZWFkIChhbmdsZSwgZGlzdGFuY2UpIHtcclxuICAgIHJldHVybiB0aGlzLnBhdGNoQXREaXJlY3Rpb25BbmREaXN0YW5jZShhbmdsZSAtIHRoaXMudGhldGEsIGRpc3RhbmNlKVxyXG4gIH1cclxuXHJcbiAgLy8gNiBtZXRob2RzIGluIGJvdGggUGF0Y2ggJiBUdXJ0bGUgbW9kdWxlc1xyXG4gIC8vIERpc3RhbmNlIGZyb20gbWUgdG8geCwgeS4gUkVNSU5EOiBObyBvZmYtd29ybGQgdGVzdCBkb25lXHJcbiAgZGlzdGFuY2VYWSAoeCwgeSkgeyByZXR1cm4gdXRpbC5kaXN0YW5jZSh0aGlzLngsIHRoaXMueSwgeCwgeSkgfVxyXG4gIC8vIFJldHVybiBkaXN0YW5jZSBmcm9tIG1lIHRvIG9iamVjdCBoYXZpbmcgYW4geCx5IHBhaXIgKHR1cnRsZSwgcGF0Y2gsIC4uLilcclxuICAvLyBkaXN0YW5jZSAoYWdlbnQpIHsgdGhpcy5kaXN0YW5jZVhZKGFnZW50LngsIGFnZW50LnkpIH1cclxuICBkaXN0YW5jZSAoYWdlbnQpIHsgcmV0dXJuIHV0aWwuZGlzdGFuY2UodGhpcy54LCB0aGlzLnksIGFnZW50LngsIGFnZW50LnkpIH1cclxuICAvLyBSZXR1cm4gYW5nbGUgdG93YXJkcyBhZ2VudC94LHlcclxuICAvLyBVc2UgdXRpbC5oZWFkaW5nIHRvIGNvbnZlcnQgdG8gaGVhZGluZ1xyXG4gIHRvd2FyZHMgKGFnZW50KSB7IHJldHVybiB0aGlzLnRvd2FyZHNYWShhZ2VudC54LCBhZ2VudC55KSB9XHJcbiAgdG93YXJkc1hZICh4LCB5KSB7IHJldHVybiB1dGlsLnJhZGlhbnNUb3dhcmQodGhpcy54LCB0aGlzLnksIHgsIHkpIH1cclxuICAvLyBSZXR1cm4gcGF0Y2ggdy8gZ2l2ZW4gcGFyYW1ldGVycy4gUmV0dXJuIHVuZGVmaW5lZCBpZiBvZmYtd29ybGQuXHJcbiAgLy8gUmV0dXJuIHBhdGNoIGR4LCBkeSBmcm9tIG15IHBvc2l0aW9uLlxyXG4gIHBhdGNoQXQgKGR4LCBkeSkgeyByZXR1cm4gdGhpcy5tb2RlbC5wYXRjaGVzLnBhdGNoKHRoaXMueCArIGR4LCB0aGlzLnkgKyBkeSkgfVxyXG4gIC8vIE5vdGU6IGFuZ2xlIGlzIGFic29sdXRlLCB3L28gcmVnYXJkIHRvIGV4aXN0aW5nIGFuZ2xlIG9mIHR1cnRsZS5cclxuICAvLyBVc2UgTGVmdC9SaWdodCB2ZXJzaW9ucyBiZWxvd1xyXG4gIHBhdGNoQXREaXJlY3Rpb25BbmREaXN0YW5jZSAoZGlyZWN0aW9uLCBkaXN0YW5jZSkge1xyXG4gICAgcmV0dXJuIHRoaXMubW9kZWwucGF0Y2hlcy5wYXRjaEF0RGlyZWN0aW9uQW5kRGlzdGFuY2UodGhpcywgZGlyZWN0aW9uLCBkaXN0YW5jZSlcclxuICB9XHJcblxyXG4gIC8vIC8vIFJldHVybiB0dXJ0bGVzL2JyZWVkcyB3aXRoaW4gcmFkaXVzIGZyb20gbWVcclxuICAvLyBpblJhZGl1cyAocmFkaXVzLCBtZVRvbyA9IGZhbHNlKSB7XHJcbiAgLy8gICByZXR1cm4gdGhpcy5hZ2VudFNldC5pblJhZGl1cyh0aGlzLCByYWRpdXMsIG1lVG9vKVxyXG4gIC8vIH1cclxuICAvLyAvLyBSZXR1cm4gdHVydGxlcy9icmVlZHMgd2l0aGluIGNvbmUgZnJvbSBtZVxyXG4gIC8vIC8vIE5vdGU6IGFnZW50U2V0IHJhdGhlciB0aGFuIHR1cnRsZXMgdG8gYWxsb3cgZm9yIGJyZWVkc1xyXG4gIC8vIGluQ29uZSAocmFkaXVzLCBjb25lQW5nbGUsIG1lVG9vID0gZmFsc2UpIHtcclxuICAvLyAgIHJldHVybiB0aGlzLmFnZW50U2V0LmluQ29uZSh0aGlzLCByYWRpdXMsIGNvbmVBbmdsZSwgdGhpcy50aGV0YSwgbWVUb28pXHJcbiAgLy8gfVxyXG5cclxuICAvLyBMaW5rIG1ldGhvZHMuIE5vdGU6IHRoaXMubGlua3MgcmV0dXJucyBhbGwgbGlua3MgbGlua2VkIHRvIG1lLlxyXG4gIC8vIFNlZSBsaW5rcyBnZXR0ZXIgYWJvdmUuXHJcblxyXG4gIC8vIFJldHVybiBvdGhlciBlbmQgb2YgbGluayBmcm9tIG1lLiBMaW5rIG11c3QgaW5jbHVkZSBtZSFcclxuICBvdGhlckVuZCAobCkgeyByZXR1cm4gbC5lbmQwID09PSB0aGlzID8gbC5lbmQxIDogbC5lbmQwIH1cclxuICAvLyBSZXR1cm4gYWxsIHR1cnRsZXMgbGlua2VkIHRvIG1lXHJcbiAgbGlua05laWdoYm9ycyAoKSB7IHJldHVybiB0aGlzLmxpbmtzLm1hcCgobCkgPT4gdGhpcy5vdGhlckVuZChsKSkgfVxyXG59XHJcblxyXG4vLyBTcHJpdGVzIGFyZSBpbWFnZXMvZHJhd2luZ3Mgd2l0aGluIGEgc3ByaXRlLXNoZWV0LlxyXG5jbGFzcyBTcHJpdGVTaGVldCB7XHJcbiAgY29uc3RydWN0b3IgKHNwcml0ZVNpemUgPSA2NCwgc3ByaXRlc1BlclJvdyA9IDE2LCB1c2VQb3dlck9mMiA9IHRydWUpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywge3Nwcml0ZVNpemUsIGNvbHM6IHNwcml0ZXNQZXJSb3csIHVzZVBvd2VyT2YyfSk7XHJcbiAgICB0aGlzLnJvd3MgPSAxO1xyXG4gICAgdGhpcy5uZXh0Q29sID0gMDtcclxuICAgIHRoaXMubmV4dFJvdyA9IDA7XHJcbiAgICB0aGlzLnNwcml0ZXMgPSB7fTtcclxuICAgIHRoaXMucGF0aHMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXRocyk7IC8vIGluc3RhbGxQYXRocygpXHJcbiAgICBpZiAodXNlUG93ZXJPZjIpIHRoaXMuY2hlY2tQb3dlck9mMigpO1xyXG4gICAgdGhpcy5jdHggPSB1dGlsLmNyZWF0ZUN0eCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsOyAvLyBUSFJFRSB1c2Ugb3B0aW9uYWxcclxuICB9XHJcblxyXG4gIC8vIGdldHRlcnMgZm9yIGRlcml2ZWQgdmFsdWVzLlxyXG4gIC8vIHdpZHRoICYgaGVpZ2h0IGluIHBpeGVsc1xyXG4gIGdldCB3aWR0aCAoKSB7IHJldHVybiB0aGlzLnNwcml0ZVNpemUgKiB0aGlzLmNvbHMgfVxyXG4gIGdldCBoZWlnaHQgKCkgeyByZXR1cm4gdGhpcy5zcHJpdGVTaXplICogdGhpcy5yb3dzIH1cclxuICAvLyBuZXh0IGNvbCwgcm93IGluIHBpeGVsc1xyXG4gIGdldCBuZXh0WCAoKSB7IHJldHVybiB0aGlzLnNwcml0ZVNpemUgKiB0aGlzLm5leHRDb2wgfVxyXG4gIGdldCBuZXh0WSAoKSB7IHJldHVybiB0aGlzLnNwcml0ZVNpemUgKiB0aGlzLm5leHRSb3cgfVxyXG4gIC8vIGlkID0gbnVtYmVyIG9mIHNwcml0ZXNcclxuICBnZXQgaWQgKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zcHJpdGVzKS5sZW5ndGggfVxyXG5cclxuICAvLyBSRU1JTkQ6IHRoaXMgaXMgYSBwbGFjZSBob2xkZXIgZm9yIGRlbGV0aW5nIHNoZWV0IGFuZCBpdCdzIHNwcml0ZXMuXHJcbiAgLy8gTm9uLXRyaXZpYWwuXHJcbiAgY2xlYXIgKCkge1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmN0eC5jYW52YXMsIHt3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLnNwcml0ZVNpemV9KTtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiBhIHNwcml0ZS4gQ3JlYXRlIGl0IGlmIG5vdCBpbiBzcHJpdGVzIGNhY2hlLlxyXG4gIC8vIFNyYyBjYW4gYmU6IGltYWdlLCBjYW52YXMsIGZ1bmN0aW9uIG5hbWUsIGZ1bmN0aW9uLlxyXG4gIC8vIElmIHNyYyBpcyBhIGNhbnZhcywgaXQgbXVzdCBoYXZlIGEgc3JjIHN0cmluZyB3L28gLyBvciAuIGNoYXJzLlxyXG4gIC8vIElmIHNyYyBpcyBmdW5jdGlvbiBvciBuYW1lIG9mIHBhdGggYmVsb3csIGNvbG9ycyBjYW4gYmUgY3NzXHJcbiAgLy8gb3IgQ29sb3IgbW9kdWxlJ3MgQ29sb3Igb2JqZWN0LlxyXG4gIG5ld1Nwcml0ZSAoc3JjLCBjb2xvciwgc3Ryb2tlQ29sb3IpIHtcclxuICAgIC8vIE5vcm1hbGl6ZSBjb2xvciBuYW1lcyB0byBDb2xvci5jb2xvciBvYmplY3RzXHJcbiAgICBpZiAoY29sb3IpIGNvbG9yID0gQ29sb3IudG9Db2xvcihjb2xvcik7XHJcbiAgICBpZiAoc3Ryb2tlQ29sb3IpIHN0cm9rZUNvbG9yID0gQ29sb3IudG9Db2xvcihzdHJva2VDb2xvcik7XHJcblxyXG4gICAgLy8gY3JlYXRlIGEgbm9ybWFsaXplZCBuYW1lOlxyXG4gICAgY29uc3QgbmFtZSA9IHRoaXMuc3ByaXRlTmFtZShzcmMsIGNvbG9yLCBzdHJva2VDb2xvcik7XHJcbiAgICAvLyBJZiBzcHJpdGUgb2YgdGhzIG5hbWUgYWxyZWFkeSBleGlzdHMsIHJldHVybiBpdC5cclxuICAgIGlmICh0aGlzLnNwcml0ZXNbbmFtZV0pIHJldHVybiB0aGlzLnNwcml0ZXNbbmFtZV1cclxuXHJcbiAgICAvLyBNYWtlIGEgbmV3IHNwcml0ZS5cclxuICAgIGNvbnN0IHNwcml0ZSA9IHV0aWwuaXNJbWFnZWFibGUoc3JjKVxyXG4gICAgICA/IHRoaXMuYWRkSW1hZ2Uoc3JjKVxyXG4gICAgICA6IHRoaXMuYWRkRHJhd2luZyhzcmMsIGNvbG9yLCBzdHJva2VDb2xvcik7XHJcbiAgICBPYmplY3QuYXNzaWduKHNwcml0ZSwge3NyYywgY29sb3IsIHN0cm9rZUNvbG9yLCBuZWVkc1VwZGF0ZTogZmFsc2V9KTtcclxuXHJcbiAgICAvLyBBZGQgbm9ybWFsaXplZCBjb2xvcnMgYW5kIHNoYXBlIG5hbWUgdG8gbmV3IHNwcml0ZS5cclxuICAgIC8vIGlmIChjb2xvcikge1xyXG4gICAgLy8gICBzcHJpdGUuY29sb3IgPSBjb2xvclxyXG4gICAgLy8gICBpZiAoc3Ryb2tlQ29sb3IpIHNwcml0ZS5zdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yXHJcbiAgICAvLyAgIHNwcml0ZS5zaGFwZSA9IG5hbWUucmVwbGFjZSgvIy4qLywgJycpIC8vIGRyb3AgI3h4eHh4eCBmcm9tIG5hbWVcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyBBZGQgc3ByaXRlIHRvIGNhY2hlIGFuZCByZXR1cm4gaXQuXHJcbiAgICB0aGlzLnNwcml0ZXNbbmFtZV0gPSBzcHJpdGU7XHJcbiAgICByZXR1cm4gc3ByaXRlXHJcbiAgfVxyXG5cclxuICAvLyBJbnN0YWxsIGEgbmV3IG5hbWVkIGZ1bmN0aW9uIGluIHRoZSBwYXRocyBvYmplY3QgYmVsb3cuXHJcbiAgLy8gVXNlZCB0byBhZGQgXCJjYXJcIiwgXCJ0aHVnXCIsIFwic3BpZGVyXCIgZXRjIGRyYXdpbmdzLlxyXG4gIGluc3RhbGxEcmF3aW5nIChmY24sIG5hbWUgPSBmY24ubmFtZSkgeyB0aGlzLnBhdGhzW25hbWVdID0gZmNuOyB9XHJcblxyXG4vLyBUaGVzZSBhcmUgaW50ZXJuYWwsIGV4cGVydHMgb25seSwgdXNlIG5ld1Nwcml0ZSBhYm92ZSBmb3Igbm9ybWFsIHVzZS5cclxuXHJcbiAgLy8gTWFrZSBhIHVuaXF1ZSwgbm9ybWFsaXplZCBzcHJpdGUgbmFtZS4gU2VlIG5vdGUgb24gc3JjLCBjb2xvcnMgYWJvdmUuXHJcbiAgLy8gQ29sb3IgbmFtZXMgYXJlIGhleCBjc3MgZm9ybWF0cywgc2VlIG5ld1Nwcml0ZSdzIG5hbWUgdHJhbnNmb3JtYXRpb24uXHJcbiAgc3ByaXRlTmFtZSAoc3JjLCBmaWxsQ29sb3IsIHN0cm9rZUNvbG9yKSB7XHJcbiAgICBsZXQgbmFtZTtcclxuICAgIC8vIElmIHNyYyBpcyBhbiBpbWFnZSwgY29uc3RydWN0IGEgbmFtZS5cclxuICAgIGlmICh1dGlsLmlzSW1hZ2VhYmxlKHNyYykpIHtcclxuICAgICAgbmFtZSA9IHNyYy5zcmM7XHJcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL14uKlxcLy8sICcnKTsgLy8gcmVtb3ZlIHBhdGhcclxuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFwuLiovLCAnLmltZycpOyAvLyByZXBsYWNlIC5wbmcvanBnLy4uIHcvIFwiLmltZ1wiXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBkaXR0byBmb3IgZHJhdyBmdW5jdGlvbiBvciBuYW1lIG9mIGZ1bmN0aW9uIGluIHBhdGhzIG9iaiBiZWxvd1xyXG4gICAgICBuYW1lID0gc3JjLm5hbWUgfHwgc3JjO1xyXG4gICAgICBpZiAoIW5hbWUuZW5kc1dpdGgoJzInKSkgc3Ryb2tlQ29sb3IgPSBudWxsO1xyXG4gICAgICBuYW1lID0gYCR7bmFtZX0ke2ZpbGxDb2xvci5jc3N9JHtzdHJva2VDb2xvciA/IHN0cm9rZUNvbG9yLmNzcyA6ICcnfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIGFuIGltYWdlL2NhbnZhcyB0byBzcHJpdGUgc2hlZXQuXHJcbiAgYWRkSW1hZ2UgKGltZykge1xyXG4gICAgdGhpcy5jaGVja1NoZWV0U2l6ZSgpOyAvLyBSZXNpemUgY3R4IGlmIG5leHRSb3cgPT09IHJvd3NcclxuICAgIGNvbnN0IFt4LCB5LCBzaXplXSA9IFt0aGlzLm5leHRYLCB0aGlzLm5leHRZLCB0aGlzLnNwcml0ZVNpemVdO1xyXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZywgeCwgeSwgc2l6ZSwgc2l6ZSk7XHJcbiAgICBjb25zdCBpZCA9IHRoaXMuaWQ7IC8vIE9iamVjdC5rZXlzKHRoaXMuc3ByaXRlcykubGVuZ3RoXHJcbiAgICBjb25zdCB7bmV4dFJvdzogcm93LCBuZXh0Q29sOiBjb2x9ID0gdGhpcztcclxuICAgIGNvbnN0IHNwcml0ZSA9IHtpZCwgeCwgeSwgcm93LCBjb2wsIHNpemUsIHNoZWV0OiB0aGlzfTtcclxuICAgIHNwcml0ZS51dnMgPSB0aGlzLmdldFVWcyhzcHJpdGUpO1xyXG4gICAgdGhpcy5pbmNyZW1lbnRSb3dDb2woKTtcclxuICAgIGlmICh0aGlzLnRleHR1cmUpIHRoaXMudGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICByZXR1cm4gc3ByaXRlXHJcbiAgfVxyXG4gIC8vIFVzZSBhYm92ZSB0byBhZGQgYSBkcmF3aW5nIHRvIHNwcml0ZSBzaGVldFxyXG4gIGFkZERyYXdpbmcgKGRyYXdGY24sIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IsIHVzZUhlbHBlcnMgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBpbWcgPSB0aGlzLmNyZWF0ZUZjbkNhbnZhcyhkcmF3RmNuLCBmaWxsQ29sb3IsIHN0cm9rZUNvbG9yLCB1c2VIZWxwZXJzKTtcclxuICAgIHJldHVybiB0aGlzLmFkZEltYWdlKGltZykgLy8gcmV0dXJuIHNwcml0ZVxyXG4gIH1cclxuXHJcbiAgLy8gUmVzaXplIGN0eCBpZiB0b28gc21hbGwgZm9yIG5leHQgcm93L2NvbFxyXG4gIGNoZWNrU2hlZXRTaXplICgpIHtcclxuICAgIGlmICh0aGlzLm5leHRSb3cgPT09IHRoaXMucm93cykgeyAvLyB0aGlzLm5leHRDb2wgc2hvdWxkIGJlIDBcclxuICAgICAgdGhpcy5yb3dzID0gKHRoaXMudXNlUG93ZXJPZjIpID8gdGhpcy5yb3dzICogMiA6IHRoaXMucm93cyArIDE7XHJcbiAgICAgIHV0aWwucmVzaXplQ3R4KHRoaXMuY3R4LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgIC8vIFJlY2FsY3VsYXRlIGV4aXN0aW5nIHNwcml0ZSB1dnMuXHJcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLnNwcml0ZXMsIChzcHJpdGUpID0+IHsgc3ByaXRlLnV2cyA9IHRoaXMuZ2V0VVZzKHNwcml0ZSk7IH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBBZHZhbmNlIG5leHRDb2wvUm93LiBEb25lIGFmdGVyIGNoZWNrU2hlZXRTaXplIGVubGFyZ2VkIGN0eCBpZiBuZWVkZWQuXHJcbiAgaW5jcmVtZW50Um93Q29sICgpIHtcclxuICAgIHRoaXMubmV4dENvbCArPSAxO1xyXG4gICAgaWYgKHRoaXMubmV4dENvbCA8IHRoaXMuY29scykgcmV0dXJuXHJcbiAgICB0aGlzLm5leHRDb2wgPSAwO1xyXG4gICAgdGhpcy5uZXh0Um93ICs9IDE7XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgYSBzcHJpdGUgaW1hZ2UuIFNlZSBbRHJhd2luZyBzaGFwZXMgd2l0aCBjYW52YXNdKGh0dHBzOi8vZ29vLmdsL3VCd3hNcSlcclxuICAvL1xyXG4gIC8vIFRoZSBkcmF3RmNuIGFyZ3M6IGRyYXdGY24oY3R4KS5cclxuICAvLyBUaGUgY3R4IGZpbGwgJiBzdHJva2Ugc3R5bGVzIGFyZSBwcmUtZmlsbGVkIHcvIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IuXHJcbiAgLy9cclxuICAvLyBJZiB1c2VIZWxwZXJzOlxyXG4gIC8vIC0gVHJhbnNmb3JtIHRvIC0xIC0+ICsxIGNvb3Jkc1xyXG4gIC8vIC0gZHJhd0ZjbiBpcyBzdXJyb3VuZGVkIHdpdGggY3R4IGJlZ2luUGF0aCAmIGNsb3NlUGF0aCwgZmlsbCBmY25zLlxyXG4gIC8vXHJcbiAgLy8gSWYgbm90IHVzaW5nIGhlbHBlcnMsIGN0eC5jYW52YXMud2lkdGgvaGVpZ2h0IGlzIHRoZSBzaXplIG9mIGRyYXdpbmcsXHJcbiAgLy8gdG9wL2xlZnQgY2FudmFzIGNvb3JkaW5hdGVzLlxyXG4gIGNyZWF0ZUZjbkNhbnZhcyAoZHJhd0ZjbiwgZmlsbENvbG9yLCBzdHJva2VDb2xvciwgdXNlSGVscGVycyA9IHRydWUpIHtcclxuICAgIGNvbnN0IGN0eCA9IHV0aWwuY3JlYXRlQ3R4KHRoaXMuc3ByaXRlU2l6ZSwgdGhpcy5zcHJpdGVTaXplKTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuY3NzIHx8IGZpbGxDb2xvcjtcclxuICAgIGlmIChzdHJva2VDb2xvcilcclxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IuY3NzIHx8IHN0cm9rZUNvbG9yO1xyXG4gICAgaWYgKHVzZUhlbHBlcnMpIHtcclxuICAgICAgY3R4LnNjYWxlKHRoaXMuc3ByaXRlU2l6ZSAvIDIsIHRoaXMuc3ByaXRlU2l6ZSAvIDIpO1xyXG4gICAgICBjdHgudHJhbnNsYXRlKDEsIDEpO1xyXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcoZHJhd0ZjbikpIHtcclxuICAgICAgdGhpcy5wYXRoc1tkcmF3RmNuXShjdHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZHJhd0ZjbihjdHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1c2VIZWxwZXJzKSB7XHJcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgY3R4LmZpbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuYW1lID0gZHJhd0Zjbi5uYW1lIHx8IGRyYXdGY247XHJcbiAgICBjdHguY2FudmFzLnNyYyA9IGAke25hbWV9JHtmaWxsQ29sb3J9YDtcclxuICAgIHJldHVybiBjdHguY2FudmFzXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gc3RhbmRhcmQgYWdlbnRzY3JpcHQgcXVhZDpcclxuICAvLyAgICAgIDMgICAyXHJcbiAgLy8gICAgICAtLS0tLVxyXG4gIC8vICAgICAgfCAgL3xcclxuICAvLyAgICAgIHwgLyB8XHJcbiAgLy8gICAgICB8LyAgfFxyXG4gIC8vICAgICAgLS0tLS1cclxuICAvLyAgICAgIDAgICAxXHJcbiAgLy8gSS5lLiBib3RMZWZ0LCBib3RSaWdodCwgdG9wUmlnaHQsIHRvcExlZnRcclxuICAvLyBnZXRVVnMgKHNwcml0ZSkge1xyXG4gIC8vICAgY29uc3Qge3JvdywgY29sfSA9IHNwcml0ZVxyXG4gIC8vICAgY29uc3Qge3Jvd3MsIGNvbHN9ID0gdGhpc1xyXG4gIC8vICAgY29uc3QgeDAgPSBjb2wgLyBjb2xzXHJcbiAgLy8gICBjb25zdCB5MCA9IHJvdyAvIHJvd3NcclxuICAvLyAgIGNvbnN0IHgxID0gKGNvbCArIDEpIC8gY29sc1xyXG4gIC8vICAgY29uc3QgeTEgPSAocm93ICsgMSkgLyByb3dzXHJcbiAgLy8gICAvLyByZXR1cm4gW1t4MCwgeTFdLCBbeDEsIHkxXSwgW3gxLCB5MF0sIFt4MCwgeTBdXVxyXG4gIC8vICAgcmV0dXJuIFt4MCwgeTEsIHgxLCB5MSwgeDEsIHkwLCB4MCwgeTBdXHJcbiAgLy8gfVxyXG4gIGdldFVWcyAoc3ByaXRlKSB7IC8vIG5vdGUgdidzIGFyZSBtZWFzdXJlZCBmcm9tIHRoZSBib3R0b20uXHJcbiAgICBjb25zdCB7cm93LCBjb2x9ID0gc3ByaXRlO1xyXG4gICAgY29uc3Qge3Jvd3MsIGNvbHN9ID0gdGhpcztcclxuICAgIGNvbnN0IHUwID0gY29sIC8gY29scztcclxuICAgIGNvbnN0IHYwID0gKHJvd3MgLSAocm93ICsgMSkpIC8gcm93cztcclxuICAgIGNvbnN0IHUxID0gKGNvbCArIDEpIC8gY29scztcclxuICAgIGNvbnN0IHYxID0gKHJvd3MgLSByb3cpIC8gcm93cztcclxuICAgIC8vIHJldHVybiBbW3gwLCB5MV0sIFt4MSwgeTFdLCBbeDEsIHkwXSwgW3gwLCB5MF1dXHJcbiAgICByZXR1cm4gW3UwLCB2MCwgdTEsIHYwLCB1MSwgdjEsIHUwLCB2MV1cclxuICB9XHJcbiAgLy8gUmV0dXJuIHV2J3Mgb2JqZWN0OiB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdExlZnQsIGJvdFJpZ2h0fVxyXG4gIC8vIGdldFVWc09iaiAoc3ByaXRlKSB7IC8vIFJFTUlORFxyXG4gIC8vICAgY29uc3QgdXZzID0gdGhpcy5nZXRVVnNcclxuICAvLyAgIHJldHVybiB7XHJcbiAgLy8gICAgIGJvdExlZnQ6IHV2c1swXSxcclxuICAvLyAgICAgYm90UmlnaHQ6IHV2c1sxXSxcclxuICAvLyAgICAgdG9wUmlnaHQ6IHV2c1syXSxcclxuICAvLyAgICAgdG9wTGVmdDogdXZzWzNdXHJcbiAgLy8gICB9XHJcbiAgLy8gfVxyXG5cclxuICBjaGVja1Bvd2VyT2YyICgpIHtcclxuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XHJcbiAgICBpZiAoISh1dGlsLmlzUG93ZXJPZjIod2lkdGgpICYmIHV0aWwuaXNQb3dlck9mMihoZWlnaHQpKSlcclxuICAgICAgdGhyb3cgRXJyb3IoYFNwcml0ZVNoZWV0IG5vbiBwb3dlciBvZiAyOiAke3dpZHRofXgke2hlaWdodH1gKVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgcGF0aHMgPSB7XHJcbiAgcG9seSAoY3R4LCBwb2ludHMpIHtcclxuICAgIHBvaW50cy5mb3JFYWNoKChwdCwgaSkgPT4ge1xyXG4gICAgICBpZiAoaSA9PT0gMCkgY3R4Lm1vdmVUbyhwdFswXSwgcHRbMV0pO1xyXG4gICAgICBlbHNlIGN0eC5saW5lVG8ocHRbMF0sIHB0WzFdKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgZGVmYXVsdCAoY3R4KSB7IHRoaXMuZGFydChjdHgpOyB9LFxyXG4gIGFycm93IChjdHgpIHtcclxuICAgIHRoaXMucG9seShjdHgsXHJcbiAgICAgIFtbMSwgMF0sIFswLCAxXSwgWzAsIDAuNF0sIFstMSwgMC40XSwgWy0xLCAtMC40XSwgWzAsIC0wLjRdLCBbMCwgLTFdXSk7XHJcbiAgfSxcclxuICBidWcgKGN0eCkge1xyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcclxuICAgIHRoaXMuYnVnMihjdHgpO1xyXG4gIH0sXHJcbiAgYnVnMiAoY3R4KSB7XHJcbiAgICBjdHgubGluZVdpZHRoID0gMC4xO1xyXG4gICAgdGhpcy5wb2x5KGN0eCwgW1swLjgsIDAuNDVdLCBbMC40LCAwXSwgWzAuOCwgLTAuNDVdXSk7XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguYXJjKDAuMjQsIDAsIDAuMjYsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgIGN0eC5hcmMoLTAuMSwgMCwgMC4yNiwgMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgY3R4LmFyYygtMC41NCwgMCwgMC40LCAwLCAyICogTWF0aC5QSSk7XHJcbiAgfSxcclxuICBjaXJjbGUgKGN0eCkgeyBjdHguYXJjKDAsIDAsIDEsIDAsIDIgKiBNYXRoLlBJKTsgfSxcclxuICBkYXJ0IChjdHgpIHsgdGhpcy5wb2x5KGN0eCwgW1sxLCAwXSwgWy0xLCAwLjhdLCBbLTAuNSwgMF0sIFstMSwgLTAuOF1dKTsgfSxcclxuICBmcmFtZSAoY3R4KSB7XHJcbiAgICBjb25zdCBpbnNldCA9IDAuNDtcclxuICAgIGN0eC5maWxsUmVjdCgtMSwgLTEsIDIsIDIpO1xyXG4gICAgY3R4LmZpbGwoKTtcclxuICAgIGN0eC5jbGVhclJlY3QoLTEgKyBpbnNldCwgLTEgKyBpbnNldCwgMiAtICgyICogaW5zZXQpLCAyIC0gKDIgKiBpbnNldCkpO1xyXG4gIH0sXHJcbiAgZnJhbWUyIChjdHgpIHtcclxuICAgIGNvbnN0IGluc2V0ID0gMC40O1xyXG4gICAgY3R4LmZpbGxSZWN0KC0xLCAtMSwgMiwgMik7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcclxuICAgIGN0eC5maWxsUmVjdCgtMSArIGluc2V0LCAtMSArIGluc2V0LCAyIC0gKDIgKiBpbnNldCksIDIgLSAoMiAqIGluc2V0KSk7XHJcbiAgfSxcclxuICAvLyBwZXJzb24gKGN0eCkge1xyXG4gIC8vICAgdGhpcy5wb2x5KGN0eCwgWyBbMC4zLCAtMC40XSwgWzAuNiwgMF0sIFswLjI1LCAwLjJdLCBbMC4yNSwgLTAuMV0sXHJcbiAgLy8gICBbMC4yLCAwLjNdLCBbMC41LCAxXSwgWzAuMSwgMV0sIFswLCAwLjVdLFxyXG4gIC8vICAgWy0wLjEsIDFdLCBbLTAuNSwgMV0sIFstMC4yLCAwLjNdLCBbLTAuMjUsIC0wLjFdLFxyXG4gIC8vICAgWy0wLjI1LCAwLjJdLCBbLTAuNiwgMF0sIFstMC4zLCAtMC40XV0pXHJcbiAgLy8gICBjdHguY2xvc2VQYXRoKClcclxuICAvLyAgIGN0eC5hcmMoMCwgLTAuNywgMC4zLCAwLCAyICogTWF0aC5QSSlcclxuICAvLyB9LFxyXG4gIHBlcnNvbiAoY3R4KSB7XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xyXG4gICAgdGhpcy5wZXJzb24yKGN0eCk7XHJcbiAgfSxcclxuICBwZXJzb24yIChjdHgpIHtcclxuICAgIHRoaXMucG9seShjdHgsIFsgWzAuMywgLTAuNF0sIFswLjYsIDBdLCBbMC4yNSwgMC4yXSwgWzAuMjUsIC0wLjFdLFxyXG4gICAgWzAuMiwgMC4zXSwgWzAuNSwgMV0sIFswLjEsIDFdLCBbMCwgMC41XSxcclxuICAgIFstMC4xLCAxXSwgWy0wLjUsIDFdLCBbLTAuMiwgMC4zXSwgWy0wLjI1LCAtMC4xXSxcclxuICAgIFstMC4yNSwgMC4yXSwgWy0wLjYsIDBdLCBbLTAuMywgLTAuNF1dKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGN0eC5maWxsKCk7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xyXG4gICAgY3R4LmFyYygwLCAtMC43LCAwLjMsIDAsIDIgKiBNYXRoLlBJKTtcclxuICB9LFxyXG4gIHJpbmcgKGN0eCkgeyAvLyB0cmFuc3BhcmVudFxyXG4gICAgY29uc3QgW3JPdXRlciwgcklubmVyXSA9IFsxLCAwLjZdO1xyXG4gICAgY3R4LmFyYygwLCAwLCByT3V0ZXIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XHJcbiAgICBjdHgubGluZVRvKHJJbm5lciwgMCk7XHJcbiAgICBjdHguYXJjKDAsIDAsIHJJbm5lciwgMCwgMiAqIE1hdGguUEksIHRydWUpO1xyXG4gIH0sXHJcbiAgcmluZzIgKGN0eCkgeyAvLyBmaWxlU3R5bGUgaXMgb3V0ZXIgY29sb3IsIHN0cm9rZVN0eWxlIGlubmVyIGNvbG9yXHJcbiAgICBjb25zdCBbck91dGVyLCBySW5uZXJdID0gWzEsIDAuNl07XHJcbiAgICBjdHguYXJjKDAsIDAsIHJPdXRlciwgMCwgMiAqIE1hdGguUEkpOyAvLyB4LCB5LCByLCBhbmcwLCBhbmcxLCBjY2xvY2t3aXNlXHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcclxuICAgIGN0eC5hcmMoMCwgMCwgcklubmVyLCAwLCAyICogTWF0aC5QSSk7IC8vIHgsIHksIHIsIGFuZzAsIGFuZzEsIGNjbG9ja3dpc2VcclxuICB9LFxyXG4gIHNxdWFyZSAoY3R4KSB7IGN0eC5maWxsUmVjdCgtMSwgLTEsIDIsIDIpOyB9LFxyXG4gIHRyaWFuZ2xlIChjdHgpIHsgdGhpcy5wb2x5KGN0eCwgW1sxLCAwXSwgWy0xLCAtMC44XSwgWy0xLCAwLjhdXSk7IH1cclxufTtcclxuXHJcbi8vIE1lc2hlcyB1c2VkIGJ5IHRoZSBUaHJlZS5qcyB2aWV3IG1vZHVsZVxyXG5cclxuLy8gVXRpbGl0eSBjbGFzc2VzIG1lYW50IHRvIGJlIHN1YmNsYXNzZWQ6XHJcblxyXG4vLyA9PT09PT09PT09PT09IEJhc2VNZXNoID09PT09PT09PT09PT1cclxuLy8gQW4gYWJzdHJhY3QgY2xhc3MgZm9yIGFsbCBNZXNoZXMuIEl0IG5lZWRzIHRoZSBwYXJ0aWN1bGFyIFRocmVlLmpzXHJcbi8vIGluc3RhbmNlIHRvIGFsbG93IGZvciBkaWZmZXJlbmNlcyBpbiBtb2RlbHMgb24gdGhlIHNhbWUgcGFnZS5cclxuY2xhc3MgQmFzZU1lc2ggeyAvLyBzdGF0aWMgb3B0aW9ucygpOiBodHRwczovL2dvby5nbC9zS2R4b1lcclxuICBjb25zdHJ1Y3RvciAodmlldywgb3B0aW9ucyA9IHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucygpKSB7XHJcbiAgICBjb25zdCB7IHNjZW5lLCBtb2RlbCB9ID0gdmlldztcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBzY2VuZSwgbW9kZWwsIHZpZXcsIG9wdGlvbnMgfSk7XHJcbiAgICB0aGlzLm1lc2ggPSBudWxsO1xyXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgdGhpcy5maXhlZENvbG9yID0gb3B0aW9ucy5jb2xvcjtcclxuICAgIHRoaXMuZml4ZWRTaXplID0gb3B0aW9ucy5wb2ludFNpemU7XHJcbiAgICB0aGlzLmZpeGVkU2hhcGUgPVxyXG4gICAgICAodGhpcy5uYW1lID09PSAnUGF0Y2hlc01lc2gnKSA/ICdQYXRjaCdcclxuICAgICAgOiAodGhpcy5uYW1lID09PSAnUG9pbnRzTWVzaCcpID8gJ1BvaW50J1xyXG4gICAgICA6ICh0aGlzLm5hbWUgPT09ICdMaW5rc01lc2gnKSA/ICdMaW5rJyA6IHVuZGVmaW5lZDtcclxuICAgIHRoaXMudXNlU3ByaXRlcyA9IHRoaXMubmFtZS5tYXRjaCgvc3ByaXRlcy9pKSAhPSBudWxsO1xyXG4gICAgLy8gQmFzZU1lc2gsXHJcbiAgICAvLyBDYW52YXNNZXNoLFxyXG4gICAgLy8gUGF0Y2hlc01lc2gsXHJcbiAgICAvLyBRdWFkU3ByaXRlc01lc2gsXHJcbiAgICAvLyBQb2ludHNNZXNoLFxyXG4gICAgLy8gTGlua3NNZXNoXHJcbiAgfVxyXG4gIGRpc3Bvc2UgKCkge1xyXG4gICAgaWYgKCF0aGlzLm1lc2gpIHJldHVyblxyXG4gICAgaWYgKHRoaXMubWVzaC5wYXJlbnQgIT09IHRoaXMuc2NlbmUpIGNvbnNvbGUubG9nKCdtZXNoIHBhcmVudCBub3Qgc2NlbmUnKTtcclxuICAgIHRoaXMubWVzaC5wYXJlbnQucmVtb3ZlKHRoaXMubWVzaCk7XHJcbiAgICB0aGlzLm1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgIGlmICh0aGlzLm1lc2gubWF0ZXJpYWwubWFwKSB0aGlzLm1lc2gubWF0ZXJpYWwubWFwLmRpc3Bvc2UoKTtcclxuICB9XHJcbiAgaW5pdCAoKSB7IHRocm93IEVycm9yKCdpbml0IGlzIGFic3RyYWN0LCBtdXN0IGJlIG92ZXJyaWRlbicpIH1cclxuICB1cGRhdGUgKCkgeyB0aHJvdyBFcnJvcigndXBkYXRlIGlzIGFic3RyYWN0LCBtdXN0IGJlIG92ZXJyaWRlbicpIH1cclxuXHJcbiAgLy8gVXRpbGl0aWVzXHJcbiAgY3JlYXRlUXVhZCAociwgeiA9IDApIHsgLy8gciBpcyByYWRpdXMgb2YgeHkgcXVhZDogWy1yLCtyXSwgeiBpcyBxdWFkIHpcclxuICAgIGNvbnN0IHZlcnRpY2VzID0gWy1yLCAtciwgeiwgciwgLXIsIHosIHIsIHIsIHosIC1yLCByLCB6XTtcclxuICAgIGNvbnN0IGluZGljZXMgPSBbMCwgMSwgMiwgMCwgMiwgM107XHJcbiAgICByZXR1cm4ge3ZlcnRpY2VzLCBpbmRpY2VzfVxyXG4gIH1cclxuICBnZXQgc3ByaXRlU2hlZXRUZXh0dXJlICgpIHtcclxuICAgIGlmICghdGhpcy5tb2RlbC5zcHJpdGVTaGVldC50ZXh0dXJlKSB7XHJcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuQ2FudmFzVGV4dHVyZSh0aGlzLm1vZGVsLnNwcml0ZVNoZWV0LmN0eC5jYW52YXMpO1xyXG4gICAgICB0aGlzLm1vZGVsLnNwcml0ZVNoZWV0LnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubW9kZWwuc3ByaXRlU2hlZXQudGV4dHVyZVxyXG4gIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PSBDYW52YXNNZXNoID09PT09PT09PT09PT1cclxuXHJcbmNsYXNzIENhbnZhc01lc2ggZXh0ZW5kcyBCYXNlTWVzaCB7XHJcbiAgaW5pdCAoY2FudmFzKSB7XHJcbiAgICBpZiAodGhpcy5tZXNoKSB0aGlzLmRpc3Bvc2UoKTtcclxuICAgIGNvbnN0IHt0ZXh0dXJlT3B0aW9ucywgen0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgY2FudmFzLCB6LCB0ZXh0dXJlT3B0aW9ucyB9KTtcclxuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBudW1YLCBudW1ZLCBjZW50ZXJYLCBjZW50ZXJZfSA9IHRoaXMubW9kZWwud29ybGQ7XHJcblxyXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5DYW52YXNUZXh0dXJlKGNhbnZhcyk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0ZXh0dXJlT3B0aW9ucykge1xyXG4gICAgICB0ZXh0dXJlW2tleV0gPSBUSFJFRVt0ZXh0dXJlT3B0aW9uc1trZXldXTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KHdpZHRoLCBoZWlnaHQsIG51bVgsIG51bVkpO1xyXG4gICAgZ2VvbWV0cnkudHJhbnNsYXRlKGNlbnRlclgsIGNlbnRlclksIDApO1xyXG5cclxuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcclxuICAgICAgbWFwOiB0ZXh0dXJlLFxyXG4gICAgICBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyxcclxuICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZSxcclxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICB0aGlzLm1lc2gucG9zaXRpb24ueiA9IHo7XHJcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpO1xyXG4gIH1cclxuICB1cGRhdGUgKCkge1xyXG4gICAgLy8gUkVNSU5EOiBoYXZlIGNhbnZhcyBvd25lciBzZXQgYSBmbGFnXHJcbiAgICB0aGlzLm1lc2gubWF0ZXJpYWwubWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFNldmVyYWwgY2xhc3NlcyBmb3IgcGF0Y2hlcywgdHVydGxlcywgbGlua3MsIGV0Yy5cclxuXHJcbi8vID09PT09PT09PT09PT0gRHJhd2luZ01lc2ggPT09PT09PT09PT09PVxyXG5cclxuLy8gRHJhd2luZyBtZXNoZXMgYXJlIGEgZm9ybSBvZiBDYW52YXMgTWVzaFxyXG5cclxuXHJcbi8vID09PT09PT09PT09PT0gUGF0Y2hlc01lc2ggPT09PT09PT09PT09PVxyXG5cclxuLy8gUGF0Y2ggbWVzaGVzIGFyZSBhIGZvcm0gb2YgQ2FudmFzIE1lc2hcclxuY2xhc3MgUGF0Y2hlc01lc2ggZXh0ZW5kcyBDYW52YXNNZXNoIHtcclxuICBzdGF0aWMgb3B0aW9ucyAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0dXJlT3B0aW9uczoge1xyXG4gICAgICAgIG1pbkZpbHRlcjogJ05lYXJlc3RGaWx0ZXInLFxyXG4gICAgICAgIG1hZ0ZpbHRlcjogJ05lYXJlc3RGaWx0ZXInXHJcbiAgICAgIH0sXHJcbiAgICAgIHo6IDEuMFxyXG4gICAgfVxyXG4gIH1cclxuICBpbml0IChwYXRjaGVzKSB7IC8vIFJFTUlORDogcGFzcyBpbiBwYXRjaGVzIGluc3RlYWQgb2YgY2FudmFzXHJcbiAgICBzdXBlci5pbml0KHBhdGNoZXMucGl4ZWxzLmN0eC5jYW52YXMpO1xyXG4gIH1cclxuICB1cGRhdGUgKHBhdGNoZXMpIHtcclxuICAgIHBhdGNoZXMuaW5zdGFsbFBpeGVscygpO1xyXG4gICAgc3VwZXIudXBkYXRlKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09IFF1YWRTcHJpdGVzTWVzaCA9PT09PT09PT09PT09XHJcblxyXG5jbGFzcyBRdWFkU3ByaXRlc01lc2ggZXh0ZW5kcyBCYXNlTWVzaCB7XHJcbiAgc3RhdGljIG9wdGlvbnMgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgejogMi4wXHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0cnVjdG9yICh2aWV3LCBvcHRpb25zKSB7XHJcbiAgICBzdXBlcih2aWV3LCBvcHRpb25zKTtcclxuICAgIHRoaXMudW5pdFF1YWQgPSB0aGlzLmNyZWF0ZVF1YWQoMC41LCAwKTtcclxuICB9XHJcbiAgaW5pdCAoKSB7XHJcbiAgICBpZiAodGhpcy5tZXNoKSB0aGlzLmRpc3Bvc2UoKTtcclxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnNwcml0ZVNoZWV0VGV4dHVyZTtcclxuXHJcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoKTtcclxuICAgIGNvbnN0IHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoKTtcclxuICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoKTtcclxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xyXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XHJcbiAgICBnZW9tZXRyeS5zZXRJbmRleChuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGluZGljZXMsIDEpKTtcclxuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcclxuICAgICAgbWFwOiB0ZXh0dXJlLCBhbHBoYVRlc3Q6IDAuNSwgc2lkZTogVEhSRUUuRG91YmxlU2lkZX0pO1xyXG5cclxuICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICB0aGlzLm1lc2gucG9zaXRpb24ueiA9IHRoaXMub3B0aW9ucy56O1xyXG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5tZXNoKTtcclxuICB9XHJcbiAgLy8gdXBkYXRlIHRha2VzIGFueSBhcnJheSBvZiBvYmplY3RzIHdpdGggeCx5LHosc2l6ZSxzcHJpdGUgLi4gcG9zaXRpb24gJiB1dnNcclxuICAvLyBSRU1JTkQ6IG9wdGltaXplIGJ5IGZsYWdzIGZvciBwb3NpdGlvbi91dnMgbmVlZCB1cGRhdGVzXHJcbiAgdXBkYXRlICh0dXJ0bGVzKSB7XHJcbiAgICBjb25zdCBtZXNoID0gdGhpcy5tZXNoO1xyXG4gICAgY29uc3QgeyB2ZXJ0aWNlcywgaW5kaWNlcyB9ID0gdGhpcy51bml0UXVhZDtcclxuICAgIGNvbnN0IHBhdGNoU2l6ZSA9IHRoaXMubW9kZWwud29ybGQucGF0Y2hTaXplO1xyXG4gICAgY29uc3QgcG9zaXRpb25BdHRyaWIgPSBtZXNoLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcclxuICAgIGNvbnN0IHV2QXR0cmliID0gbWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3V2Jyk7XHJcbiAgICBjb25zdCBpbmRleEF0dHJpYiA9IG1lc2guZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcclxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMubGVuZ3RoICogdHVydGxlcy5sZW5ndGgpO1xyXG4gICAgY29uc3QgdXZzID0gW107XHJcbiAgICBjb25zdCBpbmRleGVzID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0dXJ0bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHR1cnRsZSA9IHR1cnRsZXNbaV07XHJcbiAgICAgIGlmICh0dXJ0bGUuc3ByaXRlLm5lZWRzVXBkYXRlKSB0dXJ0bGUuc2V0U3ByaXRlKCk7XHJcbiAgICAgIGNvbnN0IHNpemUgPSB0dXJ0bGUuc2l6ZTsgLy8gKiBwYXRjaFNpemVcclxuICAgICAgY29uc3QgdGhldGEgPSB0dXJ0bGUudGhldGE7XHJcbiAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHRoZXRhKTtcclxuICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4odGhldGEpO1xyXG4gICAgICBjb25zdCBvZmZzZXQgPSBpICogdmVydGljZXMubGVuZ3RoO1xyXG5cclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2ZXJ0aWNlcy5sZW5ndGg7IGogPSBqICsgMykge1xyXG4gICAgICAgIGNvbnN0IHgwID0gdmVydGljZXNbal07XHJcbiAgICAgICAgY29uc3QgeTAgPSB2ZXJ0aWNlc1tqICsgMV07XHJcbiAgICAgICAgY29uc3QgeCA9IHR1cnRsZS54OyAvLyAqIHBhdGNoU2l6ZVxyXG4gICAgICAgIGNvbnN0IHkgPSB0dXJ0bGUueTsgLy8gKiBwYXRjaFNpemVcclxuICAgICAgICBwb3NpdGlvbnNbaiArIG9mZnNldF0gPSAoc2l6ZSAqICh4MCAqIGNvcyAtIHkwICogc2luKSArIHgpICogcGF0Y2hTaXplO1xyXG4gICAgICAgIHBvc2l0aW9uc1tqICsgb2Zmc2V0ICsgMV0gPSAoc2l6ZSAqICh4MCAqIHNpbiArIHkwICogY29zKSArIHkpICogcGF0Y2hTaXplO1xyXG4gICAgICAgIHBvc2l0aW9uc1tqICsgb2Zmc2V0ICsgMl0gPSB0dXJ0bGUueiAqIHBhdGNoU2l6ZTtcclxuICAgICAgfVxyXG4gICAgICBpbmRleGVzLnB1c2goLi4uaW5kaWNlcy5tYXAoKGl4KSA9PiBpeCArIChpICogNCkpKTsgLy8gNFxyXG4gICAgICB1dnMucHVzaCguLi50dXJ0bGUuc3ByaXRlLnV2cyk7XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbkF0dHJpYi5zZXRBcnJheShwb3NpdGlvbnMpO1xyXG4gICAgcG9zaXRpb25BdHRyaWIubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgdXZBdHRyaWIuc2V0QXJyYXkobmV3IEZsb2F0MzJBcnJheSh1dnMpKTtcclxuICAgIHV2QXR0cmliLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIGluZGV4QXR0cmliLnNldEFycmF5KG5ldyBVaW50MzJBcnJheShpbmRleGVzKSk7XHJcbiAgICBpbmRleEF0dHJpYi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09IFBvaW50c01lc2ggPT09PT09PT09PT09PVxyXG5cclxuY2xhc3MgUG9pbnRzTWVzaCBleHRlbmRzIEJhc2VNZXNoIHtcclxuICBzdGF0aWMgb3B0aW9ucyAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwb2ludFNpemU6IDEsXHJcbiAgICAgIGNvbG9yOiBudWxsLFxyXG4gICAgICB6OiAyLjBcclxuICAgIH1cclxuICB9XHJcbiAgaW5pdCAoKSB7XHJcbiAgICBpZiAodGhpcy5tZXNoKSB0aGlzLmRpc3Bvc2UoKTtcclxuICAgIGNvbnN0IHBvaW50U2l6ZSA9IHRoaXMub3B0aW9ucy5wb2ludFNpemUgKiB0aGlzLm1vZGVsLndvcmxkLnBhdGNoU2l6ZTtcclxuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yID8gbmV3IFRIUkVFLkNvbG9yKC4uLnRoaXMub3B0aW9ucy5jb2xvcikgOiBudWxsO1xyXG5cclxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyxcclxuICAgICAgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KCksIDMpKTtcclxuICAgIGlmIChjb2xvciA9PSBudWxsKVxyXG4gICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2NvbG9yJyxcclxuICAgICAgICBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoKSwgMykpO1xyXG5cclxuICAgIGNvbnN0IG1hdGVyaWFsID0gY29sb3JcclxuICAgID8gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHtzaXplOiBwb2ludFNpemUsIGNvbG9yOiBjb2xvcn0pXHJcbiAgICA6IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7c2l6ZTogcG9pbnRTaXplLCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9yc30pO1xyXG5cclxuICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgIHRoaXMubWVzaC5wb3NpdGlvbi56ID0gdGhpcy5vcHRpb25zLno7XHJcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpO1xyXG4gIH1cclxuICAvLyB1cGRhdGUgdGFrZXMgYW55IGFycmF5IG9mIG9iamVjdHMgd2l0aCB4LHkseixjb2xvciAuLiBwb3NpdGlvbiAmIGNvbG9yXHJcbiAgLy8gSWYgbm9uLW51bGwgY29sb3IgcGFzc2VkIHRvIGluaXQsIG9ubHkgeCx5LHogLi4gcG9zaXRpb24gdXNlZFxyXG4gIC8vIFJFTUlORDogb3B0aW1pemUgYnkgZmxhZ3MgZm9yIHBvc2l0aW9uL3V2cyBuZWVkIHVwZGF0ZXNcclxuICB1cGRhdGUgKHR1cnRsZXMpIHtcclxuICAgIGNvbnN0IHBvc2l0aW9uQXR0cmliID0gdGhpcy5tZXNoLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcclxuICAgIC8vIGNvbnN0IHBvc2l0aW9uQnVmZiA9IHBvc2l0aW9uQXR0cmliLmFycmF5XHJcbiAgICBjb25zdCBjb2xvckF0dHJpYiA9IHRoaXMubWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XHJcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xyXG4gICAgY29uc3QgY29sb3JzID0gY29sb3JBdHRyaWIgPT0gbnVsbCA/IG51bGwgOiBbXTtcclxuICAgIGNvbnN0IHBhdGNoU2l6ZSA9IHRoaXMubW9kZWwud29ybGQucGF0Y2hTaXplO1xyXG5cclxuICAgIC8vIGNvbnN0IHJlZCA9IFsxLCAwLCAwXSAvLyBSRU1JTkQ6IGFkZCBjb2xvci9zaGFwZSB0byB0dXJ0bGVzXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0dXJ0bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHt4LCB5LCB6LCBjb2xvcn0gPSB0dXJ0bGVzW2ldO1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKHggKiBwYXRjaFNpemUsIHkgKiBwYXRjaFNpemUsIHogKiBwYXRjaFNpemUpO1xyXG4gICAgICAvLyBpZiAoY29sb3JzICE9IG51bGwpIGNvbG9ycy5wdXNoKC4uLnJlZClcclxuICAgICAgaWYgKGNvbG9ycyAhPSBudWxsKSBjb2xvcnMucHVzaCguLi5jb2xvci53ZWJnbCk7XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbkF0dHJpYi5zZXRBcnJheShuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKSk7XHJcbiAgICBwb3NpdGlvbkF0dHJpYi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICBpZiAoY29sb3JzKSB7XHJcbiAgICAgIGNvbG9yQXR0cmliLnNldEFycmF5KG5ldyBGbG9hdDMyQXJyYXkoY29sb3JzKSk7XHJcbiAgICAgIGNvbG9yQXR0cmliLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT0gTGlua3NNZXNoID09PT09PT09PT09PT1cclxuXHJcbmNsYXNzIExpbmtzTWVzaCBleHRlbmRzIEJhc2VNZXNoIHtcclxuICBzdGF0aWMgb3B0aW9ucyAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb2xvcjogbnVsbCxcclxuICAgICAgejogMS41XHJcbiAgICB9XHJcbiAgfVxyXG4gIGluaXQgKCkge1xyXG4gICAgaWYgKHRoaXMubWVzaCkgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICBjb25zdCBjb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvciA/IG5ldyBUSFJFRS5Db2xvciguLi50aGlzLm9wdGlvbnMuY29sb3IpIDogbnVsbDtcclxuXHJcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG4gICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdwb3NpdGlvbicsXHJcbiAgICAgIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSgpLCAzKSk7XHJcbiAgICBpZiAoY29sb3IgPT0gbnVsbClcclxuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdjb2xvcicsXHJcbiAgICAgICAgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KCksIDMpKTtcclxuXHJcbiAgICBjb25zdCBtYXRlcmlhbCA9IGNvbG9yXHJcbiAgICAgID8gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtjb2xvcjogY29sb3J9KVxyXG4gICAgICA6IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7dmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnN9KTtcclxuICAgIC8vIGNvbnN0IG1hdGVyaWFsID0gY29sb3JcclxuICAgIC8vID8gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHtzaXplOiBwb2ludFNpemUsIGNvbG9yOiBjb2xvcn0pXHJcbiAgICAvLyA6IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7c2l6ZTogcG9pbnRTaXplLCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9yc30pXHJcblxyXG4gICAgdGhpcy5tZXNoID0gbmV3IFRIUkVFLkxpbmVTZWdtZW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xyXG4gICAgdGhpcy5tZXNoLnBvc2l0aW9uLnogPSB0aGlzLm9wdGlvbnMuejtcclxuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMubWVzaCk7XHJcbiAgfVxyXG4gIC8vIHVwZGF0ZSB0YWtlcyBhbnkgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGNvbG9yICYgZW5kMCwgZW5kMSBoYXZpbmcgeCx5LHpcclxuICAvLyBSRU1JTkQ6IG9wdGltaXplIGJ5IGZsYWdzIGZvciBwb3NpdGlvbi91dnMgbmVlZCB1cGRhdGVzXHJcbiAgdXBkYXRlIChsaW5rcykge1xyXG4gICAgY29uc3QgdmVydGljZXMgPSBbXTtcclxuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMub3B0aW9ucy5jb2xvciA/IG51bGwgOiBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qge2VuZDAsIGVuZDEsIGNvbG9yfSA9IGxpbmtzW2ldO1xyXG4gICAgICBjb25zdCB7eDogeDAsIHk6IHkwLCB6OiB6MH0gPSBlbmQwO1xyXG4gICAgICBjb25zdCB7eDogeDEsIHk6IHkxLCB6OiB6MX0gPSBlbmQxO1xyXG4gICAgICBjb25zdCBwcyA9IHRoaXMubW9kZWwud29ybGQucGF0Y2hTaXplO1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKHgwICogcHMsIHkwICogcHMsIHowICogcHMsIHgxICogcHMsIHkxICogcHMsIHoxICogcHMpO1xyXG4gICAgICBpZiAoY29sb3JzKVxyXG4gICAgICAgIGNvbG9ycy5wdXNoKC4uLmNvbG9yLndlYmdsLCAuLi5jb2xvci53ZWJnbCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb3NpdGlvbkF0dHJpYiA9IHRoaXMubWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XHJcbiAgICBwb3NpdGlvbkF0dHJpYi5zZXRBcnJheShuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKSk7XHJcbiAgICBwb3NpdGlvbkF0dHJpYi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICBpZiAoY29sb3JzKSB7XHJcbiAgICAgIGNvbnN0IGNvbG9yQXR0cmliID0gdGhpcy5tZXNoLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKTtcclxuICAgICAgY29sb3JBdHRyaWIuc2V0QXJyYXkobmV3IEZsb2F0MzJBcnJheShjb2xvcnMpKTtcclxuICAgICAgY29sb3JBdHRyaWIubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIE1lc2hlcyA9IHtcclxuICBCYXNlTWVzaCxcclxuICBDYW52YXNNZXNoLFxyXG4gIFBhdGNoZXNNZXNoLFxyXG4gIFF1YWRTcHJpdGVzTWVzaCxcclxuICBQb2ludHNNZXNoLFxyXG4gIExpbmtzTWVzaFxyXG59O1xyXG5cclxuLy8gaW1wb3J0IFNwcml0ZVNoZWV0IGZyb20gJy4vU3ByaXRlU2hlZXQuanMnXHJcbndpbmRvdy5NZXNoZXMgPSBNZXNoZXM7IC8vIFJFTUlORFxyXG5cclxuY2xhc3MgVGhyZWUge1xyXG4gIHN0YXRpYyBkZWZhdWx0T3B0aW9ucyAodXNlVGhyZWVIZWxwZXJzID0gdHJ1ZSwgdXNlVUlIZWxwZXJzID0gdHJ1ZSkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgIC8vIGluY2x1ZGUgbWUgaW4gb3B0aW9ucyBzbyBNb2RlbCBjYW4gaW5zdGFuY2lhdGUgbWUhXHJcbiAgICAgIFJlbmRlcmVyOiBUaHJlZSwgLy8gUkVNSU5EOiB1c2Ugc3RyaW5nLlxyXG4gICAgICBvcnRob1ZpZXc6IGZhbHNlLCAgICAgICAgICAgICAvLyAnUGVyc3BlY3RpdmUnLCAnT3J0aG9ncmFwaGljJ1xyXG4gICAgICBjbGVhckNvbG9yOiAweDAwMDAwMCwgICAgICAgICAvLyBjbGVhciB0byBibGFja1xyXG4gICAgICB1c2VBeGVzOiB1c2VUaHJlZUhlbHBlcnMsICAgICAvLyBzaG93IHgseSx6IGF4ZXNcclxuICAgICAgdXNlR3JpZDogdXNlVGhyZWVIZWxwZXJzLCAgICAgLy8gc2hvdyB4LHkgcGxhbmVcclxuICAgICAgdXNlQ29udHJvbHM6IHVzZVRocmVlSGVscGVycywgLy8gbmF2aWdhdGlvbi4gUkVNSU5EOiBjb250cm9sIG5hbWU/XHJcbiAgICAgIHVzZVN0YXRzOiB1c2VVSUhlbHBlcnMsICAgICAgIC8vIHNob3cgZnBzIHdpZGdldFxyXG4gICAgICB1c2VHVUk6IHVzZVVJSGVscGVycywgICAgICAgICAvLyBhY3RpdmF0ZSBkYXQuZ3VpIFVJXHJcbiAgICAgIC8vIG1lc2hlczoge1xyXG4gICAgICBwYXRjaGVzOiB7XHJcbiAgICAgICAgbWVzaENsYXNzOiAnUGF0Y2hlc01lc2gnXHJcbiAgICAgIH0sXHJcbiAgICAgIHR1cnRsZXM6IHtcclxuICAgICAgICBtZXNoQ2xhc3M6ICdRdWFkU3ByaXRlc01lc2gnXHJcbiAgICAgICAgLy8gbWVzaENsYXNzOiAnUG9pbnRzTWVzaCdcclxuICAgICAgfSxcclxuICAgICAgbGlua3M6IHtcclxuICAgICAgICBtZXNoQ2xhc3M6ICdMaW5rc01lc2gnXHJcbiAgICAgIH1cclxuICAgICAgLy8gfVxyXG4gICAgfTtcclxuICAgIC8vIHV0aWwuZm9yRWFjaChvcHRpb25zLm1lc2hlcywgKHZhbCwga2V5KSA9PiB7XHJcbiAgICAvLyAgIGNvbnN0IE1lc2ggPSBNZXNoZXNbdmFsLm1lc2hDbGFzc11cclxuICAgIC8vICAgY29uc3QgbWVzaE9wdGlvbnMgPSBNZXNoLm9wdGlvbnMoKVxyXG4gICAgLy8gICB2YWwub3B0aW9ucyA9IG1lc2hPcHRpb25zXHJcbiAgICAvLyB9KVxyXG4gICAgdXRpbC5mb3JFYWNoKG9wdGlvbnMsICh2YWwsIGtleSkgPT4ge1xyXG4gICAgICBpZiAodmFsLm1lc2hDbGFzcykge1xyXG4gICAgICAgIGNvbnN0IE1lc2ggPSBNZXNoZXNbdmFsLm1lc2hDbGFzc107XHJcbiAgICAgICAgY29uc3QgbWVzaE9wdGlvbnMgPSBNZXNoLm9wdGlvbnMoKTtcclxuICAgICAgICB2YWwub3B0aW9ucyA9IG1lc2hPcHRpb25zO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gb3B0aW9uc1xyXG4gIH1cclxuICBzdGF0aWMgcHJpbnRNZXNoT3B0aW9ucyAoKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGZvciAoY29uc3QgTWVzaE5hbWUgaW4gTWVzaGVzKSB7XHJcbiAgICAgIGNvbnN0IG9wdGlvbnNGY24gPSBNZXNoZXNbTWVzaE5hbWVdLm9wdGlvbnM7XHJcbiAgICAgIGlmIChvcHRpb25zRmNuKSB7XHJcbiAgICAgICAgb2JqW01lc2hOYW1lXSA9IHtcclxuICAgICAgICAgIG9wdGlvbnM6IE1lc2hlc1tNZXNoTmFtZV0ub3B0aW9ucygpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RyID0gdXRpbC5vYmplY3RUb1N0cmluZyhvYmopO1xyXG4gICAgY29uc29sZS5sb2coc3RyKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yIChtb2RlbCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAvLyB0aGlzLnNwcml0ZVNoZWV0ID0gbW9kZWwuc3ByaXRlU2hlZXQgLy8gUkVNSU5EOiBUZW1wXHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBvcHRpb25zXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIFRocmVlLmRlZmF1bHRPcHRpb25zKTsgLy8gaW5zdGFsbCBkZWZhdWx0c1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTsgLy8gb3ZlcnJpZGUgZGVmYXVsdHNcclxuICAgIGlmICh0aGlzLlJlbmRlcmVyICE9PSBUaHJlZSlcclxuICAgICAgdGhyb3cgRXJyb3IoJ1RocmVlIGN0b3I6IFJlbmRlcmVyIG5vdCBUaHJlZScsIHRoaXMucmVuZGVyZXIpXHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBUaHJlZS5qc1xyXG4gICAgdGhpcy5pbml0VGhyZWUoKTtcclxuICAgIHRoaXMuaW5pdFRocmVlSGVscGVycygpO1xyXG4gIH1cclxuICAvLyBJbml0IFRocmVlLmpzIGNvcmU6IHNjZW5lLCBjYW1lcmEsIHJlbmRlcmVyXHJcbiAgaW5pdFRocmVlICgpIHtcclxuICAgIGNvbnN0IHtjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0fSA9IHRoaXMubW9kZWwuZGl2O1xyXG4gICAgY29uc3Qge29ydGhvVmlldywgY2xlYXJDb2xvcn0gPSB0aGlzO1xyXG4gICAgLy8gY29uc3Qge3dpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlcll9ID0gdGhpcy5tb2RlbC53b3JsZFxyXG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5tb2RlbC53b3JsZDtcclxuICAgIGNvbnN0IFtoYWxmVywgaGFsZkhdID0gW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMl07XHJcblxyXG4gICAgLy8gdGhpcy5zcHJpdGVTaGVldC50ZXh0dXJlID0gbmV3IFRIUkVFLkNhbnZhc1RleHR1cmUodGhpcy5zcHJpdGVTaGVldC5jdHgpXHJcbiAgICAvLyB0aGlzLnNwcml0ZVNoZWV0LnNldFRleHR1cmUoVEhSRUUuQ2FudmFzVGV4dHVyZSlcclxuXHJcbiAgICAvLyBSRU1JTkQ6IG5lZWQgd29ybGQubWluWi9tYXhaXHJcbiAgICBjb25zdCBvcnRob2dyYXBoaWNDYW0gPVxyXG4gICAgICBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC1oYWxmVywgaGFsZlcsIGhhbGZILCAtaGFsZkgsIDEsIDIwICogd2lkdGgpO1xyXG4gICAgb3J0aG9ncmFwaGljQ2FtLnBvc2l0aW9uLnNldCgwLCAwLCAxMCAqIHdpZHRoKTtcclxuICAgIG9ydGhvZ3JhcGhpY0NhbS51cC5zZXQoMCwgMCwgMSk7XHJcblxyXG4gICAgY29uc3QgcGVyc3BlY3RpdmVDYW0gPVxyXG4gICAgICBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsIGNsaWVudFdpZHRoIC8gY2xpZW50SGVpZ2h0LCAxLCAxMDAwMCk7XHJcbiAgICAvLyBwZXJzcGVjdGl2ZUNhbS5wb3NpdGlvbi5zZXQod2lkdGggKyBjZW50ZXJYLCAtd2lkdGggLSBjZW50ZXJZLCB3aWR0aClcclxuICAgIHBlcnNwZWN0aXZlQ2FtLnBvc2l0aW9uLnNldCh3aWR0aCwgLXdpZHRoLCB3aWR0aCk7XHJcbiAgICAvLyBwZXJzcGVjdGl2ZUNhbS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoY2VudGVyWCwgY2VudGVyWSwgMCkpXHJcbiAgICBwZXJzcGVjdGl2ZUNhbS51cC5zZXQoMCwgMCwgMSk7XHJcblxyXG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuICAgIC8vIHNjZW5lLnBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoY2VudGVyWCwgY2VudGVyWSwgMClcclxuICAgIGNvbnN0IGNhbWVyYSA9IG9ydGhvVmlldyA/IG9ydGhvZ3JhcGhpY0NhbSA6IHBlcnNwZWN0aXZlQ2FtO1xyXG5cclxuICAgIC8vIGlmIChvcnRob1ZpZXcpXHJcbiAgICAvLyAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMTAwICogd2lkdGgpXHJcbiAgICAvLyBlbHNlXHJcbiAgICAvLyAgIGNhbWVyYS5wb3NpdGlvbi5zZXQod2lkdGgsIC13aWR0aCwgd2lkdGgpXHJcbiAgICAvLyBjYW1lcmEudXAuc2V0KDAsIDAsIDEpXHJcblxyXG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xyXG4gICAgcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XHJcbiAgICByZW5kZXJlci5zZXRTaXplKGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQpO1xyXG4gICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihjbGVhckNvbG9yKTtcclxuICAgIHRoaXMubW9kZWwuZGl2LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG5cclxuICAgIC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XHJcbiAgICAvLyAgIGNvbnN0IHtjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0fSA9IHRoaXMubW9kZWwuZGl2XHJcbiAgICAvLyAgIGNhbWVyYS5hc3BlY3QgPSBjbGllbnRXaWR0aCAvIGNsaWVudEhlaWdodFxyXG4gICAgLy8gICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpXHJcbiAgICAvLyAgIHJlbmRlcmVyLnNldFNpemUoY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodClcclxuICAgIC8vIH0pXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4geyB0aGlzLnJlc2l6ZSgpOyB9KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtzY2VuZSwgY2FtZXJhLCByZW5kZXJlciwgb3J0aG9ncmFwaGljQ2FtLCBwZXJzcGVjdGl2ZUNhbX0pO1xyXG4gIH1cclxuICByZXNpemUgKCkge1xyXG4gICAgY29uc3Qge2NsaWVudFdpZHRoLCBjbGllbnRIZWlnaHR9ID0gdGhpcy5tb2RlbC5kaXY7XHJcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLm1vZGVsLndvcmxkO1xyXG5cclxuICAgIGlmICh0aGlzLm9ydGhvVmlldykge1xyXG4gICAgICBjb25zdCB6b29tID0gTWF0aC5taW4oY2xpZW50V2lkdGggLyB3aWR0aCwgY2xpZW50SGVpZ2h0IC8gaGVpZ2h0KTtcclxuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHpvb20gKiB3aWR0aCwgem9vbSAqIGhlaWdodCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNhbWVyYS5hc3BlY3QgPSBjbGllbnRXaWR0aCAvIGNsaWVudEhlaWdodDtcclxuICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUoY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRvZ2dsZUNhbWVyYSAoKSB7XHJcbiAgICB0aGlzLm9ydGhvVmlldyA9ICF0aGlzLm9ydGhvVmlldztcclxuICAgIGlmICh0aGlzLm9ydGhvVmlldykge1xyXG4gICAgICB0aGlzLmNhbWVyYSA9IHRoaXMub3J0aG9ncmFwaGljQ2FtO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jYW1lcmEgPSB0aGlzLnBlcnNwZWN0aXZlQ2FtO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZXNpemUoKTtcclxuICB9XHJcbiAgLy8gUmV0dXJuIGEgZGF0YVVSTCBmb3IgdGhlIGN1cnJlbnQgbW9kZWwgc3RlcC5cclxuICBzbmFwc2hvdCAodXNlT3J0aG8gPSB0cnVlKSB7XHJcbiAgICAvLyBEb24ndCBzZXQgY2FtZXJhLCBjYW4gY2hhbmdlIHcvIHRvZ2dsZSBiZWxvd1xyXG4gICAgY29uc3Qge3NjZW5lLCByZW5kZXJlciwgbW9kZWx9ID0gdGhpcztcclxuICAgIGNvbnN0IHRvZ2dsZSA9IHVzZU9ydGhvICYmIHRoaXMuY2FtZXJhID09PSB0aGlzLnBlcnNwZWN0aXZlQ2FtO1xyXG5cclxuICAgIGlmICh0b2dnbGUpIHsgdGhpcy50b2dnbGVDYW1lcmEoKTsgbW9kZWwuZHJhdyh0cnVlKTsgfVxyXG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCB0aGlzLmNhbWVyYSk7XHJcbiAgICBjb25zdCBkdXJsID0gcmVuZGVyZXIuZG9tRWxlbWVudC50b0RhdGFVUkwoKTtcclxuICAgIGlmICh0b2dnbGUpIHRoaXMudG9nZ2xlQ2FtZXJhKCk7XHJcbiAgICByZXR1cm4gZHVybFxyXG4gIH1cclxuICBpbml0VGhyZWVIZWxwZXJzICgpIHtcclxuICAgIGNvbnN0IHtzY2VuZSwgcmVuZGVyZXIsIGNhbWVyYX0gPSB0aGlzO1xyXG4gICAgY29uc3Qge3VzZUF4ZXMsIHVzZUdyaWQsIHVzZUNvbnRyb2xzLCB1c2VTdGF0cywgdXNlR1VJfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7d2lkdGh9ID0gdGhpcy5tb2RlbC53b3JsZDtcclxuICAgIGNvbnN0IGhlbHBlcnMgPSB7fTtcclxuXHJcbiAgICBpZiAodXNlQXhlcykge1xyXG4gICAgICBoZWxwZXJzLmF4ZXMgPSBuZXcgVEhSRUUuQXhpc0hlbHBlcigxLjUgKiB3aWR0aCAvIDIpO1xyXG4gICAgICBzY2VuZS5hZGQoaGVscGVycy5heGVzKTtcclxuICAgIH1cclxuICAgIGlmICh1c2VHcmlkKSB7XHJcbiAgICAgIGhlbHBlcnMuZ3JpZCA9IG5ldyBUSFJFRS5HcmlkSGVscGVyKDEuMjUgKiB3aWR0aCwgMTApO1xyXG4gICAgICBoZWxwZXJzLmdyaWQucm90YXRpb24ueCA9IFRIUkVFLk1hdGguZGVnVG9SYWQoOTApO1xyXG4gICAgICBzY2VuZS5hZGQoaGVscGVycy5ncmlkKTtcclxuICAgIH1cclxuICAgIGlmICh1c2VDb250cm9scykge1xyXG4gICAgICBoZWxwZXJzLmNvbnRyb2xzID0gbmV3IFRIUkVFLk9yYml0Q29udHJvbHMoY2FtZXJhLCByZW5kZXJlci5kb21FbGVtZW50KTtcclxuICAgIH1cclxuICAgIGlmICh1c2VTdGF0cykge1xyXG4gICAgICBoZWxwZXJzLnN0YXRzID0gbmV3IFN0YXRzKCk7XHJcbiAgICAgIC8vIFRoaXMgZG9lcyBub3Qgd29yazogaGVscGVycy5zdGF0cy5kb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGVscGVycy5zdGF0cy5kb20pO1xyXG4gICAgfVxyXG4gICAgaWYgKHVzZUdVSSkge1xyXG4gICAgICBoZWxwZXJzLmd1aSA9IG5ldyBkYXQuR1VJKCk7IC8vIGF1dG8gYWRkcyB0byBib2R5LCBhcHBlbmRDaGlsZCBub3QgbmVlZGVkXHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBoZWxwZXJzKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENsYXNzIE1vZGVsIGlzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBmb3IgbW9kZWxlcnMsIGludGVncmF0aW5nXHJcbi8vIGFsbCB0aGUgcGFydHMgb2YgYSBtb2RlbC4gSXQgYWxzbyBjb250YWlucyBOZXRMb2dvJ3MgYG9ic2VydmVyYCBtZXRob2RzLlxyXG5jbGFzcyBNb2RlbCB7XHJcbiAgLy8gU3RhdGljIGNsYXNzIG1ldGhvZHMgZm9yIGRlZmF1bHQgc2V0dGluZ3MuXHJcbiAgLy8gRGVmYXVsdCB3b3JsZCBpcyBjZW50ZXJlZCwgcGF0Y2hTaXplID0gMTMsIG1pbi9tYXggPSAxNlxyXG4gIHN0YXRpYyBkZWZhdWx0V29ybGQgKHNpemUgPSAxMywgbWF4ID0gMTYpIHtcclxuICAgIHJldHVybiBXb3JsZC5kZWZhdWx0T3B0aW9ucyhzaXplLCBtYXgpXHJcbiAgfVxyXG4gIC8vIERlZmF1bHQgcmVuZGVyZXIgaXMgVGhyZWUuanNcclxuICBzdGF0aWMgZGVmYXVsdFJlbmRlcmVyICgpIHtcclxuICAgIHJldHVybiBUaHJlZS5kZWZhdWx0T3B0aW9ucygpXHJcbiAgfVxyXG4gIHN0YXRpYyBwcmludERlZmF1bHRWaWV3T3B0aW9ucyAoKSB7XHJcbiAgICBUaHJlZS5wcmludE1lc2hPcHRpb25zKCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgTW9kZWwgY29uc3RydWN0b3IgdGFrZXMgYSBET00gZGl2IGFuZCBtb2RlbCBhbmQgcmVuZGVyZXIgb3B0aW9ucy5cclxuICAvLyBEZWZhdWx0IHZhbHVlcyBhcmUgZ2l2ZW4gZm9yIGFsbCBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXHJcbiAgY29uc3RydWN0b3IgKGRpdiA9IGRvY3VtZW50LmJvZHksXHJcbiAgICAgICAgICAgICAgIHdvcmxkT3B0aW9ucyA9IE1vZGVsLmRlZmF1bHRXb3JsZCgpLFxyXG4gICAgICAgICAgICAgICByZW5kZXJlck9wdGlvbnMgPSBNb2RlbC5kZWZhdWx0UmVuZGVyZXIoKSkge1xyXG4gICAgLy8gU3RvcmUgYW5kIGluaXRpYWxpemUgdGhlIG1vZGVsJ3MgZGl2IGFuZCBjb250ZXh0cy5cclxuICAgIHRoaXMuZGl2ID0gdXRpbC5pc1N0cmluZyhkaXYpID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2KSA6IGRpdjtcclxuICAgIHRoaXMuc3ByaXRlU2hlZXQgPSBuZXcgU3ByaXRlU2hlZXQoKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhpcyBtb2RlbCdzIGB3b3JsZGAgb2JqZWN0XHJcbiAgICB0aGlzLndvcmxkID0gbmV3IFdvcmxkKHdvcmxkT3B0aW9ucyk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB2aWV3XHJcbiAgICB0aGlzLnZpZXcgPSBuZXcgcmVuZGVyZXJPcHRpb25zLlJlbmRlcmVyKHRoaXMsIHJlbmRlcmVyT3B0aW9ucyk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBtZXNoZXMuXHJcbiAgICB0aGlzLm1lc2hlcyA9IHt9O1xyXG4gICAgdXRpbC5mb3JFYWNoKHJlbmRlcmVyT3B0aW9ucywgKHZhbCwga2V5KSA9PiB7XHJcbiAgICAgIGlmICh2YWwubWVzaENsYXNzKSB7XHJcbiAgICAgICAgY29uc3QgTWVzaCA9IE1lc2hlc1t2YWwubWVzaENsYXNzXTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gTWVzaC5vcHRpb25zKCk7IC8vIGRlZmF1bHQgb3B0aW9uc1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdmFsLm9wdGlvbnMpOyAvLyBvdmVycmlkZSBieSB1c2VyJ3NcclxuICAgICAgICBpZiAob3B0aW9ucy5jb2xvcikgLy8gY29udmVydCBvcHRpb25zLmNvbG9yIHJnYiBhcnJheSB0byBDb2xvci5cclxuICAgICAgICAgIG9wdGlvbnMuY29sb3IgPSBDb2xvci50b0NvbG9yKG5ldyBGbG9hdDMyQXJyYXkob3B0aW9ucy5jb2xvcikpO1xyXG4gICAgICAgIHRoaXMubWVzaGVzW2tleV0gPSBuZXcgTWVzaGVzW3ZhbC5tZXNoQ2xhc3NdKHRoaXMudmlldywgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbmltYXRvciB0byBoYW5kbGUgZHJhdy9zdGVwLlxyXG4gICAgdGhpcy5hbmltID0gbmV3IEFuaW1hdG9yKHRoaXMpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgbW9kZWwgY2FsbGluZyBgc3RhcnR1cGAsIGByZXNldGAgLi4gd2hpY2ggY2FsbHMgYHNldHVwYC5cclxuICAgIC8vIHRoaXMubW9kZWxSZWFkeSA9IGZhbHNlXHJcbiAgICAvLyB0aGlzLnN0YXJ0dXAoKS50aGVuKCgpID0+IHtcclxuICAgIC8vICAgLy8gdGhpcy5yZXNldCgpOyB0aGlzLnNldHVwKCk7IHRoaXMubW9kZWxSZWFkeSA9IHRydWVcclxuICAgIC8vICAgdGhpcy5yZXNldCgpOyB0aGlzLm1vZGVsUmVhZHkgPSB0cnVlXHJcbiAgICAvLyB9KVxyXG4gICAgdGhpcy5yZXNldCgpOyAvLyBSRU1JTkQ6IFRlbXBvcmFyeVxyXG4gIH1cclxuICAvLyBDYWxsIGZjbih0aGlzKSB3aGVuIGFueSBhc3luY1xyXG4gIC8vIHdoZW5SZWFkeSAoZmNuKSB7XHJcbiAgLy8gICAvLyB1dGlsLndhaXRQcm9taXNlKCgpID0+IHRoaXMubW9kZWxSZWFkeSkudGhlbihmY24oKSlcclxuICAvLyAgIHV0aWwud2FpdE9uKCgpID0+IHRoaXMubW9kZWxSZWFkeSwgKCkgPT4gZmNuKHRoaXMpKVxyXG4gIC8vIH1cclxuICAvLyBBZGQgYWRkaXRpb25hbCB3b3JsZCB2YXJpYWJsZXMgZGVyaXZlZCBmcm9tIGNvbnN0cnVjdG9yJ3MgYG1vZGVsT3B0aW9uc2AuXHJcbiAgLy8gc2V0V29ybGQgKCkge1xyXG4gIC8vICAgY29uc3Qgd29ybGQgPSB0aGlzLndvcmxkXHJcbiAgLy8gICAvLyBSRU1JTkQ6IGNoYW5nZSB0byB4UGF0Y2hlcywgeVBhdGNoZXM/XHJcbiAgLy8gICB3b3JsZC5udW1YID0gd29ybGQubWF4WCAtIHdvcmxkLm1pblggKyAxXHJcbiAgLy8gICB3b3JsZC5udW1ZID0gd29ybGQubWF4WSAtIHdvcmxkLm1pblkgKyAxXHJcbiAgLy8gICB3b3JsZC53aWR0aCA9IHdvcmxkLm51bVggKiB3b3JsZC5wYXRjaFNpemVcclxuICAvLyAgIHdvcmxkLmhlaWdodCA9IHdvcmxkLm51bVkgKiB3b3JsZC5wYXRjaFNpemVcclxuICAvLyAgIHdvcmxkLm1pblhjb3IgPSB3b3JsZC5taW5YIC0gMC41XHJcbiAgLy8gICB3b3JsZC5tYXhYY29yID0gd29ybGQubWF4WCArIDAuNVxyXG4gIC8vICAgd29ybGQubWluWWNvciA9IHdvcmxkLm1pblkgLSAwLjVcclxuICAvLyAgIHdvcmxkLm1heFljb3IgPSB3b3JsZC5tYXhZICsgMC41XHJcbiAgLy8gICB3b3JsZC5pc09uV29ybGQgPSAoeCwgeSkgPT4gLy8gTm8gYnJhY2VzLCBpcyBsYW1iZGEgZXhwcmVzc2lvblxyXG4gIC8vICAgICAod29ybGQubWluWGNvciA8PSB4KSAmJiAoeCA8PSB3b3JsZC5tYXhYY29yKSAmJlxyXG4gIC8vICAgICAod29ybGQubWluWWNvciA8PSB5KSAmJiAoeSA8PSB3b3JsZC5tYXhZY29yKVxyXG4gIC8vIH1cclxuICAvLyBjcmVhdGVRdWFkIChyLCB6ID0gMCkgeyAvLyByIGlzIHJhZGl1cyBvZiB4eSBxdWFkOiBbLXIsK3JdLCB6IGlzIHF1YWQgelxyXG4gIC8vICAgY29uc3QgdmVydGljZXMgPSBbLXIsIC1yLCB6LCByLCAtciwgeiwgciwgciwgeiwgLXIsIHIsIHpdXHJcbiAgLy8gICBjb25zdCBpbmRpY2VzID0gWzAsIDEsIDIsIDAsIDIsIDNdXHJcbiAgLy8gICByZXR1cm4ge3ZlcnRpY2VzLCBpbmRpY2VzfVxyXG4gIC8vIH1cclxuICAvLyAoUmUpaW5pdGlhbGl6ZSB0aGUgbW9kZWwuIFJFTUlORDogbm90IHF1aXRlIHJpZ2h0XHJcbiAgLy8gc2V0QWdlbnRTZXRWaWV3UHJvcHMgKGFnZW50U2V0LCBtZXNoKSB7XHJcbiAgLy8gICBhZ2VudFNldC5pc01vbm9jaHJvbWUgPSBtZXNoLmlzTW9ub2Nocm9tZSgpXHJcbiAgLy8gICBhZ2VudFNldC51c2VTcHJpdGVzID0gbWVzaC51c2VTcHJpdGVzKClcclxuICAvLyB9XHJcbiAgaW5pdEFnZW50U2V0IChuYW1lLCBBZ2VudHNldENsYXNzLCBBZ2VudENsYXNzKSB7XHJcbiAgICBjb25zdCBhZ2VudHNldCA9IG5ldyBBZ2VudHNldENsYXNzKHRoaXMsIEFnZW50Q2xhc3MsIG5hbWUpO1xyXG4gICAgY29uc3QgbWVzaCA9IHRoaXMubWVzaGVzW25hbWVdO1xyXG4gICAgLy8gY29uc3QgbWVzaE5hbWUgPSBtZXNoLmNvbnN0cnVjdG9yLm5hbWVcclxuICAgIHRoaXNbbmFtZV0gPSBhZ2VudHNldDtcclxuICAgIC8vIGFnZW50c2V0LnNldERlZmF1bHQoJ3JlbmRlcmVyJywgbWVzaClcclxuICAgIGFnZW50c2V0LnJlbmRlcmVyID0gbWVzaDtcclxuICAgIGlmIChtZXNoLmZpeGVkQ29sb3IpIGFnZW50c2V0LnNldERlZmF1bHQoJ2NvbG9yJywgbWVzaC5maXhlZENvbG9yKTtcclxuICAgIC8vIFJFTUlORDogVHVydGxlcyBvbmx5P1xyXG4gICAgaWYgKG1lc2guZml4ZWRTaGFwZSkgYWdlbnRzZXQuc2V0RGVmYXVsdCgnc2hhcGUnLCBtZXNoLmZpeGVkU2hhcGUpO1xyXG4gICAgLy8gdGhpcy5hZ2VudHNldC5maXhlZENvbG9yID0gYWdlbnRzZXQucmVuZGVyZXIub3B0aW9ucy5jb2xvclxyXG4gICAgLy8gYWdlbnRzZXQudXNlU3ByaXRlcyA9IG1lc2hOYW1lIGluIFsnUG9pbnRTcHJpdGVzTWVzaCcsICdRdWFkU3ByaXRlc01lc2gnXVxyXG4gICAgLy8gYWdlbnRzZXQuZml4ZWRDb2xvciA9IGFnZW50c2V0LnJlbmRlcmVyLm9wdGlvbnMuY29sb3JcclxuICAgIC8vIGFnZW50c2V0LnVzZVNwcml0ZXMgPSBtZXNoTmFtZSBpbiBbJ1BvaW50U3ByaXRlc01lc2gnLCAnUXVhZFNwcml0ZXNNZXNoJ11cclxuICAgIC8vIGFnZW50c2V0LmZpeGVkU2hhcGUgPVxyXG4gICAgbWVzaC5pbml0KGFnZW50c2V0KTtcclxuICB9XHJcbiAgcmVzZXQgKHJlc3RhcnQgPSBmYWxzZSkge1xyXG4gICAgdGhpcy5hbmltLnJlc2V0KCk7XHJcbiAgICB0aGlzLndvcmxkLnNldFdvcmxkKCk7IC8vIGFsbG93IHdvcmxkIHRvIGNoYW5nZT9cclxuXHJcbiAgICB0aGlzLnJlZnJlc2hMaW5rcyA9IHRoaXMucmVmcmVzaFR1cnRsZXMgPSB0aGlzLnJlZnJlc2hQYXRjaGVzID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBCcmVlZHMgaGFuZGxlZCBieSBzZXR1cFxyXG4gICAgdGhpcy5pbml0QWdlbnRTZXQoJ3BhdGNoZXMnLCBQYXRjaGVzLCBQYXRjaCk7XHJcbiAgICB0aGlzLmluaXRBZ2VudFNldCgndHVydGxlcycsIFR1cnRsZXMsIFR1cnRsZSk7XHJcbiAgICB0aGlzLmluaXRBZ2VudFNldCgnbGlua3MnLCBMaW5rcywgTGluayk7XHJcbiAgICAvLyB0aGlzLnBhdGNoZXMgPSBuZXcgUGF0Y2hlcyh0aGlzLCBQYXRjaCwgJ3BhdGNoZXMnKVxyXG4gICAgLy8gdGhpcy5wYXRjaGVzLnJlbmRlcmVyID0gdGhpcy5tZXNoZXMucGF0Y2hlc1xyXG4gICAgLy8gdGhpcy5tZXNoZXMucGF0Y2hlcy5pbml0KHRoaXMucGF0Y2hlcylcclxuICAgIC8vIHRoaXMuc2V0QWdlbnRTZXRWaWV3UHJvcHModGhpcy5wYXRjaGVzLCB0aGlzLm1lc2hlcy5wYXRjaGVzKVxyXG4gICAgLy9cclxuICAgIC8vIHRoaXMudHVydGxlcyA9IG5ldyBUdXJ0bGVzKHRoaXMsIFR1cnRsZSwgJ3R1cnRsZXMnKVxyXG4gICAgLy8gdGhpcy50dXJ0bGVzLnJlbmRlcmVyID0gdGhpcy5tZXNoZXMudHVydGxlc1xyXG4gICAgLy8gdGhpcy5tZXNoZXMudHVydGxlcy5pbml0KHRoaXMudHVydGxlcylcclxuICAgIC8vIHRoaXMuc2V0QWdlbnRTZXRWaWV3UHJvcHModGhpcy50dXJ0bGVzLCB0aGlzLm1lc2hlcy50dXJ0bGVzKVxyXG4gICAgLy9cclxuICAgIC8vIHRoaXMubGlua3MgPSBuZXcgTGlua3ModGhpcywgTGluaywgJ2xpbmtzJylcclxuICAgIC8vIHRoaXMudHVydGxlcy5saW5rcyA9IHRoaXMubWVzaGVzLmxpbmtzXHJcbiAgICAvLyB0aGlzLm1lc2hlcy5saW5rcy5pbml0KHRoaXMubGlua3MpXHJcbiAgICAvLyB0aGlzLnNldEFnZW50U2V0Vmlld1Byb3BzKHRoaXMubGlua3MsIHRoaXMubWVzaGVzLmxpbmtzKVxyXG5cclxuICAgIC8vIHRoaXMuc2V0dXAoKVxyXG4gICAgaWYgKHJlc3RhcnQpIHRoaXMuc3RhcnQoKTtcclxuICB9XHJcblxyXG4vLyAjIyMgVXNlciBNb2RlbCBDcmVhdGlvblxyXG4gIC8vIEEgdXNlcidzIG1vZGVsIGlzIG1hZGUgYnkgc3ViY2xhc3NpbmcgTW9kZWwgYW5kIG92ZXItcmlkaW5nIHRoZXNlXHJcbiAgLy8gdGhyZWUgYWJzdHJhY3QgbWV0aG9kcy4gYHN1cGVyYCBuZWVkIG5vdCBiZSBjYWxsZWQuXHJcblxyXG4gIHNldHVwICgpIHt9IC8vIFlvdXIgaW5pdGlhbGl6YXRpb24gY29kZSBnb2VzIGhlcmVcclxuICAvLyBVcGRhdGUvc3RlcCB5b3VyIG1vZGVsIGhlcmVcclxuICBzdGVwICgpIHt9IC8vIGNhbGxlZCBlYWNoIHN0ZXAgb2YgdGhlIGFuaW1hdGlvblxyXG5cclxuICAvLyBTdGFydC9zdG9wIHRoZSBhbmltYXRpb24uIFJldHVybiBtb2RlbCBmb3IgY2hhaW5pbmcuXHJcbiAgc3RhcnQgKCkge1xyXG4gICAgLy8gdXRpbC53YWl0T24oKCkgPT4gdGhpcy5tb2RlbFJlYWR5LCAoKSA9PiB7XHJcbiAgICAvLyAgIHRoaXMuYW5pbS5zdGFydCgpXHJcbiAgICAvLyB9KVxyXG4gICAgdGhpcy5hbmltLnN0YXJ0KCk7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICBzdG9wICgpIHsgdGhpcy5hbmltLnN0b3AoKTsgfVxyXG4gIC8vIEFuaW1hdGUgb25jZSBieSBgc3RlcCgpOyBkcmF3KClgLlxyXG4gIG9uY2UgKCkgeyB0aGlzLnN0b3AoKTsgdGhpcy5hbmltLm9uY2UoKTsgfSAvLyBzdG9wIGlzIG5vLW9wIGlmIGFscmVhZHkgc3RvcHBlZFxyXG5cclxuICAvLyBDaGFuZ2UgdGhlIHdvcmxkIHBhcmFtZXRlcnMuIFJlcXVpcmVzIGEgcmVzZXQuXHJcbiAgLy8gUmVzZXRzIFBhdGNoZXMsIFR1cnRsZXMsIExpbmtzICYgcmVpbml0aWFsaXplcyBjYW52YXNlcy5cclxuICAvLyBJZiByZXN0YXJ0IGFyZ3VtZW50IGlzIHRydWUgKGRlZmF1bHQpLCB3aWxsIHJlc3RhcnQgYWZ0ZXIgcmVzZXR0aW5nLlxyXG4gIC8vIHJlc2l6ZVdvcmxkIChtb2RlbE9wdGlvbnMsIHJlc3RhcnQgPSB0cnVlKSB7XHJcbiAgLy8gICBPYmplY3QuYXNzaWduKHRoaXMud29ybGQsIG1vZGVsT3B0aW9ucylcclxuICAvLyAgIHRoaXMuc2V0V29ybGQodGhpcy53b3JsZClcclxuICAvLyAgIHRoaXMucmVzZXQocmVzdGFydClcclxuICAvLyB9XHJcblxyXG4gIGRyYXcgKGZvcmNlID0gdGhpcy5hbmltLnN0b3BwZWQgfHwgdGhpcy5hbmltLmRyYXdzID09PSAxKSB7XHJcbiAgICAvLyBjb25zdCB7c2NlbmUsIGNhbWVyYX0gPSB0aGlzLnZpZXdcclxuICAgIGlmICh0aGlzLmRpdikge1xyXG4gICAgICBpZiAoZm9yY2UgfHwgdGhpcy5yZWZyZXNoUGF0Y2hlcykge1xyXG4gICAgICAgIGlmICh0aGlzLnBhdGNoZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgIHRoaXMucGF0Y2hlcy5yZW5kZXJlci51cGRhdGUodGhpcy5wYXRjaGVzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZm9yY2UgfHwgdGhpcy5yZWZyZXNoVHVydGxlcykge1xyXG4gICAgICAgIGlmICh0aGlzLnR1cnRsZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgIHRoaXMudHVydGxlcy5yZW5kZXJlci51cGRhdGUodGhpcy50dXJ0bGVzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZm9yY2UgfHwgdGhpcy5yZWZyZXNoTGlua3MpIHtcclxuICAgICAgICBpZiAodGhpcy5saW5rcy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgdGhpcy5saW5rcy5yZW5kZXJlci51cGRhdGUodGhpcy5saW5rcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJFTUlORDogZ2VuZXJhbGl6ZS5cclxuICAgICAgdGhpcy52aWV3LnJlbmRlcmVyLnJlbmRlcih0aGlzLnZpZXcuc2NlbmUsIHRoaXMudmlldy5jYW1lcmEpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMudmlldy5zdGF0cykgdGhpcy52aWV3LnN0YXRzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQnJlZWRzOiBjcmVhdGUgYnJlZWRzL3N1YmFycmF5cyBvZiBQYXRjaGVzLCBBZ2VudHMsIExpbmtzXHJcbiAgcGF0Y2hCcmVlZHMgKGJyZWVkTmFtZXMpIHtcclxuICAgIGZvciAoY29uc3QgYnJlZWROYW1lIG9mIGJyZWVkTmFtZXMuc3BsaXQoJyAnKSkge1xyXG4gICAgICB0aGlzW2JyZWVkTmFtZV0gPSB0aGlzLnBhdGNoZXMubmV3QnJlZWQoYnJlZWROYW1lKTtcclxuICAgIH1cclxuICB9XHJcbiAgdHVydGxlQnJlZWRzIChicmVlZE5hbWVzKSB7XHJcbiAgICBmb3IgKGNvbnN0IGJyZWVkTmFtZSBvZiBicmVlZE5hbWVzLnNwbGl0KCcgJykpIHtcclxuICAgICAgdGhpc1ticmVlZE5hbWVdID0gdGhpcy50dXJ0bGVzLm5ld0JyZWVkKGJyZWVkTmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGxpbmtCcmVlZHMgKGJyZWVkTmFtZXMpIHtcclxuICAgIGZvciAoY29uc3QgYnJlZWROYW1lIG9mIGJyZWVkTmFtZXMuc3BsaXQoJyAnKSkge1xyXG4gICAgICB0aGlzW2JyZWVkTmFtZV0gPSB0aGlzLmxpbmtzLm5ld0JyZWVkKGJyZWVkTmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQYXJzZSBhbiBSR0JBIGltYWdlIHRvIGEgRGF0YVNldCBvZiB0aGUgZ2l2ZW4gdHlwZS5cclxuLy8gV2UgdXNlIGFsbCA0IGJ5dGVzIG9mIHRoZSBwaXhlbHMsIHRodXMgbWFwIGV4YWN0bHkgb250b1xyXG4vLyBtdWx0aXBsZXMgYWxsIFtUeXBlZEFycmF5XShodHRwczovL2dvby5nbC8zT09RenkpIHNpemVzLlxyXG5jbGFzcyBSR0JBRGF0YVNldCBleHRlbmRzIERhdGFTZXQge1xyXG4gIGNvbnN0cnVjdG9yIChpbWcsIFR5cGUgPSBGbG9hdDMyQXJyYXksIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgYnl0ZXMgPSB1dGlsLmltYWdlVG9CeXRlcyhpbWcpO1xyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBUeXBlKGJ5dGVzLmJ1ZmZlcik7IC8vIFBhcnNlIHZpYSBhIFR5cGUgdmlldyBvbiB0aGUgYnVmZmVyXHJcbiAgICBjb25zdCBkYXRhUGVyUGl4ZWwgPSA0ICogZGF0YS5sZW5ndGggLyBieXRlcy5sZW5ndGg7XHJcbiAgICBjb25zdCB3aWR0aCA9IGRhdGFQZXJQaXhlbCAqIGltZy53aWR0aDtcclxuICAgIGNvbnN0IGhlaWdodCA9IGltZy5oZWlnaHQ7XHJcbiAgICBzdXBlcih3aWR0aCwgaGVpZ2h0LCBkYXRhKTtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XHJcbiAgICB0aGlzLnNyYyA9IGltZy5zcmM7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBSR0JEYXRhU2V0IGV4dGVuZHMgRGF0YVNldCB7XHJcblxyXG4gIGNvbnN0cnVjdG9yIChpbWcsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCBuZXcgRmxvYXQzMkFycmF5KGltZy53aWR0aCAqIGltZy5oZWlnaHQpKTtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XHJcbiAgICBjb25zdCBjdHggPSB1dGlsLmNyZWF0ZUN0eChpbWcud2lkdGgsIGltZy5oZWlnaHQpO1xyXG4gICAgdXRpbC5maWxsQ3R4V2l0aEltYWdlKGN0eCwgaW1nKTtcclxuICAgIGNvbnN0IGltZ0RhdGEgPSB1dGlsLmN0eEltYWdlRGF0YShjdHgpO1xyXG4gICAgY29uc3QgY29udmVydGVkRGF0YSA9IHRoaXMuZGF0YTsgLy8gbmV3IEZsb2F0MzJBcnJheShpbWcud2lkdGggKiBpbWcuaGVpZ2h0KVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb252ZXJ0ZWREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHIgPSBpbWdEYXRhLmRhdGFbNCAqIGldO1xyXG4gICAgICBjb25zdCBnID0gaW1nRGF0YS5kYXRhWzQgKiBpICsgMV07XHJcbiAgICAgIGNvbnN0IGIgPSBpbWdEYXRhLmRhdGFbNCAqIGkgKyAyXTtcclxuICAgICAgY29udmVydGVkRGF0YVtpXSA9IHRoaXMucmdiMk51bWJlcihyLCBnLCBiKTtcclxuICAgIH1cclxuICAgIHRoaXMuc3JjID0gaW1nLnNyYztcclxuICAgIHRoaXMuY3R4ID0gY3R4OyAvLyBSRU1JTkQ6IGRlYnVnXHJcbiAgICAvLyB2YXIgbXlkYXRhID0gbmV3IERhdGFTZXQoaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCBjb252ZXJ0ZWREYXRhKVxyXG4gICAgLy8gcmV0dXJuIG15ZGF0YVxyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBSR0IgdG8gYSBudW1iZXIuXHJcbiAgLy8gYnkgZGVmYXVsdCB0aGlzIGFzc3VtZXMgdGhlIHZhbHVlcyBhcmUgaW4gZGVjaW1ldGVycywgYnV0IGl0IGNhbiBiZSBvdmVyd3JpdHRlbi5cclxuICAvLyAgVGhpcyBmdW5uY3Rpb24gZ2V0cyBjYWxsZWQgaW4gYSB0aWdodCBsb29wIGZvciBldmVyeSBwaXhlbC5cclxuICByZ2IyTnVtYmVyIChyLCBnLCBiKSB7XHJcbiAgICB2YXIgbmVnYXRpdmUgPSAxO1xyXG4gICAgaWYgKHIgPiA2Mykge1xyXG4gICAgICBuZWdhdGl2ZSA9IC0xO1xyXG4gICAgICByID0gMDtcclxuICAgIH1cclxuICAgIHZhciBuID0gbmVnYXRpdmUgKiAociAqIDI1NiAqIDI1NiArIGcgKiAyNTYgKyBiKTtcclxuICAgIG4gPSBuIC8gMTA7XHJcbiAgICByZXR1cm4gblxyXG4gIH1cclxufVxyXG5cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuXHJcbmV4cG9ydCB7IEFnZW50U2V0LCBBbmltYXRvciwgQXNjRGF0YVNldCwgQ29sb3IsIENvbG9yTWFwLCBEYXRhU2V0LCBEYXRhU2V0SU8sIEludDI0LCBMaW5rLCBMaW5rcywgTW9kZWwsIFBhdGNoLCBQYXRjaGVzLCBSR0JBRGF0YVNldCwgUkdCRGF0YVNldCwgU3ByaXRlU2hlZXQsIFRocmVlLCBNZXNoZXMgYXMgVGhyZWVNZXNoZXMsIFR1cnRsZSwgVHVydGxlcywgV29ybGQsIHV0aWwgfTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXN4LWFibS9kaXN0L0FTLm1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ })

});